// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'update_info.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

UpdateInfo _$UpdateInfoFromJson(Map<String, dynamic> json) {
  return _UpdateInfo.fromJson(json);
}

/// @nodoc
mixin _$UpdateInfo {
  double get cpuLoad1 => throw _privateConstructorUsedError;
  double get cpuLoad15 => throw _privateConstructorUsedError;
  double get cpuLoad5 => throw _privateConstructorUsedError;
  int get diskAvailable => throw _privateConstructorUsedError;
  int get diskUsed => throw _privateConstructorUsedError;
  int get diskUsedPercent => throw _privateConstructorUsedError;
  int get lastUpdate => throw _privateConstructorUsedError;
  int get memTotal => throw _privateConstructorUsedError;
  int get memUsed => throw _privateConstructorUsedError;
  List<SensorInfo> get sensors => throw _privateConstructorUsedError;
  int get swapTotal => throw _privateConstructorUsedError;
  int get swapUsed => throw _privateConstructorUsedError;
  String get uptime => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UpdateInfoCopyWith<UpdateInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateInfoCopyWith<$Res> {
  factory $UpdateInfoCopyWith(
          UpdateInfo value, $Res Function(UpdateInfo) then) =
      _$UpdateInfoCopyWithImpl<$Res, UpdateInfo>;
  @useResult
  $Res call(
      {double cpuLoad1,
      double cpuLoad15,
      double cpuLoad5,
      int diskAvailable,
      int diskUsed,
      int diskUsedPercent,
      int lastUpdate,
      int memTotal,
      int memUsed,
      List<SensorInfo> sensors,
      int swapTotal,
      int swapUsed,
      String uptime});
}

/// @nodoc
class _$UpdateInfoCopyWithImpl<$Res, $Val extends UpdateInfo>
    implements $UpdateInfoCopyWith<$Res> {
  _$UpdateInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cpuLoad1 = null,
    Object? cpuLoad15 = null,
    Object? cpuLoad5 = null,
    Object? diskAvailable = null,
    Object? diskUsed = null,
    Object? diskUsedPercent = null,
    Object? lastUpdate = null,
    Object? memTotal = null,
    Object? memUsed = null,
    Object? sensors = null,
    Object? swapTotal = null,
    Object? swapUsed = null,
    Object? uptime = null,
  }) {
    return _then(_value.copyWith(
      cpuLoad1: null == cpuLoad1
          ? _value.cpuLoad1
          : cpuLoad1 // ignore: cast_nullable_to_non_nullable
              as double,
      cpuLoad15: null == cpuLoad15
          ? _value.cpuLoad15
          : cpuLoad15 // ignore: cast_nullable_to_non_nullable
              as double,
      cpuLoad5: null == cpuLoad5
          ? _value.cpuLoad5
          : cpuLoad5 // ignore: cast_nullable_to_non_nullable
              as double,
      diskAvailable: null == diskAvailable
          ? _value.diskAvailable
          : diskAvailable // ignore: cast_nullable_to_non_nullable
              as int,
      diskUsed: null == diskUsed
          ? _value.diskUsed
          : diskUsed // ignore: cast_nullable_to_non_nullable
              as int,
      diskUsedPercent: null == diskUsedPercent
          ? _value.diskUsedPercent
          : diskUsedPercent // ignore: cast_nullable_to_non_nullable
              as int,
      lastUpdate: null == lastUpdate
          ? _value.lastUpdate
          : lastUpdate // ignore: cast_nullable_to_non_nullable
              as int,
      memTotal: null == memTotal
          ? _value.memTotal
          : memTotal // ignore: cast_nullable_to_non_nullable
              as int,
      memUsed: null == memUsed
          ? _value.memUsed
          : memUsed // ignore: cast_nullable_to_non_nullable
              as int,
      sensors: null == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<SensorInfo>,
      swapTotal: null == swapTotal
          ? _value.swapTotal
          : swapTotal // ignore: cast_nullable_to_non_nullable
              as int,
      swapUsed: null == swapUsed
          ? _value.swapUsed
          : swapUsed // ignore: cast_nullable_to_non_nullable
              as int,
      uptime: null == uptime
          ? _value.uptime
          : uptime // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UpdateInfoImplCopyWith<$Res>
    implements $UpdateInfoCopyWith<$Res> {
  factory _$$UpdateInfoImplCopyWith(
          _$UpdateInfoImpl value, $Res Function(_$UpdateInfoImpl) then) =
      __$$UpdateInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double cpuLoad1,
      double cpuLoad15,
      double cpuLoad5,
      int diskAvailable,
      int diskUsed,
      int diskUsedPercent,
      int lastUpdate,
      int memTotal,
      int memUsed,
      List<SensorInfo> sensors,
      int swapTotal,
      int swapUsed,
      String uptime});
}

/// @nodoc
class __$$UpdateInfoImplCopyWithImpl<$Res>
    extends _$UpdateInfoCopyWithImpl<$Res, _$UpdateInfoImpl>
    implements _$$UpdateInfoImplCopyWith<$Res> {
  __$$UpdateInfoImplCopyWithImpl(
      _$UpdateInfoImpl _value, $Res Function(_$UpdateInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cpuLoad1 = null,
    Object? cpuLoad15 = null,
    Object? cpuLoad5 = null,
    Object? diskAvailable = null,
    Object? diskUsed = null,
    Object? diskUsedPercent = null,
    Object? lastUpdate = null,
    Object? memTotal = null,
    Object? memUsed = null,
    Object? sensors = null,
    Object? swapTotal = null,
    Object? swapUsed = null,
    Object? uptime = null,
  }) {
    return _then(_$UpdateInfoImpl(
      cpuLoad1: null == cpuLoad1
          ? _value.cpuLoad1
          : cpuLoad1 // ignore: cast_nullable_to_non_nullable
              as double,
      cpuLoad15: null == cpuLoad15
          ? _value.cpuLoad15
          : cpuLoad15 // ignore: cast_nullable_to_non_nullable
              as double,
      cpuLoad5: null == cpuLoad5
          ? _value.cpuLoad5
          : cpuLoad5 // ignore: cast_nullable_to_non_nullable
              as double,
      diskAvailable: null == diskAvailable
          ? _value.diskAvailable
          : diskAvailable // ignore: cast_nullable_to_non_nullable
              as int,
      diskUsed: null == diskUsed
          ? _value.diskUsed
          : diskUsed // ignore: cast_nullable_to_non_nullable
              as int,
      diskUsedPercent: null == diskUsedPercent
          ? _value.diskUsedPercent
          : diskUsedPercent // ignore: cast_nullable_to_non_nullable
              as int,
      lastUpdate: null == lastUpdate
          ? _value.lastUpdate
          : lastUpdate // ignore: cast_nullable_to_non_nullable
              as int,
      memTotal: null == memTotal
          ? _value.memTotal
          : memTotal // ignore: cast_nullable_to_non_nullable
              as int,
      memUsed: null == memUsed
          ? _value.memUsed
          : memUsed // ignore: cast_nullable_to_non_nullable
              as int,
      sensors: null == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<SensorInfo>,
      swapTotal: null == swapTotal
          ? _value.swapTotal
          : swapTotal // ignore: cast_nullable_to_non_nullable
              as int,
      swapUsed: null == swapUsed
          ? _value.swapUsed
          : swapUsed // ignore: cast_nullable_to_non_nullable
              as int,
      uptime: null == uptime
          ? _value.uptime
          : uptime // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UpdateInfoImpl implements _UpdateInfo {
  const _$UpdateInfoImpl(
      {required this.cpuLoad1,
      required this.cpuLoad15,
      required this.cpuLoad5,
      required this.diskAvailable,
      required this.diskUsed,
      required this.diskUsedPercent,
      required this.lastUpdate,
      required this.memTotal,
      required this.memUsed,
      required final List<SensorInfo> sensors,
      required this.swapTotal,
      required this.swapUsed,
      required this.uptime})
      : _sensors = sensors;

  factory _$UpdateInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$UpdateInfoImplFromJson(json);

  @override
  final double cpuLoad1;
  @override
  final double cpuLoad15;
  @override
  final double cpuLoad5;
  @override
  final int diskAvailable;
  @override
  final int diskUsed;
  @override
  final int diskUsedPercent;
  @override
  final int lastUpdate;
  @override
  final int memTotal;
  @override
  final int memUsed;
  final List<SensorInfo> _sensors;
  @override
  List<SensorInfo> get sensors {
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sensors);
  }

  @override
  final int swapTotal;
  @override
  final int swapUsed;
  @override
  final String uptime;

  @override
  String toString() {
    return 'UpdateInfo(cpuLoad1: $cpuLoad1, cpuLoad15: $cpuLoad15, cpuLoad5: $cpuLoad5, diskAvailable: $diskAvailable, diskUsed: $diskUsed, diskUsedPercent: $diskUsedPercent, lastUpdate: $lastUpdate, memTotal: $memTotal, memUsed: $memUsed, sensors: $sensors, swapTotal: $swapTotal, swapUsed: $swapUsed, uptime: $uptime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateInfoImpl &&
            (identical(other.cpuLoad1, cpuLoad1) ||
                other.cpuLoad1 == cpuLoad1) &&
            (identical(other.cpuLoad15, cpuLoad15) ||
                other.cpuLoad15 == cpuLoad15) &&
            (identical(other.cpuLoad5, cpuLoad5) ||
                other.cpuLoad5 == cpuLoad5) &&
            (identical(other.diskAvailable, diskAvailable) ||
                other.diskAvailable == diskAvailable) &&
            (identical(other.diskUsed, diskUsed) ||
                other.diskUsed == diskUsed) &&
            (identical(other.diskUsedPercent, diskUsedPercent) ||
                other.diskUsedPercent == diskUsedPercent) &&
            (identical(other.lastUpdate, lastUpdate) ||
                other.lastUpdate == lastUpdate) &&
            (identical(other.memTotal, memTotal) ||
                other.memTotal == memTotal) &&
            (identical(other.memUsed, memUsed) || other.memUsed == memUsed) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors) &&
            (identical(other.swapTotal, swapTotal) ||
                other.swapTotal == swapTotal) &&
            (identical(other.swapUsed, swapUsed) ||
                other.swapUsed == swapUsed) &&
            (identical(other.uptime, uptime) || other.uptime == uptime));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      cpuLoad1,
      cpuLoad15,
      cpuLoad5,
      diskAvailable,
      diskUsed,
      diskUsedPercent,
      lastUpdate,
      memTotal,
      memUsed,
      const DeepCollectionEquality().hash(_sensors),
      swapTotal,
      swapUsed,
      uptime);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateInfoImplCopyWith<_$UpdateInfoImpl> get copyWith =>
      __$$UpdateInfoImplCopyWithImpl<_$UpdateInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UpdateInfoImplToJson(
      this,
    );
  }
}

abstract class _UpdateInfo implements UpdateInfo {
  const factory _UpdateInfo(
      {required final double cpuLoad1,
      required final double cpuLoad15,
      required final double cpuLoad5,
      required final int diskAvailable,
      required final int diskUsed,
      required final int diskUsedPercent,
      required final int lastUpdate,
      required final int memTotal,
      required final int memUsed,
      required final List<SensorInfo> sensors,
      required final int swapTotal,
      required final int swapUsed,
      required final String uptime}) = _$UpdateInfoImpl;

  factory _UpdateInfo.fromJson(Map<String, dynamic> json) =
      _$UpdateInfoImpl.fromJson;

  @override
  double get cpuLoad1;
  @override
  double get cpuLoad15;
  @override
  double get cpuLoad5;
  @override
  int get diskAvailable;
  @override
  int get diskUsed;
  @override
  int get diskUsedPercent;
  @override
  int get lastUpdate;
  @override
  int get memTotal;
  @override
  int get memUsed;
  @override
  List<SensorInfo> get sensors;
  @override
  int get swapTotal;
  @override
  int get swapUsed;
  @override
  String get uptime;
  @override
  @JsonKey(ignore: true)
  _$$UpdateInfoImplCopyWith<_$UpdateInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
