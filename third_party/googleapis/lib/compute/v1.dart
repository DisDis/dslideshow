// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: file_names
// ignore_for_file: library_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_expression_function_bodies
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

/// Compute Engine API - v1
///
/// Creates and runs virtual machines on Google Cloud Platform.
///
/// For more information, see
/// <https://developers.google.com/compute/docs/reference/latest/>
///
/// Create an instance of [ComputeApi] to access these resources:
///
/// - [AcceleratorTypesResource]
/// - [AddressesResource]
/// - [AutoscalersResource]
/// - [BackendBucketsResource]
/// - [BackendServicesResource]
/// - [DiskTypesResource]
/// - [DisksResource]
/// - [ExternalVpnGatewaysResource]
/// - [FirewallPoliciesResource]
/// - [FirewallsResource]
/// - [ForwardingRulesResource]
/// - [GlobalAddressesResource]
/// - [GlobalForwardingRulesResource]
/// - [GlobalNetworkEndpointGroupsResource]
/// - [GlobalOperationsResource]
/// - [GlobalOrganizationOperationsResource]
/// - [HealthChecksResource]
/// - [HttpHealthChecksResource]
/// - [HttpsHealthChecksResource]
/// - [ImagesResource]
/// - [InstanceGroupManagersResource]
/// - [InstanceGroupsResource]
/// - [InstanceTemplatesResource]
/// - [InstancesResource]
/// - [InterconnectAttachmentsResource]
/// - [InterconnectLocationsResource]
/// - [InterconnectsResource]
/// - [LicenseCodesResource]
/// - [LicensesResource]
/// - [MachineTypesResource]
/// - [NetworkEndpointGroupsResource]
/// - [NetworksResource]
/// - [NodeGroupsResource]
/// - [NodeTemplatesResource]
/// - [NodeTypesResource]
/// - [PacketMirroringsResource]
/// - [ProjectsResource]
/// - [RegionAutoscalersResource]
/// - [RegionBackendServicesResource]
/// - [RegionCommitmentsResource]
/// - [RegionDiskTypesResource]
/// - [RegionDisksResource]
/// - [RegionHealthCheckServicesResource]
/// - [RegionHealthChecksResource]
/// - [RegionInstanceGroupManagersResource]
/// - [RegionInstanceGroupsResource]
/// - [RegionInstancesResource]
/// - [RegionNetworkEndpointGroupsResource]
/// - [RegionNotificationEndpointsResource]
/// - [RegionOperationsResource]
/// - [RegionSslCertificatesResource]
/// - [RegionTargetHttpProxiesResource]
/// - [RegionTargetHttpsProxiesResource]
/// - [RegionUrlMapsResource]
/// - [RegionsResource]
/// - [ReservationsResource]
/// - [ResourcePoliciesResource]
/// - [RoutersResource]
/// - [RoutesResource]
/// - [SecurityPoliciesResource]
/// - [SnapshotsResource]
/// - [SslCertificatesResource]
/// - [SslPoliciesResource]
/// - [SubnetworksResource]
/// - [TargetGrpcProxiesResource]
/// - [TargetHttpProxiesResource]
/// - [TargetHttpsProxiesResource]
/// - [TargetInstancesResource]
/// - [TargetPoolsResource]
/// - [TargetSslProxiesResource]
/// - [TargetTcpProxiesResource]
/// - [TargetVpnGatewaysResource]
/// - [UrlMapsResource]
/// - [VpnGatewaysResource]
/// - [VpnTunnelsResource]
/// - [ZoneOperationsResource]
/// - [ZonesResource]
library compute.v1;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

/// Creates and runs virtual machines on Google Cloud Platform.
class ComputeApi {
  /// View and manage your data across Google Cloud Platform services
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View and manage your Google Compute Engine resources
  static const computeScope = 'https://www.googleapis.com/auth/compute';

  /// View your Google Compute Engine resources
  static const computeReadonlyScope =
      'https://www.googleapis.com/auth/compute.readonly';

  /// Manage your data and permissions in Google Cloud Storage
  static const devstorageFullControlScope =
      'https://www.googleapis.com/auth/devstorage.full_control';

  /// View your data in Google Cloud Storage
  static const devstorageReadOnlyScope =
      'https://www.googleapis.com/auth/devstorage.read_only';

  /// Manage your data in Google Cloud Storage
  static const devstorageReadWriteScope =
      'https://www.googleapis.com/auth/devstorage.read_write';

  final commons.ApiRequester _requester;

  AcceleratorTypesResource get acceleratorTypes =>
      AcceleratorTypesResource(_requester);
  AddressesResource get addresses => AddressesResource(_requester);
  AutoscalersResource get autoscalers => AutoscalersResource(_requester);
  BackendBucketsResource get backendBuckets =>
      BackendBucketsResource(_requester);
  BackendServicesResource get backendServices =>
      BackendServicesResource(_requester);
  DiskTypesResource get diskTypes => DiskTypesResource(_requester);
  DisksResource get disks => DisksResource(_requester);
  ExternalVpnGatewaysResource get externalVpnGateways =>
      ExternalVpnGatewaysResource(_requester);
  FirewallPoliciesResource get firewallPolicies =>
      FirewallPoliciesResource(_requester);
  FirewallsResource get firewalls => FirewallsResource(_requester);
  ForwardingRulesResource get forwardingRules =>
      ForwardingRulesResource(_requester);
  GlobalAddressesResource get globalAddresses =>
      GlobalAddressesResource(_requester);
  GlobalForwardingRulesResource get globalForwardingRules =>
      GlobalForwardingRulesResource(_requester);
  GlobalNetworkEndpointGroupsResource get globalNetworkEndpointGroups =>
      GlobalNetworkEndpointGroupsResource(_requester);
  GlobalOperationsResource get globalOperations =>
      GlobalOperationsResource(_requester);
  GlobalOrganizationOperationsResource get globalOrganizationOperations =>
      GlobalOrganizationOperationsResource(_requester);
  HealthChecksResource get healthChecks => HealthChecksResource(_requester);
  HttpHealthChecksResource get httpHealthChecks =>
      HttpHealthChecksResource(_requester);
  HttpsHealthChecksResource get httpsHealthChecks =>
      HttpsHealthChecksResource(_requester);
  ImagesResource get images => ImagesResource(_requester);
  InstanceGroupManagersResource get instanceGroupManagers =>
      InstanceGroupManagersResource(_requester);
  InstanceGroupsResource get instanceGroups =>
      InstanceGroupsResource(_requester);
  InstanceTemplatesResource get instanceTemplates =>
      InstanceTemplatesResource(_requester);
  InstancesResource get instances => InstancesResource(_requester);
  InterconnectAttachmentsResource get interconnectAttachments =>
      InterconnectAttachmentsResource(_requester);
  InterconnectLocationsResource get interconnectLocations =>
      InterconnectLocationsResource(_requester);
  InterconnectsResource get interconnects => InterconnectsResource(_requester);
  LicenseCodesResource get licenseCodes => LicenseCodesResource(_requester);
  LicensesResource get licenses => LicensesResource(_requester);
  MachineTypesResource get machineTypes => MachineTypesResource(_requester);
  NetworkEndpointGroupsResource get networkEndpointGroups =>
      NetworkEndpointGroupsResource(_requester);
  NetworksResource get networks => NetworksResource(_requester);
  NodeGroupsResource get nodeGroups => NodeGroupsResource(_requester);
  NodeTemplatesResource get nodeTemplates => NodeTemplatesResource(_requester);
  NodeTypesResource get nodeTypes => NodeTypesResource(_requester);
  PacketMirroringsResource get packetMirrorings =>
      PacketMirroringsResource(_requester);
  ProjectsResource get projects => ProjectsResource(_requester);
  RegionAutoscalersResource get regionAutoscalers =>
      RegionAutoscalersResource(_requester);
  RegionBackendServicesResource get regionBackendServices =>
      RegionBackendServicesResource(_requester);
  RegionCommitmentsResource get regionCommitments =>
      RegionCommitmentsResource(_requester);
  RegionDiskTypesResource get regionDiskTypes =>
      RegionDiskTypesResource(_requester);
  RegionDisksResource get regionDisks => RegionDisksResource(_requester);
  RegionHealthCheckServicesResource get regionHealthCheckServices =>
      RegionHealthCheckServicesResource(_requester);
  RegionHealthChecksResource get regionHealthChecks =>
      RegionHealthChecksResource(_requester);
  RegionInstanceGroupManagersResource get regionInstanceGroupManagers =>
      RegionInstanceGroupManagersResource(_requester);
  RegionInstanceGroupsResource get regionInstanceGroups =>
      RegionInstanceGroupsResource(_requester);
  RegionInstancesResource get regionInstances =>
      RegionInstancesResource(_requester);
  RegionNetworkEndpointGroupsResource get regionNetworkEndpointGroups =>
      RegionNetworkEndpointGroupsResource(_requester);
  RegionNotificationEndpointsResource get regionNotificationEndpoints =>
      RegionNotificationEndpointsResource(_requester);
  RegionOperationsResource get regionOperations =>
      RegionOperationsResource(_requester);
  RegionSslCertificatesResource get regionSslCertificates =>
      RegionSslCertificatesResource(_requester);
  RegionTargetHttpProxiesResource get regionTargetHttpProxies =>
      RegionTargetHttpProxiesResource(_requester);
  RegionTargetHttpsProxiesResource get regionTargetHttpsProxies =>
      RegionTargetHttpsProxiesResource(_requester);
  RegionUrlMapsResource get regionUrlMaps => RegionUrlMapsResource(_requester);
  RegionsResource get regions => RegionsResource(_requester);
  ReservationsResource get reservations => ReservationsResource(_requester);
  ResourcePoliciesResource get resourcePolicies =>
      ResourcePoliciesResource(_requester);
  RoutersResource get routers => RoutersResource(_requester);
  RoutesResource get routes => RoutesResource(_requester);
  SecurityPoliciesResource get securityPolicies =>
      SecurityPoliciesResource(_requester);
  SnapshotsResource get snapshots => SnapshotsResource(_requester);
  SslCertificatesResource get sslCertificates =>
      SslCertificatesResource(_requester);
  SslPoliciesResource get sslPolicies => SslPoliciesResource(_requester);
  SubnetworksResource get subnetworks => SubnetworksResource(_requester);
  TargetGrpcProxiesResource get targetGrpcProxies =>
      TargetGrpcProxiesResource(_requester);
  TargetHttpProxiesResource get targetHttpProxies =>
      TargetHttpProxiesResource(_requester);
  TargetHttpsProxiesResource get targetHttpsProxies =>
      TargetHttpsProxiesResource(_requester);
  TargetInstancesResource get targetInstances =>
      TargetInstancesResource(_requester);
  TargetPoolsResource get targetPools => TargetPoolsResource(_requester);
  TargetSslProxiesResource get targetSslProxies =>
      TargetSslProxiesResource(_requester);
  TargetTcpProxiesResource get targetTcpProxies =>
      TargetTcpProxiesResource(_requester);
  TargetVpnGatewaysResource get targetVpnGateways =>
      TargetVpnGatewaysResource(_requester);
  UrlMapsResource get urlMaps => UrlMapsResource(_requester);
  VpnGatewaysResource get vpnGateways => VpnGatewaysResource(_requester);
  VpnTunnelsResource get vpnTunnels => VpnTunnelsResource(_requester);
  ZoneOperationsResource get zoneOperations =>
      ZoneOperationsResource(_requester);
  ZonesResource get zones => ZonesResource(_requester);

  ComputeApi(http.Client client,
      {core.String rootUrl = 'https://compute.googleapis.com/',
      core.String servicePath = 'compute/v1/'})
      : _requester =
            commons.ApiRequester(client, rootUrl, servicePath, requestHeaders);
}

class AcceleratorTypesResource {
  final commons.ApiRequester _requester;

  AcceleratorTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of accelerator types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/acceleratorTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified accelerator type.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [acceleratorType] - Name of the accelerator type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorType> get(
    core.String project,
    core.String zone,
    core.String acceleratorType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/acceleratorTypes/' +
        commons.escapeVariable('$acceleratorType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorType.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of accelerator types that are available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AcceleratorTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AcceleratorTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/acceleratorTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AcceleratorTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class AddressesResource {
  final commons.ApiRequester _requester;

  AddressesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String address, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String region,
    core.String address, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Address.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of addresses contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class AutoscalersResource {
  final commons.ApiRequester _requester;

  AutoscalersResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of autoscalers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AutoscalerAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified autoscaler resource.
  ///
  /// Gets a list of available autoscalers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String zone,
    core.String autoscaler, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Autoscaler.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of autoscalers contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AutoscalerList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AutoscalerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String zone, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class BackendBucketsResource {
  final commons.ApiRequester _requester;

  BackendBucketsResource(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket') +
        '/addSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified BackendBucket resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// bucket.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendBucket,
    core.String keyName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'keyName': [keyName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket') +
        '/deleteSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified BackendBucket resource.
  ///
  /// Gets a list of available backend buckets by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucket].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucket> get(
    core.String project,
    core.String backendBucket, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendBucket.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BackendBucket resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendBucket request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of BackendBucket resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendBucketList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendBucketList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendBucketList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendBucket resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendBucket] - Name of the BackendBucket resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendBucket request,
    core.String project,
    core.String backendBucket, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendBuckets/' +
        commons.escapeVariable('$backendBucket');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class BackendServicesResource {
  final commons.ApiRequester _requester;

  BackendServicesResource(commons.ApiRequester client) : _requester = client;

  /// Adds a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addSignedUrlKey(
    SignedUrlKey request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/addSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of all BackendService resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a key for validating requests with signed URLs for this backend
  /// service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the Signed
  /// URL Key should be added. The name should conform to RFC1035.
  ///
  /// [keyName] - The name of the Signed URL Key to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteSignedUrlKey(
    core.String project,
    core.String backendService,
    core.String keyName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'keyName': [keyName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/deleteSignedUrlKey';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified BackendService resource.
  ///
  /// Gets a list of available backend services.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for this BackendService.
  ///
  /// Example request body:
  ///
  /// { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// queried instance belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return BackendServiceGroupHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BackendService resource in the specified project using the data
  /// included in the request.
  ///
  /// For more information, see  Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of BackendService resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified BackendService resource with the data included in
  /// the request.
  ///
  /// For more information, see Backend services overview. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the security policy for the specified backend service.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to which the
  /// security policy should be set. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSecurityPolicy(
    SecurityPolicyReference request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/setSecurityPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified BackendService resource with the data included in
  /// the request.
  ///
  /// For more information, see Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class DiskTypesResource {
  final commons.ApiRequester _requester;

  DiskTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of disk types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified disk type.
  ///
  /// Gets a list of available disk types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String zone,
    core.String diskType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/diskTypes/' +
        commons.escapeVariable('$diskType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of disk types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class DisksResource {
  final commons.ApiRequester _requester;

  DisksResource(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a disk.
  ///
  /// You can only add one policy which will be applied to this disk for
  /// scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    DisksAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of persistent disks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/aggregated/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a snapshot of a specified persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to snapshot.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [guestFlush] - \[Input Only\] Whether to attempt an application consistent
  /// snapshot by informing the OS to prepare for the snapshot process.
  /// Currently only supported on Windows instances using the Volume Shadow Copy
  /// Service (VSS).
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.bool? guestFlush,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (guestFlush != null) 'guestFlush': ['${guestFlush}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/createSnapshot';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified persistent disk.
  ///
  /// Deleting a disk removes its data permanently and is irreversible. However,
  /// deleting a disk does not delete any snapshots previously made from the
  /// disk. You must separately delete snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns a specified persistent disk.
  ///
  /// Gets a list of available persistent disks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the persistent disk to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Disk.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a persistent disk in the specified project using the data in the
  /// request.
  ///
  /// You can create a disk from a source (sourceImage, sourceSnapshot, or
  /// sourceDisk) or create an empty 500 GB data disk by omitting all
  /// properties. You can also create a disk that is larger than the default
  /// size by specifying the sizeGb property.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Source image to restore onto a disk. This field is
  /// optional.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? sourceImage,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceImage != null) 'sourceImage': [sourceImage],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of persistent disks contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from a disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    DisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the specified persistent disk.
  ///
  /// You can only increase the size of the disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The name of the persistent disk.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    DisksResizeRequest request,
    core.String project,
    core.String zone,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a disk.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    ZoneSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ExternalVpnGatewaysResource {
  final commons.ApiRequester _requester;

  ExternalVpnGatewaysResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified externalVpnGateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateways to delete.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String externalVpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$externalVpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified externalVpnGateway.
  ///
  /// Get a list of available externalVpnGateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [externalVpnGateway] - Name of the externalVpnGateway to return.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGateway> get(
    core.String project,
    core.String externalVpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$externalVpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExternalVpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a ExternalVpnGateway in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ExternalVpnGateway request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of ExternalVpnGateway available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExternalVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExternalVpnGatewayList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExternalVpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on an ExternalVpnGateway.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/externalVpnGateways/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class FirewallPoliciesResource {
  final commons.ApiRequester _requester;

  FirewallPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Inserts an association for the specified firewall policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [replaceExistingAssociation] - Indicates whether or not to replace it if
  /// an association of the attachment already exists. This is false by default,
  /// in which case an error will be returned if an association already exists.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAssociation(
    FirewallPolicyAssociation request,
    core.String firewallPolicy, {
    core.bool? replaceExistingAssociation,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (replaceExistingAssociation != null)
        'replaceExistingAssociation': ['${replaceExistingAssociation}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/addAssociation';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts a rule into a firewall policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(
    FirewallPolicyRule request,
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/addRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Copies rules to the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceFirewallPolicy] - The firewall policy from which to copy rules.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> cloneRules(
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? sourceFirewallPolicy,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceFirewallPolicy != null)
        'sourceFirewallPolicy': [sourceFirewallPolicy],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/cloneRules';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to delete.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to get.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicy> get(
    core.String firewallPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets an association with the specified name.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to which the queried rule
  /// belongs.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [name] - The name of the association to get from the firewall policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyAssociation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyAssociation> getAssociation(
    core.String firewallPolicy, {
    core.String? name,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (name != null) 'name': [name],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/getAssociation';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyAssociation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets a rule of the specified priority.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to which the queried rule
  /// belongs.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to get from the firewall policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyRule> getRule(
    core.String firewallPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/getRule';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parentId] - Parent ID for this request. The ID can be either be
  /// "folders/\[FOLDER_ID\]" if the parent is a folder or
  /// "organizations/\[ORGANIZATION_ID\]" if the parent is an organization.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    FirewallPolicy request, {
    core.String? parentId,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the policies that have been configured for the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPolicyList> list({
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? parentId,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parentId != null) 'parentId': [parentId],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists associations of a specified target, i.e., organization or folder.
  ///
  /// Request parameters:
  ///
  /// [targetResource] - The target resource to list associations. It is an
  /// organization, or a folder.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallPoliciesListAssociationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallPoliciesListAssociationsResponse> listAssociations({
    core.String? targetResource,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (targetResource != null) 'targetResource': [targetResource],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/firewallPolicies/listAssociations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallPoliciesListAssociationsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Moves the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [parentId] - The new parent of the firewall policy.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> move(
    core.String firewallPolicy, {
    core.String? parentId,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/move';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    FirewallPolicy request,
    core.String firewallPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches a rule of the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(
    FirewallPolicyRule request,
    core.String firewallPolicy, {
    core.int? priority,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/patchRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes an association for the specified firewall policy.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [name] - Name for the attachment that will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeAssociation(
    core.String firewallPolicy, {
    core.String? name,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (name != null) 'name': [name],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/removeAssociation';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a rule of the specified priority.
  ///
  /// Request parameters:
  ///
  /// [firewallPolicy] - Name of the firewall policy to update.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [priority] - The priority of the rule to remove from the firewall policy.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
    core.String firewallPolicy, {
    core.int? priority,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$firewallPolicy') +
        '/removeRule';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalOrganizationSetPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern `(firewallPolicies/)?\[0-9\]{0,20}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'locations/global/firewallPolicies/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class FirewallsResource {
  final commons.ApiRequester _requester;

  FirewallsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified firewall.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Firewall].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Firewall> get(
    core.String project,
    core.String firewall, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Firewall.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a firewall rule in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Firewall request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/firewalls';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of firewall rules available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [FirewallList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<FirewallList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/firewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return FirewallList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified firewall rule with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified firewall rule with the data included in the request.
  ///
  /// Note that all fields will be updated if using PUT, even fields that are
  /// not specified. To update individual fields, please use PATCH instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [firewall] - Name of the firewall rule to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Firewall request,
    core.String project,
    core.String firewall, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/firewalls/' +
        commons.escapeVariable('$firewall');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ForwardingRulesResource {
  final commons.ApiRequester _requester;

  ForwardingRulesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of forwarding rules.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified ForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a ForwardingRule resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of ForwardingRule resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules. Currently, you can only patch the network_tier
  /// field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the specified resource.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes target URL for forwarding rule.
  ///
  /// The new target should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String region,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/forwardingRules/' +
        commons.escapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalAddressesResource {
  final commons.ApiRequester _requester;

  GlobalAddressesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified address resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [address] - Name of the address resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String address, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified address resource.
  ///
  /// Gets a list of available addresses by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [address] - Name of the address resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Address].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Address> get(
    core.String project,
    core.String address, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/addresses/' +
        commons.escapeVariable('$address');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Address.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an address resource in the specified project by using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Address request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/addresses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of global addresses.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [AddressList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<AddressList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/addresses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return AddressList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalForwardingRulesResource {
  final commons.ApiRequester _requester;

  GlobalForwardingRulesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified GlobalForwardingRule resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified GlobalForwardingRule resource.
  ///
  /// Gets a list of available forwarding rules by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRule> get(
    core.String project,
    core.String forwardingRule, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a GlobalForwardingRule resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ForwardingRule request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of GlobalForwardingRule resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ForwardingRuleList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ForwardingRuleList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ForwardingRuleList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified forwarding rule with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules. Currently, you can only patch the network_tier
  /// field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    ForwardingRule request,
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the specified resource.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes target URL for the GlobalForwardingRule resource.
  ///
  /// The new target should be of the same type as the old target.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forwardingRule] - Name of the ForwardingRule resource in which target is
  /// to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTarget(
    TargetReference request,
    core.String project,
    core.String forwardingRule, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/forwardingRules/' +
        commons.escapeVariable('$forwardingRule') +
        '/setTarget';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalNetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  GlobalNetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Attach a network endpoint to the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    GlobalNetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network endpoint group.Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detach the network endpoint from the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    GlobalNetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    core.String project,
    core.String networkEndpointGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupsListNetworkEndpoints.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalOperationsResource {
  final commons.ApiRequester _requester;

  GlobalOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of all operations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified Operations resource.
  ///
  /// Gets a list of operations by making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class GlobalOrganizationOperationsResource {
  final commons.ApiRequester _requester;

  GlobalOrganizationOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified Operations resource.
  ///
  /// Request parameters:
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String operation, {
    core.String? parentId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'locations/global/operations/' + commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified Operations resource.
  ///
  /// Gets a list of operations by making a `list()` request.
  ///
  /// Request parameters:
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String operation, {
    core.String? parentId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (parentId != null) 'parentId': [parentId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'locations/global/operations/' + commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// organization.
  ///
  /// Request parameters:
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [parentId] - Parent ID for this request.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list({
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? parentId,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parentId != null) 'parentId': [parentId],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    const _url = 'locations/global/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class HealthChecksResource {
  final commons.ApiRequester _requester;

  HealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all HealthCheck resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthChecksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthChecksAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthChecksAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HealthCheck resource.
  ///
  /// Gets a list of available health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String healthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class HttpHealthChecksResource {
  final commons.ApiRequester _requester;

  HttpHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HttpHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HttpHealthCheck resource.
  ///
  /// Gets a list of available HTTP health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheck> get(
    core.String project,
    core.String httpHealthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpHealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpHealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HttpHealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpHealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpHealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpHealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpHealthCheck] - Name of the HttpHealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpHealthCheck request,
    core.String project,
    core.String httpHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpHealthChecks/' +
        commons.escapeVariable('$httpHealthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class HttpsHealthChecksResource {
  final commons.ApiRequester _requester;

  HttpsHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HttpsHealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HttpsHealthCheck resource.
  ///
  /// Gets a list of available HTTPS health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheck> get(
    core.String project,
    core.String httpsHealthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpsHealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HttpsHealthCheck request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HttpsHealthCheck resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HttpsHealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HttpsHealthCheckList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HttpsHealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HttpsHealthCheck resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [httpsHealthCheck] - Name of the HttpsHealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HttpsHealthCheck request,
    core.String project,
    core.String httpsHealthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/httpsHealthChecks/' +
        commons.escapeVariable('$httpsHealthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ImagesResource {
  final commons.ApiRequester _requester;

  ImagesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified image.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the deprecation status of an image.
  ///
  /// If an empty request body is given, clears the deprecation status instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Image name.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deprecate(
    DeprecationStatus request,
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image') +
        '/deprecate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified image.
  ///
  /// Gets a list of available images by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> get(
    core.String project,
    core.String image, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Image.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the latest image that is part of an image family and is not
  /// deprecated.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [family] - Name of the image family to search for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Image].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Image> getFromFamily(
    core.String project,
    core.String family, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/family/' +
        commons.escapeVariable('$family');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Image.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an image in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [forceCreate] - Force image creation if true.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Image request,
    core.String project, {
    core.bool? forceCreate,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (forceCreate != null) 'forceCreate': ['${forceCreate}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/images';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of custom images available to the specified project.
  ///
  /// Custom images are images you create that belong to your project. This
  /// method does not get any images that belong to other projects, including
  /// publicly-available images, like Debian 8. If you want to get a list of
  /// publicly-available images, use this method to make a request to the
  /// respective image project, such as debian-cloud or windows-cloud.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ImageList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ImageList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/images';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ImageList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified image with the data included in the request.
  ///
  /// Only the following fields can be modified: family, description,
  /// deprecation status.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [image] - Name of the image resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Image request,
    core.String project,
    core.String image, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$image');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on an image.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/images/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceGroupManagersResource {
  final commons.ApiRequester _requester;

  InstanceGroupManagersResource(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be removed from the managed instance
  /// group.
  ///
  /// Abandoning an instance does not delete the instance, but it does remove
  /// the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    InstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of managed instance groups and groups them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagerAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Applies changes to selected instances on the managed instance group.
  ///
  /// This method can be used to apply new overrides and/or new versions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// Should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    InstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates instances with per-instance configs in this managed instance
  /// group.
  ///
  /// Instances are created using the current instance template. The create
  /// instances operation is marked DONE if the createInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    InstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Note that the instance group must not belong to a backend service. Read
  /// Deleting an instance group for more information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group for immediate
  /// deletion.
  ///
  /// The instances are also removed from any target pools of which they were a
  /// member. This method reduces the targetSize of the managed instance group
  /// by the number of instances that you delete. This operation is marked as
  /// DONE when the action is scheduled even if the instances are still being
  /// deleted. You must separately verify the status of the deleting action with
  /// the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    InstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    InstanceGroupManagersDeletePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Gets a list of available managed instance groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManager.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// After the group is created, instances in the group are created using the
  /// specified instance template. This operation is marked as DONE when the
  /// group is created even if the instances in the group have not yet been
  /// created. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method.
  ///
  /// A managed instance group can have up to 1000 VM instances per group.
  /// Please contact Cloud Support if you need an increase in this limit.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of managed instance groups that are contained within the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagerList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all errors thrown by actions on instances for a given managed
  /// instance group.
  ///
  /// The filter and orderBy query parameters are not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?)|\[1-9\]\[0-9\]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListErrorsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the instances in the managed instance group.
  ///
  /// Each instance in the list has a currentAction, which indicates the action
  /// that the managed instance group is performing on the instance. For
  /// example, if the group is still creating an instance, the currentAction is
  /// CREATING. If a previous action failed, the list displays the errors for
  /// that failed action. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListManagedInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListManagedInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListManagedInstancesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManagersListPerInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManagersListPerInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return InstanceGroupManagersListPerInstanceConfigsResp.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// This operation is marked as DONE when the group is patched even if the
  /// instances in the group are still in the process of being patched. You must
  /// separately verify the status of the individual instances with the
  /// listManagedInstances method. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the managed
  /// instance group.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or patches per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    InstanceGroupManagersPatchPerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated.
  ///
  /// The instances are deleted and recreated using the current instance
  /// template for the managed instance group. This operation is marked as DONE
  /// when the flag is set even if the instances have not yet been recreated.
  /// You must separately verify the status of the recreating action with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    InstanceGroupManagersRecreateInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the managed instance group.
  ///
  /// If you increase the size, the group creates new instances using the
  /// current instance template. If you decrease the size, the group deletes
  /// instances. The resize operation is marked DONE when the resize actions are
  /// scheduled even if the group has not yet added or deleted any instances.
  /// You must separately verify the status of the creating or deleting actions
  /// with the listmanagedinstances method.
  ///
  /// When resizing down, the instance group arbitrarily chooses the order in
  /// which VMs are deleted. The group takes into account some VM attributes
  /// when making the selection including:
  ///
  /// + The status of the VM instance. + The health of the VM instance. + The
  /// instance template version the VM is based on. + For regional managed
  /// instance groups, the location of the VM instance.
  ///
  /// This list is subject to change.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [size] - The number of running instances that the managed instance group
  /// should maintain at any given time. The group automatically adds or removes
  /// instances to maintain the number of instances specified by this parameter.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String zone,
    core.String instanceGroupManager,
    core.int size, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'size': ['${size}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Specifies the instance template to use when creating new instances in this
  /// group.
  ///
  /// The templates for existing instances in the group do not change unless you
  /// run recreateInstances, run applyUpdatesToInstances, or set the group's
  /// updatePolicy.type to PROACTIVE.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    InstanceGroupManagersSetInstanceTemplateRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Modifies the target pools to which all instances in this managed instance
  /// group are assigned.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group. This operation is marked DONE when you make the
  /// request even if the instances have not yet been added to their target
  /// pools. The change might take some time to apply to all of the instances in
  /// the group depending on the size of the group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    InstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or updates per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the managed instance group is located.
  /// It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    InstanceGroupManagersUpdatePerInstanceConfigsReq request,
    core.String project,
    core.String zone,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceGroupsResource {
  final commons.ApiRequester _requester;

  InstanceGroupsResource(commons.ApiRequester client) : _requester = client;

  /// Adds a list of instances to the specified instance group.
  ///
  /// All of the instances in the instance group must be in the same
  /// network/subnetwork. Read Adding instances for more information.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where you are adding
  /// instances.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstances(
    InstanceGroupsAddInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/addInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instance groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified instance group.
  ///
  /// The instances in the group are not deleted. Note that instance group must
  /// not belong to a backend service. Read Deleting an instance group for more
  /// information.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified zonal instance group.
  ///
  /// Get a list of available zonal instance groups by making a list() request.
  ///
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance group in the specified project using the parameters
  /// that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroup request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of zonal instance group resources contained within the
  /// specified zone.
  ///
  /// For managed instance groups, use the instanceGroupManagers or
  /// regionInstanceGroupManagers methods instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the specified instance group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group from which you want to
  /// generate a list of included instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupsListInstances> listInstances(
    InstanceGroupsListInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return InstanceGroupsListInstances.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes one or more instances from the specified instance group, but does
  /// not delete those instances.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration before the VM instance is removed or deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the specified
  /// instances will be removed.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstances(
    InstanceGroupsRemoveInstancesRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/removeInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the named ports for the specified instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the instance group is located.
  ///
  /// [instanceGroup] - The name of the instance group where the named ports are
  /// updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    InstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String zone,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InstanceTemplatesResource {
  final commons.ApiRequester _requester;

  InstanceTemplatesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified instance template.
  ///
  /// Deleting an instance template is permanent and cannot be undone. It is not
  /// possible to delete templates that are already in use by a managed instance
  /// group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [instanceTemplate] - The name of the instance template to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String instanceTemplate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$instanceTemplate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified instance template.
  ///
  /// Gets a list of available instance templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [instanceTemplate] - The name of the instance template.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplate> get(
    core.String project,
    core.String instanceTemplate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$instanceTemplate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceTemplate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance template in the specified project using the data that
  /// is included in the request.
  ///
  /// If you are creating a new template to update an existing instance group,
  /// your new instance template must use the same network or, if applicable,
  /// the same subnetwork as the original template.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceTemplate request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of instance templates that are contained within the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceTemplateList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceTemplateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/instanceTemplates/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InstancesResource {
  final commons.ApiRequester _requester;

  InstancesResource(commons.ApiRequester client) : _requester = client;

  /// Adds an access config to an instance's network interface.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface to add to this
  /// instance.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/addAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Adds existing resource policies to an instance.
  ///
  /// You can only add one policy right now which will be applied to this
  /// instance for scheduling live migrations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    InstancesAddResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves aggregated list of all of the instances in your project across
  /// all regions and zones.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/instances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Attaches an existing Disk resource to an instance.
  ///
  /// You must first create the disk before you can attach it. It is not
  /// possible to create and attach a disk at the same time. For more
  /// information, read Adding a persistent disk to your instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [forceAttach] - Whether to force attach the regional disk even if it's
  /// currently attached to another instance. If you try to force attach a zonal
  /// disk to an instance, you will receive an error.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachDisk(
    AttachedDisk request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.bool? forceAttach,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (forceAttach != null) 'forceAttach': ['${forceAttach}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/attachDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates multiple instances.
  ///
  /// Count specifies the number of instances to create.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> bulkInsert(
    BulkInsertInstanceResource request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/bulkInsert';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Instance resource.
  ///
  /// For more information, see Stopping or Deleting an Instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an access config from an instance's network interface.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [accessConfig] - The name of the access config to delete.
  ///
  /// [networkInterface] - The name of the network interface.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteAccessConfig(
    core.String project,
    core.String zone,
    core.String instance,
    core.String accessConfig,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'accessConfig': [accessConfig],
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/deleteAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detaches a disk from an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [deviceName] - The device name of the disk to detach. Make a get() request
  /// on the instance to view currently attached disks and device names.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachDisk(
    core.String project,
    core.String zone,
    core.String instance,
    core.String deviceName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'deviceName': [deviceName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/detachDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Instance resource.
  ///
  /// Gets a list of available instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Instance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Instance> get(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Instance.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns effective firewalls applied to an interface of the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [networkInterface] - The name of the network interface to get the
  /// effective firewalls.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstancesGetEffectiveFirewallsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstancesGetEffectiveFirewallsResponse> getEffectiveFirewalls(
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getEffectiveFirewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstancesGetEffectiveFirewallsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified guest attributes entry.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [queryPath] - Specifies the guest attributes path to be queried.
  ///
  /// [variableKey] - Specifies the key for the guest attributes entry.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GuestAttributes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GuestAttributes> getGuestAttributes(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? queryPath,
    core.String? variableKey,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (queryPath != null) 'queryPath': [queryPath],
      if (variableKey != null) 'variableKey': [variableKey],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getGuestAttributes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return GuestAttributes.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the screenshot from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Screenshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Screenshot> getScreenshot(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/screenshot';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Screenshot.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the last 1 MB of serial port output from the specified instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [port] - Specifies which COM or serial port to retrieve data from.
  /// Value must be between "1" and "4".
  ///
  /// [start_1] - Specifies the starting byte position of the output to return.
  /// To start with the first byte of output to the specified port, omit this
  /// field or set it to `0`.
  ///
  /// If the output for that byte position is available, this field matches the
  /// `start` parameter sent with the request. If the amount of serial console
  /// output exceeds the size of the buffer (1 MB), the oldest output is
  /// discarded and is no longer available. If the requested start position
  /// refers to discarded output, the start position is adjusted to the oldest
  /// output still available, and the adjusted start position is returned as the
  /// `start` property value.
  ///
  /// You can also provide a negative start position, which translates to the
  /// most recent number of bytes written to the serial port. For example, -3 is
  /// interpreted as the most recent 3 bytes written to the serial console.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SerialPortOutput].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SerialPortOutput> getSerialPortOutput(
    core.String project,
    core.String zone,
    core.String instance, {
    core.int? port,
    core.String? start_1,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (port != null) 'port': ['${port}'],
      if (start_1 != null) 'start': [start_1],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/serialPort';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SerialPortOutput.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the Shielded Instance Identity of an instance
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ShieldedInstanceIdentity].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ShieldedInstanceIdentity> getShieldedInstanceIdentity(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/getShieldedInstanceIdentity';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ShieldedInstanceIdentity.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an instance resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceInstanceTemplate] - Specifies instance template to create the
  /// instance.
  ///
  /// This field is optional. It can be a full or partial URL. For example, the
  /// following are all valid URLs to an instance template:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
  /// - projects/project/global/instanceTemplates/instanceTemplate
  /// - global/instanceTemplates/instanceTemplate
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Instance request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? sourceInstanceTemplate,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceInstanceTemplate != null)
        'sourceInstanceTemplate': [sourceInstanceTemplate],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instances contained within the specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of resources that refer to the VM instance specified in
  /// the request.
  ///
  /// For example, if the VM instance is part of a managed or unmanaged instance
  /// group, the referrers list includes the instance group. For more
  /// information, read Viewing referrers to VM instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the target instance scoping this request, or '-' if
  /// the request should span over all instances in the container.
  /// Value must have pattern
  /// `-|\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceListReferrers].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceListReferrers> listReferrers(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/referrers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceListReferrers.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    InstancesRemoveResourcePoliciesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Performs a reset on the instance.
  ///
  /// This is a hard reset the VM does not do a graceful shutdown. For more
  /// information, see Resetting an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> reset(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/reset';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets deletion protection on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [deletionProtection] - Whether the resource should be protected against
  /// deletion.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDeletionProtection(
    core.String project,
    core.String zone,
    core.String resource, {
    core.bool? deletionProtection,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (deletionProtection != null)
        'deletionProtection': ['${deletionProtection}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/setDeletionProtection';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the auto-delete flag for a disk attached to an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [autoDelete] - Whether to auto-delete the disk when the instance is
  /// deleted.
  ///
  /// [deviceName] - The device name of the disk to modify. Make a get() request
  /// on the instance to view currently attached disks and device names.
  /// Value must have pattern `\w\[\w.-\]{0,254}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDiskAutoDelete(
    core.String project,
    core.String zone,
    core.String instance,
    core.bool autoDelete,
    core.String deviceName, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'autoDelete': ['${autoDelete}'],
      'deviceName': [deviceName],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setDiskAutoDelete';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets labels on an instance.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    InstancesSetLabelsRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the number and/or type of accelerator for a stopped instance to
  /// the values specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineResources(
    InstancesSetMachineResourcesRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMachineResources';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the machine type for a stopped instance to the machine type
  /// specified in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMachineType(
    InstancesSetMachineTypeRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMachineType';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets metadata for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMetadata(
    Metadata request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMetadata';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the minimum CPU platform that this instance should use.
  ///
  /// This method can only be called on a stopped instance. For more
  /// information, read Specifying a Minimum CPU Platform.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setMinCpuPlatform(
    InstancesSetMinCpuPlatformRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setMinCpuPlatform';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets an instance's scheduling options.
  ///
  /// You can only call this method on a stopped instance, that is, a VM
  /// instance that is in a `TERMINATED` state. See Instance Life Cycle for more
  /// information on the possible instance states.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setScheduling(
    Scheduling request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setScheduling';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the service account on the instance.
  ///
  /// For more information, read Changing the service account and access scopes
  /// for an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setServiceAccount(
    InstancesSetServiceAccountRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setServiceAccount';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the Shielded Instance integrity policy for an instance.
  ///
  /// You can only use this method on a running instance. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setShieldedInstanceIntegrityPolicy(
    ShieldedInstanceIntegrityPolicy request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setShieldedInstanceIntegrityPolicy';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets network tags for the specified instance to the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTags(
    Tags request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/setTags';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Simulates a maintenance event on the instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> simulateMaintenanceEvent(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/simulateMaintenanceEvent';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Starts an instance that was stopped using the instances().stop method.
  ///
  /// For more information, see Restart an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> start(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/start';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Starts an instance that was stopped using the instances().stop method.
  ///
  /// For more information, see Restart an instance.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to start.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> startWithEncryptionKey(
    InstancesStartWithEncryptionKeyRequest request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/startWithEncryptionKey';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Stops a running instance, shutting it down cleanly, and allows you to
  /// restart the instance at a later time.
  ///
  /// Stopped instances do not incur VM usage charges while they are stopped.
  /// However, resources that the VM is using, such as persistent disks and
  /// static IP addresses, will continue to be charged until they are deleted.
  /// For more information, see Stopping an instance.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to stop.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> stop(
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/stop';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an instance only if the necessary resources are available.
  ///
  /// This method can update only a specific set of instance properties. See
  /// Updating a running instance for a list of updatable instance properties.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [minimalAction] - Specifies the action to take when updating an instance
  /// even if the updated properties do not require it. If not specified, then
  /// Compute Engine acts based on the minimum action that the updated
  /// properties require.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [mostDisruptiveAllowedAction] - Specifies the most disruptive action that
  /// can be taken on the instance as part of the update. Compute Engine returns
  /// an error if the instance properties require a more disruptive action as
  /// part of the instance update. Valid options from lowest to highest are
  /// NO_EFFECT, REFRESH, and RESTART.
  /// Possible string values are:
  /// - "INVALID"
  /// - "NO_EFFECT"
  /// - "REFRESH"
  /// - "RESTART"
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Instance request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? minimalAction,
    core.String? mostDisruptiveAllowedAction,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (minimalAction != null) 'minimalAction': [minimalAction],
      if (mostDisruptiveAllowedAction != null)
        'mostDisruptiveAllowedAction': [mostDisruptiveAllowedAction],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified access config from an instance's network interface
  /// with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface where the access
  /// config is attached.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateAccessConfig(
    AccessConfig request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateAccessConfig';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the Display config for a VM instance.
  ///
  /// You can only use this method on a stopped VM instance. This method
  /// supports PATCH semantics and uses the JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name of the instance scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateDisplayDevice(
    DisplayDevice request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateDisplayDevice';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an instance's network interface.
  ///
  /// This method can only update an interface's alias IP range and attached
  /// network. See Modifying alias IP ranges for an existing instance for
  /// instructions on changing alias IP ranges. See Migrating a VM between
  /// networks for instructions on migrating an interface. This method follows
  /// PATCH semantics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - The instance name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [networkInterface] - The name of the network interface to update.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateNetworkInterface(
    NetworkInterface request,
    core.String project,
    core.String zone,
    core.String instance,
    core.String networkInterface, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'networkInterface': [networkInterface],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateNetworkInterface';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the Shielded Instance config for an instance.
  ///
  /// You can only use this method on a stopped instance. This method supports
  /// PATCH semantics and uses the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [instance] - Name or id of the instance scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updateShieldedInstanceConfig(
    ShieldedInstanceConfig request,
    core.String project,
    core.String zone,
    core.String instance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/instances/' +
        commons.escapeVariable('$instance') +
        '/updateShieldedInstanceConfig';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectAttachmentsResource {
  final commons.ApiRequester _requester;

  InterconnectAttachmentsResource(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves an aggregated list of interconnect attachments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachmentAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified interconnect attachment.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachment> get(
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachment.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an InterconnectAttachment in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [validateOnly] - If true, the request will not be committed.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InterconnectAttachment request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.bool? validateOnly,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (validateOnly != null) 'validateOnly': ['${validateOnly}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect attachments contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectAttachmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectAttachmentList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectAttachmentList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified interconnect attachment with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [interconnectAttachment] - Name of the interconnect attachment to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InterconnectAttachment request,
    core.String project,
    core.String region,
    core.String interconnectAttachment, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/interconnectAttachments/' +
        commons.escapeVariable('$interconnectAttachment');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectLocationsResource {
  final commons.ApiRequester _requester;

  InterconnectLocationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Returns the details for the specified interconnect location.
  ///
  /// Gets a list of available interconnect locations by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnectLocation] - Name of the interconnect location to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocation> get(
    core.String project,
    core.String interconnectLocation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnectLocations/' +
        commons.escapeVariable('$interconnectLocation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectLocation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect locations available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectLocationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectLocationList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnectLocations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectLocationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class InterconnectsResource {
  final commons.ApiRequester _requester;

  InterconnectsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String interconnect, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified interconnect.
  ///
  /// Get a list of available interconnects by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Interconnect].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Interconnect> get(
    core.String project,
    core.String interconnect, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Interconnect.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the interconnectDiagnostics for the specified interconnect.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectsGetDiagnosticsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectsGetDiagnosticsResponse> getDiagnostics(
    core.String project,
    core.String interconnect, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect') +
        '/getDiagnostics';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectsGetDiagnosticsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Interconnect in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Interconnect request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of interconnect available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InterconnectList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InterconnectList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InterconnectList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified interconnect with the data included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [interconnect] - Name of the interconnect to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Interconnect request,
    core.String project,
    core.String interconnect, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/interconnects/' +
        commons.escapeVariable('$interconnect');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class LicenseCodesResource {
  final commons.ApiRequester _requester;

  LicenseCodesResource(commons.ApiRequester client) : _requester = client;

  /// Return a specified license code.
  ///
  /// License codes are mirrored across all projects that have permissions to
  /// read the License Code. Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [licenseCode] - Number corresponding to the License code resource to
  /// return.
  /// Value must have pattern `\[0-9\]{0,61}?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicenseCode].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicenseCode> get(
    core.String project,
    core.String licenseCode, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.escapeVariable('$licenseCode');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return LicenseCode.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// Caution This resource is intended for use only by third-party partners who
  /// are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenseCodes/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class LicensesResource {
  final commons.ApiRequester _requester;

  LicensesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified license.
  ///
  /// Caution This resource is intended for use only by third-party partners who
  /// are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [license] - Name of the license resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String license, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$license');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified License resource.
  ///
  /// Caution This resource is intended for use only by third-party partners who
  /// are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [license] - Name of the License resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [License].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<License> get(
    core.String project,
    core.String license, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$license');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return License.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists. Caution This resource
  /// is intended for use only by third-party partners who are creating Cloud
  /// Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Create a License resource in the specified project.
  ///
  /// Caution This resource is intended for use only by third-party partners who
  /// are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    License request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/licenses';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of licenses available in the specified project.
  ///
  /// This method does not get any licenses that belong to other projects,
  /// including licenses attached to publicly-available images, like Debian 9.
  /// If you want to get a list of publicly-available licenses, use this method
  /// to make a request to the respective image project, such as debian-cloud or
  /// windows-cloud. Caution This resource is intended for use only by
  /// third-party partners who are creating Cloud Marketplace images.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [LicensesListResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<LicensesListResponse> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/licenses';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return LicensesListResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Caution This resource is intended for use
  /// only by third-party partners who are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// Caution This resource is intended for use only by third-party partners who
  /// are creating Cloud Marketplace images.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/licenses/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class MachineTypesResource {
  final commons.ApiRequester _requester;

  MachineTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of machine types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/machineTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified machine type.
  ///
  /// Gets a list of available machine types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [machineType] - Name of the machine type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineType> get(
    core.String project,
    core.String zone,
    core.String machineType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/machineTypes/' +
        commons.escapeVariable('$machineType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineType.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of machine types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [MachineTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<MachineTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/machineTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return MachineTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  NetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Retrieves the list of network endpoint groups and sorts them by zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Attach a list of network endpoints to the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are attaching network endpoints to. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> attachNetworkEndpoints(
    NetworkEndpointGroupsAttachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/attachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network endpoint group.
  ///
  /// The network endpoints in the NEG and the VM instances they belong to are
  /// not terminated when the NEG is deleted. Note that the NEG cannot be
  /// deleted if there are backend services referencing it.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Detach a list of network endpoints from the specified network endpoint
  /// group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group where you
  /// are removing network endpoints. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> detachNetworkEndpoints(
    NetworkEndpointGroupsDetachEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/detachNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of network endpoint groups that are located in the
  /// specified project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the network endpoints in the specified network endpoint group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone where the network endpoint group is located.
  /// It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group from which
  /// you want to generate a list of included network endpoints. It should
  /// comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupsListNetworkEndpoints].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupsListNetworkEndpoints> listNetworkEndpoints(
    NetworkEndpointGroupsListEndpointsRequest request,
    core.String project,
    core.String zone,
    core.String networkEndpointGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup') +
        '/listNetworkEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupsListNetworkEndpoints.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NetworksResource {
  final commons.ApiRequester _requester;

  NetworksResource(commons.ApiRequester client) : _requester = client;

  /// Adds a peering to the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource to add peering to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addPeering(
    NetworksAddPeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/addPeering';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network.
  ///
  /// Gets a list of available networks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Network].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Network> get(
    core.String project,
    core.String network, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Network.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the effective firewalls on a given network.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworksGetEffectiveFirewallsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworksGetEffectiveFirewallsResponse> getEffectiveFirewalls(
    core.String project,
    core.String network, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/getEffectiveFirewalls';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworksGetEffectiveFirewallsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network in the specified project using the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Network request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/networks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of networks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/networks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the peering routes exchanged over peering connection.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [direction] - The direction of the exchanged routes.
  /// Possible string values are:
  /// - "INCOMING"
  /// - "OUTGOING"
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [peeringName] - The response will show routes exchanged over the given
  /// peering connection.
  ///
  /// [region] - The region of the request. The response will include all subnet
  /// routes, static routes and dynamic routes in the region.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ExchangedPeeringRoutesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ExchangedPeeringRoutesList> listPeeringRoutes(
    core.String project,
    core.String network, {
    core.String? direction,
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.String? peeringName,
    core.String? region,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (direction != null) 'direction': [direction],
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (peeringName != null) 'peeringName': [peeringName],
      if (region != null) 'region': [region],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/listPeeringRoutes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ExchangedPeeringRoutesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified network with the data included in the request.
  ///
  /// Only the following fields can be modified: routingConfig.routingMode.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Network request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes a peering from the specified network.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource to remove peering from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removePeering(
    NetworksRemovePeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/removePeering';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Switches the network mode from auto subnet mode to custom subnet mode.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network to be updated.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> switchToCustomMode(
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/switchToCustomMode';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified network peering with the data included in the
  /// request Only the following fields can be modified:
  /// NetworkPeering.export_custom_routes, and
  /// NetworkPeering.import_custom_routes
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [network] - Name of the network resource which the updated peering is
  /// belonging to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePeering(
    NetworksUpdatePeeringRequest request,
    core.String project,
    core.String network, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/networks/' +
        commons.escapeVariable('$network') +
        '/updatePeering';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class NodeGroupsResource {
  final commons.ApiRequester _requester;

  NodeGroupsResource(commons.ApiRequester client) : _requester = client;

  /// Adds specified number of nodes to the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addNodes(
    NodeGroupsAddNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/addNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of node groups.
  ///
  /// Note: use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroupAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified NodeGroup resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes specified nodes from the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes will be deleted.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteNodes(
    NodeGroupsDeleteNodesRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/deleteNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified NodeGroup.
  ///
  /// Get a list of available NodeGroups by making a list() request. Note: the
  /// "nodes" field should not be used. Use nodeGroups.listNodes instead.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the node group to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroup> get(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroup.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NodeGroup resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [initialNodeCount] - Initial count of nodes in the node group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.int initialNodeCount, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      'initialNodeCount': ['${initialNodeCount}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node groups available to the specified project.
  ///
  /// Note: use nodeGroups.listNodes for more details about each group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists nodes in the node group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource whose nodes you want to list.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeGroupsListNodes].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeGroupsListNodes> listNodes(
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/listNodes';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return NodeGroupsListNodes.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    NodeGroup request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the node template of the node group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeGroup] - Name of the NodeGroup resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNodeTemplate(
    NodeGroupsSetNodeTemplateRequest request,
    core.String project,
    core.String zone,
    core.String nodeGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$nodeGroup') +
        '/setNodeTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeGroups/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NodeTemplatesResource {
  final commons.ApiRequester _requester;

  NodeTemplatesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node templates.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplateAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified NodeTemplate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeTemplate] - Name of the NodeTemplate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$nodeTemplate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified node template.
  ///
  /// Gets a list of available node templates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeTemplate] - Name of the node template to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplate> get(
    core.String project,
    core.String region,
    core.String nodeTemplate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$nodeTemplate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NodeTemplate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NodeTemplate request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node templates available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTemplateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTemplateList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTemplateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/nodeTemplates/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class NodeTypesResource {
  final commons.ApiRequester _requester;

  NodeTypesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of node types.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/nodeTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTypeAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified node type.
  ///
  /// Gets a list of available node types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [nodeType] - Name of the node type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeType> get(
    core.String project,
    core.String zone,
    core.String nodeType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeTypes/' +
        commons.escapeVariable('$nodeType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of node types available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NodeTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NodeTypeList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/nodeTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NodeTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class PacketMirroringsResource {
  final commons.ApiRequester _requester;

  PacketMirroringsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of packetMirrorings.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroringAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified PacketMirroring resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroring].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroring> get(
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroring.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PacketMirroring resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    PacketMirroring request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of PacketMirroring resources available to the specified
  /// project and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [PacketMirroringList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<PacketMirroringList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return PacketMirroringList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified PacketMirroring resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [packetMirroring] - Name of the PacketMirroring resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    PacketMirroring request,
    core.String project,
    core.String region,
    core.String packetMirroring, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$packetMirroring');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/packetMirrorings/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsResource(commons.ApiRequester client) : _requester = client;

  /// Disable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnHost(
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/disableXpnHost';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Disable a service resource (also known as service project) associated with
  /// this host project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> disableXpnResource(
    ProjectsDisableXpnResourceRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/disableXpnResource';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enable this project as a shared VPC host project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnHost(
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/enableXpnHost';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enable service resource (a.k.a service project) for a host project, so
  /// that subnets in the host project can be used by instances in the service
  /// project.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> enableXpnResource(
    ProjectsEnableXpnResourceRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/enableXpnResource';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Project resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> get(
    core.String project, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Project.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the shared VPC host project that this project links to.
  ///
  /// May be empty if no link exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Project].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Project> getXpnHost(
    core.String project, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/getXpnHost';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Project.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets service resources (a.k.a service project) associated with this host
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ProjectsGetXpnResources].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ProjectsGetXpnResources> getXpnResources(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/getXpnResources';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ProjectsGetXpnResources.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all shared VPC host projects visible to the user in an organization.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [XpnHostList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<XpnHostList> listXpnHosts(
    ProjectsListXpnHostsRequest request,
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/listXpnHosts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return XpnHostList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Moves a persistent disk from one zone to another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveDisk(
    DiskMoveRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/moveDisk';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Moves an instance and its attached persistent disks from one zone to
  /// another.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> moveInstance(
    InstanceMoveRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/moveInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets metadata common to all instances within the specified project using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setCommonInstanceMetadata(
    Metadata request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setCommonInstanceMetadata';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the default network tier of the project.
  ///
  /// The default network tier is used when an address/forwardingRule/instance
  /// is created without specifying the network tier field.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setDefaultNetworkTier(
    ProjectsSetDefaultNetworkTierRequest request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setDefaultNetworkTier';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Enables the usage export feature and sets the usage export bucket where
  /// reports are stored.
  ///
  /// If you provide an empty request body using this method, the usage export
  /// feature will be disabled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUsageExportBucket(
    UsageExportLocation request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/setUsageExportBucket';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionAutoscalersResource {
  final commons.ApiRequester _requester;

  RegionAutoscalersResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified autoscaler.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Autoscaler].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Autoscaler> get(
    core.String project,
    core.String region,
    core.String autoscaler, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers/' +
        commons.escapeVariable('$autoscaler');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Autoscaler.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of autoscalers contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionAutoscalerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionAutoscalerList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionAutoscalerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates an autoscaler in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [autoscaler] - Name of the autoscaler to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Autoscaler request,
    core.String project,
    core.String region, {
    core.String? autoscaler,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (autoscaler != null) 'autoscaler': [autoscaler],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/autoscalers';

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionBackendServicesResource {
  final commons.ApiRequester _requester;

  RegionBackendServicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified regional BackendService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendService> get(
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for this regional
  /// BackendService.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - null
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource for which to get
  /// health.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceGroupHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceGroupHealth> getHealth(
    ResourceGroupReference request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return BackendServiceGroupHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a regional BackendService resource in the specified project using
  /// the data included in the request.
  ///
  /// For more information, see  Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    BackendService request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of regional BackendService resources available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [BackendServiceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<BackendServiceList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return BackendServiceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request.
  ///
  /// For more information, see Understanding backend services This method
  /// supports PATCH semantics and uses the JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional BackendService resource with the data
  /// included in the request.
  ///
  /// For more information, see  Backend services overview.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [backendService] - Name of the BackendService resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    BackendService request,
    core.String project,
    core.String region,
    core.String backendService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/backendServices/' +
        commons.escapeVariable('$backendService');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionCommitmentsResource {
  final commons.ApiRequester _requester;

  RegionCommitmentsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of commitments.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/commitments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return CommitmentAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified commitment resource.
  ///
  /// Gets a list of available commitments by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [commitment] - Name of the commitment to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Commitment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Commitment> get(
    core.String project,
    core.String region,
    core.String commitment, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments/' +
        commons.escapeVariable('$commitment');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Commitment.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a commitment in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Commitment request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of commitments contained within the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [CommitmentList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<CommitmentList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/commitments';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return CommitmentList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionDiskTypesResource {
  final commons.ApiRequester _requester;

  RegionDiskTypesResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified regional disk type.
  ///
  /// Gets a list of available disk types by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [diskType] - Name of the disk type to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskType> get(
    core.String project,
    core.String region,
    core.String diskType, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/diskTypes/' +
        commons.escapeVariable('$diskType');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskType.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of regional disk types available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionDiskTypeList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionDiskTypeList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/diskTypes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionDiskTypeList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionDisksResource {
  final commons.ApiRequester _requester;

  RegionDisksResource(commons.ApiRequester client) : _requester = client;

  /// Adds existing resource policies to a regional disk.
  ///
  /// You can only add one policy which will be applied to this disk for
  /// scheduling snapshot creation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addResourcePolicies(
    RegionDisksAddResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/addResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a snapshot of this regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to snapshot.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createSnapshot(
    Snapshot request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/createSnapshot';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified regional persistent disk.
  ///
  /// Deleting a regional disk removes all the replicas of its data permanently
  /// and is irreversible. However, deleting a disk does not delete any
  /// snapshots previously made from the disk. You must separately delete
  /// snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns a specified regional persistent disk.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Disk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Disk> get(
    core.String project,
    core.String region,
    core.String disk, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Disk.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a persistent regional disk in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [sourceImage] - Source image to restore onto a disk. This field is
  /// optional.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Disk request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? sourceImage,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if (sourceImage != null) 'sourceImage': [sourceImage],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of persistent disks contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [DiskList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<DiskList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return DiskList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes resource policies from a regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - The disk name for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeResourcePolicies(
    RegionDisksRemoveResourcePoliciesRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/removeResourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the specified regional persistent disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - The project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [disk] - Name of the regional persistent disk.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    RegionDisksResizeRequest request,
    core.String project,
    core.String region,
    core.String disk, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$disk') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on the target regional disk.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/disks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionHealthCheckServicesResource {
  final commons.ApiRequester _requester;

  RegionHealthCheckServicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified regional HealthCheckService.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to delete. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified regional HealthCheckService resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckService].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckService> get(
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckService.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a regional HealthCheckService resource in the specified project
  /// and region using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheckService request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the HealthCheckService resources that have been configured for
  /// the specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckServicesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckServicesList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckServicesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified regional HealthCheckService resource with the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheckService] - Name of the HealthCheckService to update. The name
  /// must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheckService request,
    core.String project,
    core.String region,
    core.String healthCheckService, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthCheckServices/' +
        commons.escapeVariable('$healthCheckService');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionHealthChecksResource {
  final commons.ApiRequester _requester;

  RegionHealthChecksResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified HealthCheck resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified HealthCheck resource.
  ///
  /// Gets a list of available health checks by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheck].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheck> get(
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheck.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    HealthCheck request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of HealthCheck resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [HealthCheckList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<HealthCheckList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return HealthCheckList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a HealthCheck resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [healthCheck] - Name of the HealthCheck resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    HealthCheck request,
    core.String project,
    core.String region,
    core.String healthCheck, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/healthChecks/' +
        commons.escapeVariable('$healthCheck');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstanceGroupManagersResource {
  final commons.ApiRequester _requester;

  RegionInstanceGroupManagersResource(commons.ApiRequester client)
      : _requester = client;

  /// Flags the specified instances to be immediately removed from the managed
  /// instance group.
  ///
  /// Abandoning an instance does not delete the instance, but it does remove
  /// the instance from any target pools that are applied by the managed
  /// instance group. This method reduces the targetSize of the managed instance
  /// group by the number of instances that you abandon. This operation is
  /// marked as DONE when the action is scheduled even if the instances have not
  /// yet been removed from the group. You must separately verify the status of
  /// the abandoning action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> abandonInstances(
    RegionInstanceGroupManagersAbandonInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/abandonInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Apply updates to selected instances the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group, should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> applyUpdatesToInstances(
    RegionInstanceGroupManagersApplyUpdatesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/applyUpdatesToInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates instances with per-instance configs in this regional managed
  /// instance group.
  ///
  /// Instances are created using the current instance template. The create
  /// instances operation is marked DONE if the createInstances request is
  /// successful. The underlying actions take additional time. You must
  /// separately verify the status of the creating or actions with the
  /// listmanagedinstances method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the managed instance group is
  /// located. It should conform to RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> createInstances(
    RegionInstanceGroupManagersCreateInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/createInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified managed instance group and all of the instances in
  /// that group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to delete.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately deleted.
  ///
  /// The instances are also removed from any target pools of which they were a
  /// member. This method reduces the targetSize of the managed instance group
  /// by the number of instances that you delete. The deleteInstances operation
  /// is marked DONE if the deleteInstances request is successful. The
  /// underlying actions take additional time. You must separately verify the
  /// status of the deleting action with the listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deleteInstances(
    RegionInstanceGroupManagersDeleteInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deleteInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes selected per-instance configs for the managed instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> deletePerInstanceConfigs(
    RegionInstanceGroupManagerDeleteInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/deletePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns all of the details about the specified managed instance group.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroupManager].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroupManager> get(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroupManager.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// After the group is created, instances in the group are created using the
  /// specified instance template. This operation is marked as DONE when the
  /// group is created even if the instances in the group have not yet been
  /// created. You must separately verify the status of the individual instances
  /// with the listmanagedinstances method.
  ///
  /// A regional managed instance group can contain up to 2000 instances.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    InstanceGroupManager request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of managed instance groups that are contained within
  /// the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagerList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagerList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagerList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all errors thrown by actions on instances for a given regional
  /// managed instance group.
  ///
  /// The filter and orderBy query parameters are not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request. This should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It must
  /// be a string that meets the requirements in RFC1035, or an unsigned long
  /// integer: must match regexp pattern:
  /// (?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?)|\[1-9\]\[0-9\]{0,19}.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListErrorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListErrorsResponse> listErrors(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listErrors';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListErrorsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the managed instance group and instances that are
  /// scheduled to be created.
  ///
  /// The list includes any current actions that the group has scheduled for its
  /// instances. The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstancesResponse>
      listManagedInstances(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listManagedInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListInstancesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the per-instance configs defined for the managed instance
  /// group.
  ///
  /// The orderBy query parameter is not supported.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupManagersListInstanceConfigsResp].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupManagersListInstanceConfigsResp>
      listPerInstanceConfigs(
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/listPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates a managed instance group using the information that you specify in
  /// the request.
  ///
  /// This operation is marked as DONE when the group is patched even if the
  /// instances in the group are still in the process of being patched. You must
  /// separately verify the status of the individual instances with the
  /// listmanagedinstances method. This method supports PATCH semantics and uses
  /// the JSON merge patch format and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the instance group manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    InstanceGroupManager request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or patches per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchPerInstanceConfigs(
    RegionInstanceGroupManagerPatchInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/patchPerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Flags the specified instances in the managed instance group to be
  /// immediately recreated.
  ///
  /// The instances are deleted and recreated using the current instance
  /// template for the managed instance group. This operation is marked as DONE
  /// when the flag is set even if the instances have not yet been recreated.
  /// You must separately verify the status of the recreating action with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// You can specify a maximum of 1000 instances with this method per request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> recreateInstances(
    RegionInstanceGroupManagersRecreateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/recreateInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the intended size of the managed instance group.
  ///
  /// If you increase the size, the group creates new instances using the
  /// current instance template. If you decrease the size, the group deletes one
  /// or more instances.
  ///
  /// The resize operation is marked DONE if the resize request is successful.
  /// The underlying actions take additional time. You must separately verify
  /// the status of the creating or deleting actions with the
  /// listmanagedinstances method.
  ///
  /// If the group is part of a backend service that has enabled connection
  /// draining, it can take up to 60 seconds after the connection draining
  /// duration has elapsed before the VM instance is removed or deleted.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [size] - Number of instances that should exist in this instance group
  /// manager.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    core.String project,
    core.String region,
    core.String instanceGroupManager,
    core.int size, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      'size': ['${size}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the instance template to use when creating new instances or
  /// recreating instances in this group.
  ///
  /// Existing instances are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - The name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setInstanceTemplate(
    RegionInstanceGroupManagersSetTemplateRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setInstanceTemplate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Modifies the target pools to which all new instances in this group are
  /// assigned.
  ///
  /// Existing instances in the group are not affected.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroupManager] - Name of the managed instance group.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setTargetPools(
    RegionInstanceGroupManagersSetTargetPoolsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/setTargetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Inserts or updates per-instance configs for the managed instance group.
  ///
  /// perInstanceConfig.name serves as a key used to distinguish whether to
  /// perform insert or patch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request, should conform to
  /// RFC1035.
  ///
  /// [instanceGroupManager] - The name of the managed instance group. It should
  /// conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> updatePerInstanceConfigs(
    RegionInstanceGroupManagerUpdateInstanceConfigReq request,
    core.String project,
    core.String region,
    core.String instanceGroupManager, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroupManagers/' +
        commons.escapeVariable('$instanceGroupManager') +
        '/updatePerInstanceConfigs';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstanceGroupsResource {
  final commons.ApiRequester _requester;

  RegionInstanceGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Returns the specified instance group resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the instance group resource to return.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [InstanceGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<InstanceGroup> get(
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return InstanceGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of instance group resources contained within the
  /// specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionInstanceGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the instances in the specified instance group and displays
  /// information about the named ports.
  ///
  /// Depending on the specified options, this method can list all instances or
  /// only the instances that are running. The orderBy query parameter is not
  /// supported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - Name of the regional instance group for which we want to
  /// list the instances.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionInstanceGroupsListInstances].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionInstanceGroupsListInstances> listInstances(
    RegionInstanceGroupsListInstancesRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/listInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return RegionInstanceGroupsListInstances.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the named ports for the specified regional instance group.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  ///
  /// [instanceGroup] - The name of the regional instance group where the named
  /// ports are updated.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setNamedPorts(
    RegionInstanceGroupsSetNamedPortsRequest request,
    core.String project,
    core.String region,
    core.String instanceGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instanceGroups/' +
        commons.escapeVariable('$instanceGroup') +
        '/setNamedPorts';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionInstancesResource {
  final commons.ApiRequester _requester;

  RegionInstancesResource(commons.ApiRequester client) : _requester = client;

  /// Creates multiple instances in a given region.
  ///
  /// Count specifies the number of instances to create.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> bulkInsert(
    BulkInsertInstanceResource request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/instances/bulkInsert';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionNetworkEndpointGroupsResource {
  final commons.ApiRequester _requester;

  RegionNetworkEndpointGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified network endpoint group.
  ///
  /// Note that the NEG cannot be deleted if it is configured as a backend of a
  /// backend service.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group to delete.
  /// It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified network endpoint group.
  ///
  /// Gets a list of available network endpoint groups by making a list()
  /// request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [networkEndpointGroup] - The name of the network endpoint group. It should
  /// comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroup> get(
    core.String project,
    core.String region,
    core.String networkEndpointGroup, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups/' +
        commons.escapeVariable('$networkEndpointGroup');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroup.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a network endpoint group in the specified project using the
  /// parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where you want to create the network
  /// endpoint group. It should comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NetworkEndpointGroup request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of regional network endpoint groups available to the
  /// specified project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region where the network endpoint group is
  /// located. It should comply with RFC1035.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NetworkEndpointGroupList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NetworkEndpointGroupList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/networkEndpointGroups';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NetworkEndpointGroupList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionNotificationEndpointsResource {
  final commons.ApiRequester _requester;

  RegionNotificationEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified NotificationEndpoint in the given region
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.escapeVariable('$notificationEndpoint');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified NotificationEndpoint resource in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [notificationEndpoint] - Name of the NotificationEndpoint resource to
  /// return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpoint> get(
    core.String project,
    core.String region,
    core.String notificationEndpoint, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints/' +
        commons.escapeVariable('$notificationEndpoint');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NotificationEndpoint.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Create a NotificationEndpoint in the specified project in the given region
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    NotificationEndpoint request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the NotificationEndpoints for a project in the given region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [NotificationEndpointList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<NotificationEndpointList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/notificationEndpoints';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return NotificationEndpointList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionOperationsResource {
  final commons.ApiRequester _requester;

  RegionOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified region-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String region,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionSslCertificatesResource {
  final commons.ApiRequester _requester;

  RegionSslCertificatesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified SslCertificate resource in the region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SslCertificate resource in the specified region.
  ///
  /// Get a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String region,
    core.String sslCertificate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a SslCertificate resource in the specified project and region
  /// using the data included in the request
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionTargetHttpProxiesResource {
  final commons.ApiRequester _requester;

  RegionTargetHttpProxiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpProxy resource in the specified region.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionTargetHttpsProxiesResource {
  final commons.ApiRequester _requester;

  RegionTargetHttpsProxiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpsProxy resource in the specified region.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpsProxy resource in the specified project and region
  /// using the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    RegionTargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String region,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RegionUrlMapsResource {
  final commons.ApiRequester _requester;

  RegionUrlMapsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified UrlMap resource.
  ///
  /// Gets a list of available URL maps by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMap.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of UrlMap resources available to the specified project
  /// in the specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - begin_interface: MixerMutationRequestBuilder Request ID to
  /// support idempotency.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Runs static validation for the UrlMap.
  ///
  /// In particular, the tests of the provided UrlMap will be run. Calling this
  /// method does NOT create the UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    RegionUrlMapsValidateRequest request,
    core.String project,
    core.String region,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/validate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return UrlMapsValidateResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RegionsResource {
  final commons.ApiRequester _requester;

  RegionsResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Region resource.
  ///
  /// Gets a list of available regions by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Region].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Region> get(
    core.String project,
    core.String region, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Region.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of region resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RegionList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RegionList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/regions';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RegionList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ReservationsResource {
  final commons.ApiRequester _requester;

  ReservationsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of reservations.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/reservations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ReservationAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves information about the specified reservation.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to retrieve.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Reservation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Reservation> get(
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Reservation.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String zone,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new reservation.
  ///
  /// For more information, read Reserving zonal resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Reservation request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// A list of all the reservations that have been configured for the specified
  /// project in specified zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ReservationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ReservationList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ReservationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Resizes the reservation (applicable to standalone reservations only).
  ///
  /// For more information, read Modifying reservations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [reservation] - Name of the reservation to update.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> resize(
    ReservationsResizeRequest request,
    core.String project,
    core.String zone,
    core.String reservation, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$reservation') +
        '/resize';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    ZoneSetPolicyRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - The name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String zone,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/reservations/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ResourcePoliciesResource {
  final commons.ApiRequester _requester;

  ResourcePoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of resource policies.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resourcePolicy] - Name of the resource policy to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resourcePolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves all information of the specified resource policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resourcePolicy] - Name of the resource policy to retrieve.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicy> get(
    core.String project,
    core.String region,
    core.String resourcePolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resourcePolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new resource policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    ResourcePolicy request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// A list all the resource policies that have been configured for the
  /// specified project in specified region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ResourcePolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ResourcePolicyList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ResourcePolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/resourcePolicies/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class RoutersResource {
  final commons.ApiRequester _requester;

  RoutersResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of routers.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/routers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified Router resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Router resource.
  ///
  /// Gets a list of available routers by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Router].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Router> get(
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Router.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves runtime Nat mapping information of VM endpoints.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query for Nat Mapping
  /// information of VM endpoints.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VmEndpointNatMappingsList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VmEndpointNatMappingsList> getNatMappingInfo(
    core.String project,
    core.String region,
    core.String router, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/getNatMappingInfo';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VmEndpointNatMappingsList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves runtime information of the specified router.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterStatusResponse> getRouterStatus(
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/getRouterStatus';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterStatusResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Router resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Router request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Router resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouterList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouterList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouterList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified Router resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Preview fields auto-generated during router create and update operations.
  ///
  /// Calling this method does NOT create or update the router.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to query.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RoutersPreviewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RoutersPreviewResponse> preview(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router') +
        '/preview';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return RoutersPreviewResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified Router resource with the data included in the
  /// request.
  ///
  /// This method conforms to PUT semantics, which requests that the state of
  /// the target resource be created or replaced with the state defined by the
  /// representation enclosed in the request message payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [router] - Name of the Router resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    Router request,
    core.String project,
    core.String region,
    core.String router, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/routers/' +
        commons.escapeVariable('$router');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class RoutesResource {
  final commons.ApiRequester _requester;

  RoutesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Route resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [route] - Name of the Route resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String route, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/routes/' +
        commons.escapeVariable('$route');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Route resource.
  ///
  /// Gets a list of available routes by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [route] - Name of the Route resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Route].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Route> get(
    core.String project,
    core.String route, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/routes/' +
        commons.escapeVariable('$route');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Route.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Route resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Route request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/routes';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Route resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [RouteList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<RouteList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/routes';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return RouteList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class SecurityPoliciesResource {
  final commons.ApiRequester _requester;

  SecurityPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Inserts a rule into a security policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/addRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String securityPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// List all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to get.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicy> get(
    core.String project,
    core.String securityPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to which the queried rule
  /// belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to get from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyRule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyRule> getRule(
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/getRule';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicyRule.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new policy in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SecurityPolicy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// List all the policies that have been configured for the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SecurityPolicyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPolicyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPolicyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the current list of preconfigured Web Application Firewall (WAF)
  /// expressions.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [SecurityPoliciesListPreconfiguredExpressionSetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SecurityPoliciesListPreconfiguredExpressionSetsResponse>
      listPreconfiguredExpressionSets(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/listPreconfiguredExpressionSets';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified policy with the data included in the request.
  ///
  /// This cannot be used to be update the rules in the policy. Please use the
  /// per rule methods like addRule, patchRule, and removeRule instead.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SecurityPolicy request,
    core.String project,
    core.String securityPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Patches a rule at the specified priority.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to patch.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patchRule(
    SecurityPolicyRule request,
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/patchRule';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a rule at the specified priority.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [securityPolicy] - Name of the security policy to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [priority] - The priority of the rule to remove from the security policy.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeRule(
    core.String project,
    core.String securityPolicy, {
    core.int? priority,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (priority != null) 'priority': ['${priority}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/securityPolicies/' +
        commons.escapeVariable('$securityPolicy') +
        '/removeRule';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class SnapshotsResource {
  final commons.ApiRequester _requester;

  SnapshotsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified Snapshot resource.
  ///
  /// Keep in mind that deleting a single snapshot might not necessarily delete
  /// all the data on that snapshot. If any data on the snapshot that is marked
  /// for deletion is needed for subsequent snapshots, the data will be moved to
  /// the next corresponding snapshot.
  ///
  /// For more information, see Deleting snapshots.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [snapshot] - Name of the Snapshot resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String snapshot, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$snapshot');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified Snapshot resource.
  ///
  /// Gets a list of available snapshots by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [snapshot] - Name of the Snapshot resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Snapshot].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Snapshot> get(
    core.String project,
    core.String snapshot, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$snapshot');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Snapshot.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Snapshot resources contained within the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SnapshotList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SnapshotList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/snapshots';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SnapshotList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    GlobalSetPolicyRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a snapshot.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    GlobalSetLabelsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9_\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/snapshots/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class SslCertificatesResource {
  final commons.ApiRequester _requester;

  SslCertificatesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all SslCertificate resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified SslCertificate resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslCertificate, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SslCertificate resource.
  ///
  /// Gets a list of available SSL certificates by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslCertificate] - Name of the SslCertificate resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificate> get(
    core.String project,
    core.String sslCertificate, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates/' +
        commons.escapeVariable('$sslCertificate');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificate.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a SslCertificate resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslCertificate request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of SslCertificate resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslCertificateList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslCertificateList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslCertificates';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslCertificateList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class SslPoliciesResource {
  final commons.ApiRequester _requester;

  SslPoliciesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified SSL policy.
  ///
  /// The SSL policy resource can be deleted only if it is not in use by any
  /// TargetHttpsProxy or TargetSslProxy resources.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to delete. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String sslPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all of the ordered rules present in a single specified policy.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPolicy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPolicy> get(
    core.String project,
    core.String sslPolicy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPolicy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified SSL policy resource.
  ///
  /// Gets a list of available SSL policies by making a list() request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    SslPolicy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the SSL policies that have been configured for the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPoliciesList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Lists all features that can be specified in the SSL policy when using
  /// custom profile.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SslPoliciesListAvailableFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SslPoliciesListAvailableFeaturesResponse> listAvailableFeatures(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/listAvailableFeatures';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SslPoliciesListAvailableFeaturesResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified SSL policy with the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [sslPolicy] - Name of the SSL policy to update. The name must be 1-63
  /// characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    SslPolicy request,
    core.String project,
    core.String sslPolicy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/sslPolicies/' +
        commons.escapeVariable('$sslPolicy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class SubnetworksResource {
  final commons.ApiRequester _requester;

  SubnetworksResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of subnetworks.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/subnetworks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SubnetworkAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified subnetwork.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Expands the IP CIDR range of the subnetwork to a specified value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> expandIpCidrRange(
    SubnetworksExpandIpCidrRangeRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork') +
        '/expandIpCidrRange';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified subnetwork.
  ///
  /// Gets a list of available subnetworks list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Subnetwork].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Subnetwork> get(
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Subnetwork.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// May be empty if no such policy or resource exists.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [optionsRequestedPolicyVersion] - Requested IAM Policy version.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> getIamPolicy(
    core.String project,
    core.String region,
    core.String resource, {
    core.int? optionsRequestedPolicyVersion,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion': ['${optionsRequestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/getIamPolicy';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a subnetwork in the specified project using the data included in
  /// the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    Subnetwork request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of subnetworks available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [SubnetworkList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<SubnetworkList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return SubnetworkList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of all usable subnetworks in the project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UsableSubnetworksAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UsableSubnetworksAggregatedList> listUsable(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/subnetworks/listUsable';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UsableSubnetworksAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified subnetwork with the data included in the request.
  ///
  /// Only certain fields can be updated with a patch request as indicated in
  /// the field descriptions. You must specify the current fingerprint of the
  /// subnetwork resource being patched.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [drainTimeoutSeconds] - The drain timeout specifies the upper bound in
  /// seconds on the amount of time allowed to drain connections from the
  /// current ACTIVE subnetwork to the current BACKUP subnetwork. The drain
  /// timeout is only applicable when the following conditions are true: - the
  /// subnetwork being patched has purpose = INTERNAL_HTTPS_LOAD_BALANCER - the
  /// subnetwork being patched has role = BACKUP - the patch request is setting
  /// the role to ACTIVE. Note that after this patch operation the roles of the
  /// ACTIVE and BACKUP subnetworks will be swapped.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    Subnetwork request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.int? drainTimeoutSeconds,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (drainTimeoutSeconds != null)
        'drainTimeoutSeconds': ['${drainTimeoutSeconds}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Policy> setIamPolicy(
    RegionSetPolicyRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/setIamPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Policy.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Set whether VMs in this subnet can access Google services without
  /// assigning external IP addresses through Private Google Access.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [subnetwork] - Name of the Subnetwork resource.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setPrivateIpGoogleAccess(
    SubnetworksSetPrivateIpGoogleAccessRequest request,
    core.String project,
    core.String region,
    core.String subnetwork, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$subnetwork') +
        '/setPrivateIpGoogleAccess';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/subnetworks/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class TargetGrpcProxiesResource {
  final commons.ApiRequester _requester;

  TargetGrpcProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetGrpcProxy in the given scope
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetGrpcProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetGrpcProxy resource in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxy> get(
    core.String project,
    core.String targetGrpcProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetGrpcProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetGrpcProxy in the specified project in the given scope
  /// using the parameters that are included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetGrpcProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Lists the TargetGrpcProxies for a project in the given scope.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetGrpcProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetGrpcProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetGrpcProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetGrpcProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetGrpcProxy] - Name of the TargetGrpcProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetGrpcProxy request,
    core.String project,
    core.String targetGrpcProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetGrpcProxies/' +
        commons.escapeVariable('$targetGrpcProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetHttpProxiesResource {
  final commons.ApiRequester _requester;

  TargetHttpProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all TargetHttpProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetHttpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpProxy resource.
  ///
  /// Gets a list of available target HTTP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxy> get(
    core.String project,
    core.String targetHttpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetHttpProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules. (== suppress_warning http-rest-shadowed ==)
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetHttpProxy request,
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpProxy] - Name of the TargetHttpProxy to set a URL map for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpProxies/' +
        commons.escapeVariable('$targetHttpProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetHttpsProxiesResource {
  final commons.ApiRequester _requester;

  TargetHttpsProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all TargetHttpsProxy resources, regional and global,
  /// available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetHttpsProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetHttpsProxy resource.
  ///
  /// Gets a list of available target HTTPS proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxy> get(
    core.String project,
    core.String targetHttpsProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetHttpsProxy resource in the specified project using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetHttpsProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetHttpsProxy resources available to the
  /// specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetHttpsProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetHttpsProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetHttpsProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified TargetHttpsProxy resource with the data included in
  /// the request.
  ///
  /// This method supports PATCH semantics and uses JSON merge patch format and
  /// processing rules. (== suppress_warning http-rest-shadowed ==)
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    TargetHttpsProxy request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the QUIC override policy for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set the QUIC
  /// override policy for. The name should conform to RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setQuicOverride(
    TargetHttpsProxiesSetQuicOverrideRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setQuicOverride';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Replaces SslCertificates for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource to set an
  /// SslCertificates resource for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetHttpsProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the SSL policy for TargetHttpsProxy.
  ///
  /// The SSL policy specifies the server-side support for SSL features. This
  /// affects connections between clients and the HTTPS proxy load balancer.
  /// They do not affect the connection between the load balancer and the
  /// backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose SSL
  /// policy is to be set. The name must be 1-63 characters long, and comply
  /// with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setSslPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the URL map for TargetHttpsProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetHttpsProxy] - Name of the TargetHttpsProxy resource whose URL map
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setUrlMap(
    UrlMapReference request,
    core.String project,
    core.String targetHttpsProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/targetHttpsProxies/' +
        commons.escapeVariable('$targetHttpsProxy') +
        '/setUrlMap';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetInstancesResource {
  final commons.ApiRequester _requester;

  TargetInstancesResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target instances.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetInstances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstanceAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified TargetInstance resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetInstance] - Name of the TargetInstance resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances/' +
        commons.escapeVariable('$targetInstance');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetInstance resource.
  ///
  /// Gets a list of available target instances by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetInstance] - Name of the TargetInstance resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstance> get(
    core.String project,
    core.String zone,
    core.String targetInstance, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances/' +
        commons.escapeVariable('$targetInstance');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstance.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetInstance resource in the specified project and zone using
  /// the data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetInstance request,
    core.String project,
    core.String zone, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of TargetInstance resources available to the specified
  /// project and zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetInstanceList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetInstanceList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/targetInstances';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetInstanceList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class TargetPoolsResource {
  final commons.ApiRequester _requester;

  TargetPoolsResource(commons.ApiRequester client) : _requester = client;

  /// Adds health check URLs to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the target pool to add a health check to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addHealthCheck(
    TargetPoolsAddHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/addHealthCheck';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Adds an instance to a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to add instances to.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> addInstance(
    TargetPoolsAddInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/addInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves an aggregated list of target pools.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetPools';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPoolAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified target pool.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified target pool.
  ///
  /// Gets a list of available target pools by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPool> get(
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPool.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Gets the most recent health check results for each IP for the instance
  /// that is referenced by the given target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to which the queried
  /// instance belongs.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolInstanceHealth].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolInstanceHealth> getHealth(
    InstanceReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/getHealth';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TargetPoolInstanceHealth.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a target pool in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetPool request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of target pools available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetPoolList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetPoolList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetPoolList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Removes health check URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the target pool to remove health checks from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeHealthCheck(
    TargetPoolsRemoveHealthCheckRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/removeHealthCheck';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Removes instance URL from a target pool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to remove instances from.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> removeInstance(
    TargetPoolsRemoveInstanceRequest request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/removeInstance';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes a backup target pool's configurations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region scoping this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetPool] - Name of the TargetPool resource to set a backup pool for.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [failoverRatio] - New failoverRatio value for the target pool.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackup(
    TargetReference request,
    core.String project,
    core.String region,
    core.String targetPool, {
    core.double? failoverRatio,
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (failoverRatio != null) 'failoverRatio': ['${failoverRatio}'],
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetPools/' +
        commons.escapeVariable('$targetPool') +
        '/setBackup';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetSslProxiesResource {
  final commons.ApiRequester _requester;

  TargetSslProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetSslProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetSslProxy resource.
  ///
  /// Gets a list of available target SSL proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxy> get(
    core.String project,
    core.String targetSslProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetSslProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetSslProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetSslProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetSslProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetSslProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetSslProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetSslProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the BackendService for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetSslProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setBackendService';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the ProxyHeaderType for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetSslProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setProxyHeader';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes SslCertificates for TargetSslProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose
  /// SslCertificate resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslCertificates(
    TargetSslProxiesSetSslCertificatesRequest request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setSslCertificates';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the SSL policy for TargetSslProxy.
  ///
  /// The SSL policy specifies the server-side support for SSL features. This
  /// affects connections between clients and the SSL proxy load balancer. They
  /// do not affect the connection between the load balancer and the backends.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetSslProxy] - Name of the TargetSslProxy resource whose SSL policy is
  /// to be set. The name must be 1-63 characters long, and comply with RFC1035.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setSslPolicy(
    SslPolicyReference request,
    core.String project,
    core.String targetSslProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetSslProxies/' +
        commons.escapeVariable('$targetSslProxy') +
        '/setSslPolicy';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetTcpProxiesResource {
  final commons.ApiRequester _requester;

  TargetTcpProxiesResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified TargetTcpProxy resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified TargetTcpProxy resource.
  ///
  /// Gets a list of available target TCP proxies by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxy> get(
    core.String project,
    core.String targetTcpProxy, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetTcpProxy.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TargetTcpProxy resource in the specified project using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetTcpProxy request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of TargetTcpProxy resources available to the specified
  /// project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetTcpProxyList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetTcpProxyList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetTcpProxyList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the BackendService for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose
  /// BackendService resource is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setBackendService(
    TargetTcpProxiesSetBackendServiceRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy') +
        '/setBackendService';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Changes the ProxyHeaderType for TargetTcpProxy.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [targetTcpProxy] - Name of the TargetTcpProxy resource whose ProxyHeader
  /// is to be set.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setProxyHeader(
    TargetTcpProxiesSetProxyHeaderRequest request,
    core.String project,
    core.String targetTcpProxy, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/targetTcpProxies/' +
        commons.escapeVariable('$targetTcpProxy') +
        '/setProxyHeader';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class TargetVpnGatewaysResource {
  final commons.ApiRequester _requester;

  TargetVpnGatewaysResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of target VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGatewayAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified target VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.escapeVariable('$targetVpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified target VPN gateway.
  ///
  /// Gets a list of available target VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [targetVpnGateway] - Name of the target VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGateway> get(
    core.String project,
    core.String region,
    core.String targetVpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways/' +
        commons.escapeVariable('$targetVpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a target VPN gateway in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    TargetVpnGateway request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of target VPN gateways available to the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TargetVpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TargetVpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/targetVpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return TargetVpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class UrlMapsResource {
  final commons.ApiRequester _requester;

  UrlMapsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves the list of all UrlMap resources, regional and global, available
  /// to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Name of the project scoping this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapsAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified UrlMap resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified UrlMap resource.
  ///
  /// Gets a list of available URL maps by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMap].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMap> get(
    core.String project,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMap.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a UrlMap resource in the specified project using the data included
  /// in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    UrlMap request,
    core.String project, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/urlMaps';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Initiates a cache invalidation operation, invalidating the specified path,
  /// scoped to the specified UrlMap.
  ///
  /// For more information, see \[Invalidating cached
  /// content\](/cdn/docs/invalidating-cached-content).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap scoping this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> invalidateCache(
    CacheInvalidationRule request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/invalidateCache';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of UrlMap resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url =
        'projects/' + commons.escapeVariable('$project') + '/global/urlMaps';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return UrlMapList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Patches the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// This method supports PATCH semantics and uses the JSON merge patch format
  /// and processing rules.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to patch.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> patch(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PATCH',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Updates the specified UrlMap resource with the data included in the
  /// request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to update.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> update(
    UrlMap request,
    core.String project,
    core.String urlMap, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap');

    final _response = await _requester.request(
      _url,
      'PUT',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Runs static validation for the UrlMap.
  ///
  /// In particular, the tests of the provided UrlMap will be run. Calling this
  /// method does NOT create the UrlMap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [urlMap] - Name of the UrlMap resource to be validated as.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [UrlMapsValidateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<UrlMapsValidateResponse> validate(
    UrlMapsValidateRequest request,
    core.String project,
    core.String urlMap, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/global/urlMaps/' +
        commons.escapeVariable('$urlMap') +
        '/validate';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return UrlMapsValidateResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class VpnGatewaysResource {
  final commons.ApiRequester _requester;

  VpnGatewaysResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN gateways.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/vpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewayAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified VPN gateway.
  ///
  /// Gets a list of available VPN gateways by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGateway].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGateway> get(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGateway.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the status for the specified VPN gateway.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnGateway] - Name of the VPN gateway to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewaysGetStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewaysGetStatusResponse> getStatus(
    core.String project,
    core.String region,
    core.String vpnGateway, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$vpnGateway') +
        '/getStatus';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewaysGetStatusResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a VPN gateway in the specified project and region using the data
  /// included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnGateway request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of VPN gateways available to the specified project and
  /// region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnGatewayList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnGatewayList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnGatewayList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Sets the labels on a VpnGateway.
  ///
  /// To learn more about labels, read the Labeling Resources documentation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> setLabels(
    RegionSetLabelsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$resource') +
        '/setLabels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - The name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [resource] - Name or id of the resource for this request.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [TestPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<TestPermissionsResponse> testIamPermissions(
    TestPermissionsRequest request,
    core.String project,
    core.String region,
    core.String resource, {
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnGateways/' +
        commons.escapeVariable('$resource') +
        '/testIamPermissions';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return TestPermissionsResponse.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class VpnTunnelsResource {
  final commons.ApiRequester _requester;

  VpnTunnelsResource(commons.ApiRequester client) : _requester = client;

  /// Retrieves an aggregated list of VPN tunnels.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [includeAllScopes] - Indicates whether every visible scope for each scope
  /// type (zone, region, global) should be included in the response. For new
  /// resource types added after this field, the flag has no effect as new
  /// resource types will always include every visible scope for each scope type
  /// in response. For resource types which predate this field, if this flag is
  /// omitted or false, only scopes of the scope types where the resource type
  /// is expected to be found will be included.
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelAggregatedList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelAggregatedList> aggregatedList(
    core.String project, {
    core.String? filter,
    core.bool? includeAllScopes,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (includeAllScopes != null) 'includeAllScopes': ['${includeAllScopes}'],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/aggregated/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnelAggregatedList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Deletes the specified VpnTunnel resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> delete(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels/' +
        commons.escapeVariable('$vpnTunnel');

    final _response = await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Returns the specified VpnTunnel resource.
  ///
  /// Gets a list of available VPN tunnels by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [vpnTunnel] - Name of the VpnTunnel resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnel> get(
    core.String project,
    core.String region,
    core.String vpnTunnel, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels/' +
        commons.escapeVariable('$vpnTunnel');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnel.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Creates a VpnTunnel resource in the specified project and region using the
  /// data included in the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [requestId] - An optional request ID to identify requests. Specify a
  /// unique request ID so that if you must retry your request, the server will
  /// know to ignore the request if it has already been completed.
  ///
  /// For example, consider a situation where you make an initial request and
  /// the request times out. If you make the request again with the same request
  /// ID, the server can check if original operation with the same request ID
  /// was received, and if so, will ignore the second request. This prevents
  /// clients from accidentally creating duplicate commitments.
  ///
  /// The request ID must be a valid UUID with the exception that zero UUID is
  /// not supported (00000000-0000-0000-0000-000000000000).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> insert(
    VpnTunnel request,
    core.String project,
    core.String region, {
    core.String? requestId,
    core.String? $fields,
  }) async {
    final _body = convert.json.encode(request.toJson());
    final _queryParams = <core.String, core.List<core.String>>{
      if (requestId != null) 'requestId': [requestId],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'POST',
      body: _body,
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of VpnTunnel resources contained in the specified project
  /// and region.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [region] - Name of the region for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [VpnTunnelList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<VpnTunnelList> list(
    core.String project,
    core.String region, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/regions/' +
        commons.escapeVariable('$region') +
        '/vpnTunnels';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return VpnTunnelList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }
}

class ZoneOperationsResource {
  final commons.ApiRequester _requester;

  ZoneOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Deletes the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to delete.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<void> delete(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation');

    await _requester.request(
      _url,
      'DELETE',
      queryParams: _queryParams,
      downloadOptions: null,
    );
  }

  /// Retrieves the specified zone-specific Operations resource.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> get(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a list of Operation resources contained within the specified
  /// zone.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [OperationList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<OperationList> list(
    core.String project,
    core.String zone, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return OperationList.fromJson(
        _response as core.Map<core.String, core.dynamic>);
  }

  /// Waits for the specified Operation resource to return as `DONE` or for the
  /// request to approach the 2 minute deadline, and retrieves the specified
  /// Operation resource.
  ///
  /// This method differs from the `GET` method in that it waits for no more
  /// than the default deadline (2 minutes) and then returns the current state
  /// of the operation, which might be `DONE` or still in progress.
  ///
  /// This method is called on a best-effort basis. Specifically:
  /// - In uncommon cases, when the server is overloaded, the request might
  /// return before the default deadline is reached, or might return after zero
  /// seconds.
  /// - If the default deadline is reached, there is no guarantee that the
  /// operation is actually done when the method returns. Be prepared to retry
  /// if the operation is not `DONE`.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone for this request.
  /// Value must have pattern `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
  ///
  /// [operation] - Name of the Operations resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Operation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Operation> wait(
    core.String project,
    core.String zone,
    core.String operation, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone') +
        '/operations/' +
        commons.escapeVariable('$operation') +
        '/wait';

    final _response = await _requester.request(
      _url,
      'POST',
      queryParams: _queryParams,
    );
    return Operation.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

class ZonesResource {
  final commons.ApiRequester _requester;

  ZonesResource(commons.ApiRequester client) : _requester = client;

  /// Returns the specified Zone resource.
  ///
  /// Gets a list of available zones by making a list() request.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [zone] - Name of the zone resource to return.
  /// Value must have pattern
  /// `\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?|\[1-9\]\[0-9\]{0,19}`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [Zone].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<Zone> get(
    core.String project,
    core.String zone, {
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' +
        commons.escapeVariable('$project') +
        '/zones/' +
        commons.escapeVariable('$zone');

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return Zone.fromJson(_response as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves the list of Zone resources available to the specified project.
  ///
  /// Request parameters:
  ///
  /// [project] - Project ID for this request.
  /// Value must have pattern
  /// `(?:(?:\[-a-z0-9\]{1,63}\.)*(?:\[a-z\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?):)?(?:\[0-9\]{1,19}|(?:\[a-z0-9\](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?))`.
  ///
  /// [filter] - A filter expression that filters resources listed in the
  /// response. The expression must specify the field name, a comparison
  /// operator, and the value that you want to use for filtering. The value must
  /// be a string, a number, or a boolean. The comparison operator must be
  /// either `=`, `!=`, `>`, or `<`.
  ///
  /// For example, if you are filtering Compute Engine instances, you can
  /// exclude instances named `example-instance` by specifying `name !=
  /// example-instance`.
  ///
  /// You can also filter nested fields. For example, you could specify
  /// `scheduling.automaticRestart = false` to include instances only if they
  /// are not scheduled for automatic restarts. You can use filtering on nested
  /// fields to filter based on resource labels.
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. For example: ``` (scheduling.automaticRestart = true)
  /// (cpuPlatform = "Intel Skylake") ``` By default, each expression is an
  /// `AND` expression. However, you can include `AND` and `OR` expressions
  /// explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR
  /// (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true)
  /// ```
  ///
  /// [maxResults] - The maximum number of results per page that should be
  /// returned. If the number of available results is larger than `maxResults`,
  /// Compute Engine returns a `nextPageToken` that can be used to get the next
  /// page of results in subsequent list requests. Acceptable values are `0` to
  /// `500`, inclusive. (Default: `500`)
  ///
  /// [orderBy] - Sorts list results by a certain order. By default, results are
  /// returned in alphanumerical order based on the resource name.
  ///
  /// You can also sort results in descending order based on the creation
  /// timestamp using `orderBy="creationTimestamp desc"`. This sorts results
  /// based on the `creationTimestamp` field in reverse chronological order
  /// (newest result first). Use this to sort resources like operations so that
  /// the newest operation is returned first.
  ///
  /// Currently, only sorting by `name` or `creationTimestamp desc` is
  /// supported.
  ///
  /// [pageToken] - Specifies a page token to use. Set `pageToken` to the
  /// `nextPageToken` returned by a previous list request to get the next page
  /// of results.
  ///
  /// [returnPartialSuccess] - Opt-in for partial success behavior which
  /// provides partial results in case of failure. The default value is false.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [ZoneList].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<ZoneList> list(
    core.String project, {
    core.String? filter,
    core.int? maxResults,
    core.String? orderBy,
    core.String? pageToken,
    core.bool? returnPartialSuccess,
    core.String? $fields,
  }) async {
    final _queryParams = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxResults != null) 'maxResults': ['${maxResults}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageToken != null) 'pageToken': [pageToken],
      if (returnPartialSuccess != null)
        'returnPartialSuccess': ['${returnPartialSuccess}'],
      if ($fields != null) 'fields': [$fields],
    };

    final _url = 'projects/' + commons.escapeVariable('$project') + '/zones';

    final _response = await _requester.request(
      _url,
      'GET',
      queryParams: _queryParams,
    );
    return ZoneList.fromJson(_response as core.Map<core.String, core.dynamic>);
  }
}

/// A specification of the type and number of accelerator cards attached to the
/// instance.
class AcceleratorConfig {
  /// The number of the guest accelerator cards exposed to this instance.
  core.int? acceleratorCount;

  /// Full or partial URL of the accelerator type resource to attach to this
  /// instance.
  ///
  /// For example:
  /// projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
  /// If you are creating an instance template, specify only the accelerator
  /// name. See GPUs on Compute Engine for a full list of accelerator types.
  core.String? acceleratorType;

  AcceleratorConfig();

  AcceleratorConfig.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorCount')) {
      acceleratorCount = _json['acceleratorCount'] as core.int;
    }
    if (_json.containsKey('acceleratorType')) {
      acceleratorType = _json['acceleratorType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
      };
}

/// Represents an Accelerator Type resource.
///
/// Google Cloud Platform provides graphics processing units (accelerators) that
/// you can add to VM instances to improve or accelerate performance when
/// working with intensive workloads.
///
/// For more information, read GPUs on Compute Engine. (== resource_for
/// {$api_version}.acceleratorTypes ==)
class AcceleratorType {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this accelerator type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#acceleratorType for accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum number of accelerator cards allowed per instance.
  ///
  /// Output only.
  core.int? maximumCardsPerInstance;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined, fully qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the accelerator type resides, such as
  /// us-central1-a.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  AcceleratorType();

  AcceleratorType.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('maximumCardsPerInstance')) {
      maximumCardsPerInstance = _json['maximumCardsPerInstance'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (maximumCardsPerInstance != null)
          'maximumCardsPerInstance': maximumCardsPerInstance!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class AcceleratorTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypeAggregatedListWarningData();

  AcceleratorTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AcceleratorTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypeAggregatedListWarning();

  AcceleratorTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypeAggregatedListWarningData>((value) =>
              AcceleratorTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AcceleratorTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AcceleratorTypesScopedList resources.
  core.Map<core.String, AcceleratorTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#acceleratorTypeAggregatedList for aggregated lists of
  /// accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AcceleratorTypeAggregatedListWarning? warning;

  AcceleratorTypeAggregatedList();

  AcceleratorTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          AcceleratorTypesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AcceleratorTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypeListWarningData();

  AcceleratorTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AcceleratorTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypeListWarning();

  AcceleratorTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypeListWarningData>((value) =>
              AcceleratorTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of accelerator types.
class AcceleratorTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AcceleratorType resources.
  core.List<AcceleratorType>? items;

  /// Type of resource.
  ///
  /// Always compute#acceleratorTypeList for lists of accelerator types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AcceleratorTypeListWarning? warning;

  AcceleratorTypeList();

  AcceleratorTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<AcceleratorType>((value) => AcceleratorType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AcceleratorTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AcceleratorTypesScopedListWarningData();

  AcceleratorTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the accelerator types list is
/// empty.
///
/// Output only.
class AcceleratorTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AcceleratorTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AcceleratorTypesScopedListWarning();

  AcceleratorTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AcceleratorTypesScopedListWarningData>((value) =>
              AcceleratorTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AcceleratorTypesScopedList {
  /// A list of accelerator types contained in this scope.
  ///
  /// Output only.
  core.List<AcceleratorType>? acceleratorTypes;

  /// An informational warning that appears when the accelerator types list is
  /// empty.
  ///
  /// Output only.
  AcceleratorTypesScopedListWarning? warning;

  AcceleratorTypesScopedList();

  AcceleratorTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorTypes')) {
      acceleratorTypes = (_json['acceleratorTypes'] as core.List)
          .map<AcceleratorType>((value) => AcceleratorType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AcceleratorTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorTypes != null)
          'acceleratorTypes':
              acceleratorTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// An access configuration attached to an instance's network interface.
///
/// Only one access config per instance is supported.
class AccessConfig {
  /// Type of the resource.
  ///
  /// Always compute#accessConfig for access configs.
  ///
  /// Output only.
  core.String? kind;

  /// The name of this access configuration.
  ///
  /// The default and recommended name is External NAT, but you can use any
  /// arbitrary string, such as My external IP or Network Access.
  core.String? name;

  /// An external IP address associated with this instance.
  ///
  /// Specify an unused static external IP address available to the project or
  /// leave this field undefined to use an IP from a shared ephemeral IP address
  /// pool. If you specify a static external IP address, it must live in the
  /// same region as the zone of the instance.
  core.String? natIP;

  /// This signifies the networking tier used for configuring this access
  /// configuration and can only take the following values: PREMIUM, STANDARD.
  ///
  /// If an AccessConfig is specified without a valid external IP address, an
  /// ephemeral IP will be created with this networkTier.
  ///
  /// If an AccessConfig with a valid external IP address is specified, it must
  /// match that of the networkTier associated with the Address resource owning
  /// that IP.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? networkTier;

  /// The DNS domain name for the public PTR record.
  ///
  /// You can set this field only if the `setPublicPtr` field is enabled.
  core.String? publicPtrDomainName;

  /// Specifies whether a public DNS 'PTR' record should be created to map the
  /// external IP address of the instance to a DNS domain name.
  core.bool? setPublicPtr;

  /// The type of configuration.
  ///
  /// The default and only option is ONE_TO_ONE_NAT.
  /// Possible string values are:
  /// - "ONE_TO_ONE_NAT"
  core.String? type;

  AccessConfig();

  AccessConfig.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natIP')) {
      natIP = _json['natIP'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('publicPtrDomainName')) {
      publicPtrDomainName = _json['publicPtrDomainName'] as core.String;
    }
    if (_json.containsKey('setPublicPtr')) {
      setPublicPtr = _json['setPublicPtr'] as core.bool;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (natIP != null) 'natIP': natIP!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (publicPtrDomainName != null)
          'publicPtrDomainName': publicPtrDomainName!,
        if (setPublicPtr != null) 'setPublicPtr': setPublicPtr!,
        if (type != null) 'type': type!,
      };
}

/// Use global external addresses for GFE-based external HTTP(S) load balancers
/// in Premium Tier.
///
/// Use global internal addresses for reserved peering network range.
///
/// Use regional external addresses for the following resources:
///
/// - External IP addresses for VM instances - Regional external forwarding
/// rules - Cloud NAT external IP addresses - GFE based LBs in Standard Tier -
/// Network LBs in Premium or Standard Tier - Cloud VPN gateways (both Classic
/// and HA)
///
/// Use regional internal IP addresses for subnet IP ranges (primary and
/// secondary).
///
/// This includes:
///
/// - Internal IP addresses for VM instances - Alias IP ranges of VM instances
/// (/32 only) - Regional internal forwarding rules - Internal TCP/UDP load
/// balancer addresses - Internal HTTP(S) load balancer addresses - Cloud DNS
/// inbound forwarding IP addresses
///
/// For more information, read reserved IP address.
///
/// (== resource_for {$api_version}.addresses ==) (== resource_for
/// {$api_version}.globalAddresses ==)
class Address {
  /// The static IP address represented by this resource.
  core.String? address;

  /// The type of address to reserve, either INTERNAL or EXTERNAL.
  ///
  /// If unspecified, defaults to EXTERNAL.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "UNSPECIFIED_TYPE"
  core.String? addressType;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The IP version that will be used by this address.
  ///
  /// Valid options are IPV4 or IPV6. This can only be specified for a global
  /// address.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String? ipVersion;

  /// Type of the resource.
  ///
  /// Always compute#address for addresses.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// The URL of the network in which to reserve the address.
  ///
  /// This field can only be used with INTERNAL type with the VPC_PEERING
  /// purpose.
  core.String? network;

  /// This signifies the networking tier used for configuring this address and
  /// can only take the following values: PREMIUM or STANDARD.
  ///
  /// Global forwarding rules can only be Premium Tier. Regional forwarding
  /// rules can be either Premium or Standard Tier. Standard Tier addresses
  /// applied to regional forwarding rules can be used with any external load
  /// balancer. Regional forwarding rules in Premium Tier can only be used with
  /// a network load balancer.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? networkTier;

  /// The prefix length if the resource reprensents an IP range.
  core.int? prefixLength;

  /// The purpose of this resource, which can be one of the following values:
  /// - `GCE_ENDPOINT` for addresses that are used by VM instances, alias IP
  /// ranges, internal load balancers, and similar resources.
  ///
  ///
  /// - `DNS_RESOLVER` for a DNS resolver address in a subnetwork
  /// - `VPC_PEERING` for addresses that are reserved for VPC peer networks.
  /// - `NAT_AUTO` for addresses that are external IP addresses automatically
  /// reserved for Cloud NAT.
  /// - `IPSEC_INTERCONNECT` for addresses created from a private IP range that
  /// are reserved for a VLAN attachment in an IPsec encrypted Interconnect
  /// configuration. These addresses are regional resources.
  /// Possible string values are:
  /// - "DNS_RESOLVER"
  /// - "GCE_ENDPOINT"
  /// - "NAT_AUTO"
  /// - "PRIVATE_SERVICE_CONNECT"
  /// - "SHARED_LOADBALANCER_VIP"
  /// - "VPC_PEERING"
  core.String? purpose;

  /// The URL of the region where a regional address resides.
  ///
  /// For regional addresses, you must specify the region as a path parameter in
  /// the HTTP request URL. This field is not applicable to global addresses.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the address, which can be one of RESERVING, RESERVED, or
  /// IN_USE.
  ///
  /// An address that is RESERVING is currently in the process of being
  /// reserved. A RESERVED address is currently reserved and available to use.
  /// An IN_USE address is currently being used by another resource and is not
  /// available.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "IN_USE"
  /// - "RESERVED"
  /// - "RESERVING"
  core.String? status;

  /// The URL of the subnetwork in which to reserve the address.
  ///
  /// If an IP address is specified, it must be within the subnetwork's IP
  /// range. This field can only be used with INTERNAL type with a GCE_ENDPOINT
  /// or DNS_RESOLVER purpose.
  core.String? subnetwork;

  /// The URLs of the resources that are using this address.
  ///
  /// Output only.
  core.List<core.String>? users;

  Address();

  Address.fromJson(core.Map _json) {
    if (_json.containsKey('address')) {
      address = _json['address'] as core.String;
    }
    if (_json.containsKey('addressType')) {
      addressType = _json['addressType'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipVersion')) {
      ipVersion = _json['ipVersion'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('prefixLength')) {
      prefixLength = _json['prefixLength'] as core.int;
    }
    if (_json.containsKey('purpose')) {
      purpose = _json['purpose'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('users')) {
      users = (_json['users'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (address != null) 'address': address!,
        if (addressType != null) 'addressType': addressType!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (ipVersion != null) 'ipVersion': ipVersion!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (prefixLength != null) 'prefixLength': prefixLength!,
        if (purpose != null) 'purpose': purpose!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (users != null) 'users': users!,
      };
}

class AddressAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressAggregatedListWarningData();

  AddressAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AddressAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressAggregatedListWarning();

  AddressAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressAggregatedListWarningData>((value) =>
              AddressAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AddressAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AddressesScopedList resources.
  core.Map<core.String, AddressesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#addressAggregatedList for aggregated lists of addresses.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AddressAggregatedListWarning? warning;

  AddressAggregatedList();

  AddressAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          AddressesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AddressAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AddressListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressListWarningData();

  AddressListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AddressListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressListWarning();

  AddressListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressListWarningData>((value) =>
              AddressListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of addresses.
class AddressList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Address resources.
  core.List<Address>? items;

  /// Type of resource.
  ///
  /// Always compute#addressList for lists of addresses.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AddressListWarning? warning;

  AddressList();

  AddressList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Address>((value) =>
              Address.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AddressListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AddressesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AddressesScopedListWarningData();

  AddressesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class AddressesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AddressesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AddressesScopedListWarning();

  AddressesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AddressesScopedListWarningData>((value) =>
              AddressesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AddressesScopedList {
  /// A list of addresses contained in this scope.
  ///
  /// Output only.
  core.List<Address>? addresses;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  AddressesScopedListWarning? warning;

  AddressesScopedList();

  AddressesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('addresses')) {
      addresses = (_json['addresses'] as core.List)
          .map<Address>((value) =>
              Address.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AddressesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (addresses != null)
          'addresses': addresses!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Specifies options for controlling advanced machine features.
///
/// Options that would traditionally be configured in a BIOS belong here.
/// Features that require operating system support may have corresponding
/// entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in
/// the Image supports nested virtualization being enabled or disabled).
class AdvancedMachineFeatures {
  /// Whether to enable nested virtualization or not (default is false).
  core.bool? enableNestedVirtualization;

  AdvancedMachineFeatures();

  AdvancedMachineFeatures.fromJson(core.Map _json) {
    if (_json.containsKey('enableNestedVirtualization')) {
      enableNestedVirtualization =
          _json['enableNestedVirtualization'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableNestedVirtualization != null)
          'enableNestedVirtualization': enableNestedVirtualization!,
      };
}

/// An alias IP range attached to an instance's network interface.
class AliasIpRange {
  /// The IP alias ranges to allocate for this interface.
  ///
  /// This IP CIDR range must belong to the specified subnetwork and cannot
  /// contain IP addresses reserved by system or used by other network
  /// interfaces. This range may be a single IP address (such as 10.2.3.4), a
  /// netmask (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
  core.String? ipCidrRange;

  /// The name of a subnetwork secondary IP range from which to allocate an IP
  /// alias range.
  ///
  /// If not specified, the primary range of the subnetwork is used.
  core.String? subnetworkRangeName;

  AliasIpRange();

  AliasIpRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('subnetworkRangeName')) {
      subnetworkRangeName = _json['subnetworkRangeName'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (subnetworkRangeName != null)
          'subnetworkRangeName': subnetworkRangeName!,
      };
}

class AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk {
  /// Specifies the size of the disk in base-2 GB.
  core.String? diskSizeGb;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME.
  ///
  /// The default is SCSI. For performance characteristics of SCSI over NVMe,
  /// see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String? interface;

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk();

  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk.fromJson(
      core.Map _json) {
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('interface')) {
      interface = _json['interface'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (interface != null) 'interface': interface!,
      };
}

/// Properties of the SKU instances being reserved.
///
/// Next ID: 9
class AllocationSpecificSKUAllocationReservedInstanceProperties {
  /// Specifies accelerator type and count.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Specifies amount of local ssd to reserve with each instance.
  ///
  /// The type of disk is local-ssd.
  core.List<
          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>?
      localSsds;

  /// An opaque location hint used to place the allocation close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Specifies type of machine (name only) which has fixed number of vCPUs and
  /// fixed amount of memory.
  ///
  /// This also includes specifying custom machine type following
  /// custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
  core.String? machineType;

  /// Minimum cpu platform the reservation.
  core.String? minCpuPlatform;

  AllocationSpecificSKUAllocationReservedInstanceProperties();

  AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('localSsds')) {
      localSsds = (_json['localSsds'] as core.List)
          .map<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk>(
              (value) =>
                  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('locationHint')) {
      locationHint = _json['locationHint'] as core.String;
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (localSsds != null)
          'localSsds': localSsds!.map((value) => value.toJson()).toList(),
        if (locationHint != null) 'locationHint': locationHint!,
        if (machineType != null) 'machineType': machineType!,
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
      };
}

/// This reservation type allows to pre allocate specific instance
/// configuration.
class AllocationSpecificSKUReservation {
  /// Specifies the number of resources that are allocated.
  core.String? count;

  /// Indicates how many instances are in use.
  ///
  /// Output only.
  core.String? inUseCount;

  /// The instance properties for the reservation.
  AllocationSpecificSKUAllocationReservedInstanceProperties? instanceProperties;

  AllocationSpecificSKUReservation();

  AllocationSpecificSKUReservation.fromJson(core.Map _json) {
    if (_json.containsKey('count')) {
      count = _json['count'] as core.String;
    }
    if (_json.containsKey('inUseCount')) {
      inUseCount = _json['inUseCount'] as core.String;
    }
    if (_json.containsKey('instanceProperties')) {
      instanceProperties =
          AllocationSpecificSKUAllocationReservedInstanceProperties.fromJson(
              _json['instanceProperties']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (count != null) 'count': count!,
        if (inUseCount != null) 'inUseCount': inUseCount!,
        if (instanceProperties != null)
          'instanceProperties': instanceProperties!.toJson(),
      };
}

/// An instance-attached disk resource.
class AttachedDisk {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool? autoDelete;

  /// Indicates that this is a boot disk.
  ///
  /// The virtual machine will use the first partition of the disk for its root
  /// filesystem.
  core.bool? boot;

  /// Specifies a unique device name of your choice that is reflected into the
  /// /dev/disk/by-id/google-* tree of a Linux operating system running within
  /// the instance.
  ///
  /// This name can be used to reference the device for mounting, resizing, and
  /// so on, from within the instance.
  ///
  /// If not specified, the server chooses a default device name to apply to
  /// this disk, in the form persistent-disk-x, where x is a number assigned by
  /// Google Compute Engine. This field is only applicable for persistent disks.
  core.String? deviceName;

  /// Encrypts or decrypts a disk using a customer-supplied encryption key.
  ///
  /// If you are creating a new disk, this field encrypts the new disk using an
  /// encryption key that you provide.
  ///
  /// If you are attaching an existing disk that is already encrypted, this
  /// field decrypts the disk using the customer-supplied encryption key.
  ///
  /// If you encrypt a disk using a customer-supplied key, you must provide the
  /// same key again when you attempt to use this resource at a later time. For
  /// example, you must provide the key when you create a snapshot or an image
  /// from the disk or when you attach the disk to a virtual machine instance.
  ///
  /// If you do not provide an encryption key, then the disk will be encrypted
  /// using an automatically generated key and you do not need to provide a key
  /// to use the disk later.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot use your own keys to encrypt disks in a managed instance group.
  CustomerEncryptionKey? diskEncryptionKey;

  /// The size of the disk in GB.
  core.String? diskSizeGb;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// A zero-based index to this disk, where 0 is reserved for the boot disk.
  ///
  /// If you have many disks attached to an instance, each disk would have a
  /// unique index number.
  ///
  /// Output only.
  core.int? index;

  /// \[Input Only\] Specifies the parameters for a new disk that will be
  /// created alongside the new instance.
  ///
  /// Use initialization parameters to create boot disks or local SSDs attached
  /// to the new instance.
  ///
  /// This property is mutually exclusive with the source property; you can only
  /// define one or the other, but not both.
  AttachedDiskInitializeParams? initializeParams;

  /// Specifies the disk interface to use for attaching this disk, which is
  /// either SCSI or NVME.
  ///
  /// The default is SCSI. Persistent disks must always use SCSI and the request
  /// will fail if you attempt to attach a persistent disk in any other format
  /// than SCSI. Local SSDs can use either NVME or SCSI. For performance
  /// characteristics of SCSI over NVMe, see Local SSD performance.
  /// Possible string values are:
  /// - "NVME"
  /// - "SCSI"
  core.String? interface;

  /// Type of the resource.
  ///
  /// Always compute#attachedDisk for attached disks.
  ///
  /// Output only.
  core.String? kind;

  /// Any valid publicly visible licenses.
  ///
  /// Output only.
  core.List<core.String>? licenses;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
  ///
  /// If not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String? mode;

  /// shielded vm initial state stored on disk
  ///
  /// Output only.
  InitialStateConfig? shieldedInstanceInitialState;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource.
  ///
  /// When creating a new instance, one of initializeParams.sourceImage or
  /// initializeParams.sourceSnapshot or disks.source is required except for
  /// local SSD.
  ///
  /// If desired, you can also attach existing non-root persistent disks using
  /// this property. This field is only applicable for persistent disks.
  ///
  /// Note that for InstanceTemplate, specify the disk name, not the URL for the
  /// disk.
  core.String? source;

  /// Specifies the type of the disk, either SCRATCH or PERSISTENT.
  ///
  /// If not specified, the default is PERSISTENT.
  /// Possible string values are:
  /// - "PERSISTENT"
  /// - "SCRATCH"
  core.String? type;

  AttachedDisk();

  AttachedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.bool;
    }
    if (_json.containsKey('boot')) {
      boot = _json['boot'] as core.bool;
    }
    if (_json.containsKey('deviceName')) {
      deviceName = _json['deviceName'] as core.String;
    }
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('index')) {
      index = _json['index'] as core.int;
    }
    if (_json.containsKey('initializeParams')) {
      initializeParams = AttachedDiskInitializeParams.fromJson(
          _json['initializeParams'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('interface')) {
      interface = _json['interface'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('shieldedInstanceInitialState')) {
      shieldedInstanceInitialState = InitialStateConfig.fromJson(
          _json['shieldedInstanceInitialState']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (boot != null) 'boot': boot!,
        if (deviceName != null) 'deviceName': deviceName!,
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (index != null) 'index': index!,
        if (initializeParams != null)
          'initializeParams': initializeParams!.toJson(),
        if (interface != null) 'interface': interface!,
        if (kind != null) 'kind': kind!,
        if (licenses != null) 'licenses': licenses!,
        if (mode != null) 'mode': mode!,
        if (shieldedInstanceInitialState != null)
          'shieldedInstanceInitialState':
              shieldedInstanceInitialState!.toJson(),
        if (source != null) 'source': source!,
        if (type != null) 'type': type!,
      };
}

/// \[Input Only\] Specifies the parameters for a new disk that will be created
/// alongside the new instance.
///
/// Use initialization parameters to create boot disks or local SSDs attached to
/// the new instance.
///
/// This property is mutually exclusive with the source property; you can only
/// define one or the other, but not both.
class AttachedDiskInitializeParams {
  /// An optional description.
  ///
  /// Provide this property when creating the disk.
  core.String? description;

  /// Specifies the disk name.
  ///
  /// If not specified, the default is to use the name of the instance. If a
  /// disk with the same name already exists in the given region, the existing
  /// disk is attached to the new instance and the new disk is not created.
  core.String? diskName;

  /// Specifies the size of the disk in base-2 GB.
  ///
  /// The size must be at least 10 GB. If you specify a sourceImage, which is
  /// required for boot disks, the default size is the size of the sourceImage.
  /// If you do not specify a sourceImage, the default disk size is 500 GB.
  core.String? diskSizeGb;

  /// Specifies the disk type to use to create the instance.
  ///
  /// If not specified, the default is pd-standard, specified using the full
  /// URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard
  ///
  ///
  /// Other values include pd-ssd and local-ssd. If you define this field, you
  /// can provide either the full or partial URL. For example, the following are
  /// valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
  /// - projects/project/zones/zone/diskTypes/diskType
  /// - zones/zone/diskTypes/diskType Note that for InstanceTemplate, this is
  /// the name of the disk type, not URL.
  core.String? diskType;

  /// Labels to apply to this disk.
  ///
  /// These can be later modified by the disks.setLabels method. This field is
  /// only applicable for persistent disks.
  core.Map<core.String, core.String>? labels;

  /// Specifies which action to take on instance update with this disk.
  ///
  /// Default is to use the existing disk.
  /// Possible string values are:
  /// - "RECREATE_DISK"
  /// - "RECREATE_DISK_IF_SOURCE_CHANGED"
  /// - "USE_EXISTING_DISK"
  core.String? onUpdateAction;

  /// Indicates how many IOPS must be provisioned for the disk.
  core.String? provisionedIops;

  /// Resource policies applied to this disk for automatic snapshot creations.
  ///
  /// Specified using the full or partial URL. For instance template, specify
  /// only the resource policy name.
  core.List<core.String>? resourcePolicies;

  /// The source image to create this disk.
  ///
  /// When creating a new instance, one of initializeParams.sourceImage or
  /// initializeParams.sourceSnapshot or disks.source is required except for
  /// local SSD.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  ///
  ///
  /// If the source image is deleted later, this field will not be set.
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key.
  ///
  /// Instance templates do not store customer-supplied encryption keys, so you
  /// cannot create disks for instances in a managed instance group if the
  /// source images are encrypted with your own keys.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The source snapshot to create this disk.
  ///
  /// When creating a new instance, one of initializeParams.sourceSnapshot or
  /// initializeParams.sourceImage or disks.source is required except for local
  /// SSD.
  ///
  /// To create a disk with a snapshot that you created, specify the snapshot
  /// name in the following format:
  /// global/snapshots/my-backup
  ///
  ///
  /// If the source snapshot is deleted later, this field will not be set.
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  AttachedDiskInitializeParams();

  AttachedDiskInitializeParams.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskName')) {
      diskName = _json['diskName'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('diskType')) {
      diskType = _json['diskType'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('onUpdateAction')) {
      onUpdateAction = _json['onUpdateAction'] as core.String;
    }
    if (_json.containsKey('provisionedIops')) {
      provisionedIops = _json['provisionedIops'] as core.String;
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (diskName != null) 'diskName': diskName!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
        if (labels != null) 'labels': labels!,
        if (onUpdateAction != null) 'onUpdateAction': onUpdateAction!,
        if (provisionedIops != null) 'provisionedIops': provisionedIops!,
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
      };
}

/// Specifies the audit configuration for a service.
///
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging. An AuditConfig must have one
/// or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service, the
/// union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
/// { "audit_configs": \[ { "service": "allServices", "audit_log_configs": \[ {
/// "log_type": "DATA_READ", "exempted_members": \[ "user:jose@example.com" \]
/// }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } \] }, {
/// "service": "sampleservice.googleapis.com", "audit_log_configs": \[ {
/// "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members":
/// \[ "user:aliya@example.com" \] } \] } \] }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts jose@example.com from DATA_READ logging, and
/// aliya@example.com from DATA_WRITE logging.
class AuditConfig {
  /// The configuration for logging of each type of permission.
  core.List<AuditLogConfig>? auditLogConfigs;
  core.List<core.String>? exemptedMembers;

  /// Specifies a service that will be enabled for audit logging.
  ///
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  core.String? service;

  AuditConfig();

  AuditConfig.fromJson(core.Map _json) {
    if (_json.containsKey('auditLogConfigs')) {
      auditLogConfigs = (_json['auditLogConfigs'] as core.List)
          .map<AuditLogConfig>((value) => AuditLogConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('exemptedMembers')) {
      exemptedMembers = (_json['exemptedMembers'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (auditLogConfigs != null)
          'auditLogConfigs':
              auditLogConfigs!.map((value) => value.toJson()).toList(),
        if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
        if (service != null) 'service': service!,
      };
}

/// Provides the configuration for logging a type of permissions.
///
/// Example:
///
/// { "audit_log_configs": \[ { "log_type": "DATA_READ", "exempted_members": \[
/// "user:jose@example.com" \] }, { "log_type": "DATA_WRITE" } \] }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
class AuditLogConfig {
  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  ///
  /// Follows the same format of \[Binding.members\]\[\].
  core.List<core.String>? exemptedMembers;
  core.bool? ignoreChildExemptions;

  /// The log type that this config enables.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "LOG_TYPE_UNSPECIFIED"
  core.String? logType;

  AuditLogConfig();

  AuditLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('exemptedMembers')) {
      exemptedMembers = (_json['exemptedMembers'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('ignoreChildExemptions')) {
      ignoreChildExemptions = _json['ignoreChildExemptions'] as core.bool;
    }
    if (_json.containsKey('logType')) {
      logType = _json['logType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (exemptedMembers != null) 'exemptedMembers': exemptedMembers!,
        if (ignoreChildExemptions != null)
          'ignoreChildExemptions': ignoreChildExemptions!,
        if (logType != null) 'logType': logType!,
      };
}

/// Authorization-related information used by Cloud Audit Logging.
class AuthorizationLoggingOptions {
  /// The type of the permission that was checked.
  /// Possible string values are:
  /// - "ADMIN_READ"
  /// - "ADMIN_WRITE"
  /// - "DATA_READ"
  /// - "DATA_WRITE"
  /// - "PERMISSION_TYPE_UNSPECIFIED"
  core.String? permissionType;

  AuthorizationLoggingOptions();

  AuthorizationLoggingOptions.fromJson(core.Map _json) {
    if (_json.containsKey('permissionType')) {
      permissionType = _json['permissionType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissionType != null) 'permissionType': permissionType!,
      };
}

/// Represents an Autoscaler resource.
///
/// Google Compute Engine has two Autoscaler resources:
///
/// * \[Zonal\](/compute/docs/reference/rest/{$api_version}/autoscalers) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionAutoscalers)
///
/// Use autoscalers to automatically add or delete instances from a managed
/// instance group according to your defined autoscaling policy.
///
/// For more information, read Autoscaling Groups of Instances.
///
/// For zonal managed instance groups resource, use the autoscaler resource.
///
/// For regional managed instance groups, use the regionAutoscalers resource.
/// (== resource_for {$api_version}.autoscalers ==) (== resource_for
/// {$api_version}.regionAutoscalers ==)
class Autoscaler {
  /// The configuration parameters for the autoscaling algorithm.
  ///
  /// You can define one or more of the policies for an autoscaler:
  /// cpuUtilization, customMetricUtilizations, and loadBalancingUtilization.
  ///
  /// If none of these are specified, the default will be to autoscale based on
  /// cpuUtilization to 0.6 or 60%.
  AutoscalingPolicy? autoscalingPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#autoscaler for autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Target recommended MIG size (number of instances) computed by autoscaler.
  ///
  /// Autoscaler calculates the recommended MIG size even when the autoscaling
  /// policy mode is different from ON. This field is empty when autoscaler is
  /// not connected to an existing managed instance group or autoscaler did not
  /// generate its prediction.
  ///
  /// Output only.
  core.int? recommendedSize;

  /// URL of the region where the instance group resides (for autoscalers living
  /// in regional scope).
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the autoscaler configuration.
  ///
  /// Current set of possible values:
  /// - PENDING: Autoscaler backend hasn't read new/updated configuration.
  /// - DELETING: Configuration is being deleted.
  /// - ACTIVE: Configuration is acknowledged to be effective. Some warnings
  /// might be present in the statusDetails field.
  /// - ERROR: Configuration has errors. Actionable for users. Details are
  /// present in the statusDetails field. New values might be added in the
  /// future.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETING"
  /// - "ERROR"
  /// - "PENDING"
  core.String? status;

  /// Human-readable details about the current state of the autoscaler.
  ///
  /// Read the documentation for Commonly returned status messages for examples
  /// of status messages you might encounter.
  ///
  /// Output only.
  core.List<AutoscalerStatusDetails>? statusDetails;

  /// URL of the managed instance group that this autoscaler will scale.
  ///
  /// This field is required when creating an autoscaler.
  core.String? target;

  /// URL of the zone where the instance group resides (for autoscalers living
  /// in zonal scope).
  ///
  /// Output only.
  core.String? zone;

  Autoscaler();

  Autoscaler.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalingPolicy')) {
      autoscalingPolicy = AutoscalingPolicy.fromJson(
          _json['autoscalingPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('recommendedSize')) {
      recommendedSize = _json['recommendedSize'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusDetails')) {
      statusDetails = (_json['statusDetails'] as core.List)
          .map<AutoscalerStatusDetails>((value) =>
              AutoscalerStatusDetails.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingPolicy != null)
          'autoscalingPolicy': autoscalingPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (recommendedSize != null) 'recommendedSize': recommendedSize!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (statusDetails != null)
          'statusDetails':
              statusDetails!.map((value) => value.toJson()).toList(),
        if (target != null) 'target': target!,
        if (zone != null) 'zone': zone!,
      };
}

class AutoscalerAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalerAggregatedListWarningData();

  AutoscalerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AutoscalerAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalerAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalerAggregatedListWarning();

  AutoscalerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalerAggregatedListWarningData>((value) =>
              AutoscalerAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AutoscalerAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of AutoscalersScopedList resources.
  core.Map<core.String, AutoscalersScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#autoscalerAggregatedList for aggregated lists of
  /// autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  AutoscalerAggregatedListWarning? warning;

  AutoscalerAggregatedList();

  AutoscalerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          AutoscalersScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalerAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AutoscalerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalerListWarningData();

  AutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class AutoscalerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalerListWarning();

  AutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalerListWarningData>((value) =>
              AutoscalerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Autoscaler resources.
class AutoscalerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler>? items;

  /// Type of resource.
  ///
  /// Always compute#autoscalerList for lists of autoscalers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  AutoscalerListWarning? warning;

  AutoscalerList();

  AutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class AutoscalerStatusDetails {
  /// The status message.
  core.String? message;

  /// The type of error, warning, or notice returned.
  ///
  /// Current set of possible values:
  /// - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group
  /// are unhealthy (not in RUNNING state).
  /// - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
  /// attached to the instance group.
  /// - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size
  /// greater than maxNumReplicas.
  /// - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric
  /// samples are not exported often enough to be a credible base for
  /// autoscaling.
  /// - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does
  /// not exist or does not have the necessary labels.
  /// - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas.
  /// This means the autoscaler cannot add or remove instances from the instance
  /// group.
  /// - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not
  /// receive any data from the custom metric configured for autoscaling.
  /// - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is
  /// configured to scale based on a load balancing signal but the instance
  /// group has not received any requests from the load balancer.
  /// - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances
  /// in the group won't change automatically. The autoscaling configuration is
  /// preserved.
  /// - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode.
  /// The autoscaler can add instances but not remove any.
  /// - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be
  /// autoscaled because it has more than one backend service attached to it.
  /// - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the
  /// necessary resources, such as CPU or number of instances.
  /// - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers:
  /// there is a resource stockout in the chosen region.
  /// - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
  /// exist.
  /// - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling
  /// does not work with an HTTP/S load balancer that has been configured for
  /// maxRate.
  /// - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a
  /// resource stockout in the chosen zone. For regional autoscalers: in at
  /// least one of the zones you're using there is a resource stockout. New
  /// values might be added in the future. Some of the values might not be
  /// available in all API versions.
  /// Possible string values are:
  /// - "ALL_INSTANCES_UNHEALTHY"
  /// - "BACKEND_SERVICE_DOES_NOT_EXIST"
  /// - "CAPPED_AT_MAX_NUM_REPLICAS"
  /// - "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE"
  /// - "CUSTOM_METRIC_INVALID"
  /// - "MIN_EQUALS_MAX"
  /// - "MISSING_CUSTOM_METRIC_DATA_POINTS"
  /// - "MISSING_LOAD_BALANCING_DATA_POINTS"
  /// - "MODE_OFF"
  /// - "MODE_ONLY_SCALE_OUT"
  /// - "MODE_ONLY_UP"
  /// - "MORE_THAN_ONE_BACKEND_SERVICE"
  /// - "NOT_ENOUGH_QUOTA_AVAILABLE"
  /// - "REGION_RESOURCE_STOCKOUT"
  /// - "SCALING_TARGET_DOES_NOT_EXIST"
  /// - "UNKNOWN"
  /// - "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION"
  /// - "ZONE_RESOURCE_STOCKOUT"
  core.String? type;

  AutoscalerStatusDetails();

  AutoscalerStatusDetails.fromJson(core.Map _json) {
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (message != null) 'message': message!,
        if (type != null) 'type': type!,
      };
}

class AutoscalersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  AutoscalersScopedListWarningData();

  AutoscalersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of autoscalers when the list
/// is empty.
///
/// Output only.
class AutoscalersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<AutoscalersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  AutoscalersScopedListWarning();

  AutoscalersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<AutoscalersScopedListWarningData>((value) =>
              AutoscalersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class AutoscalersScopedList {
  /// A list of autoscalers contained in this scope.
  ///
  /// Output only.
  core.List<Autoscaler>? autoscalers;

  /// Informational warning which replaces the list of autoscalers when the list
  /// is empty.
  ///
  /// Output only.
  AutoscalersScopedListWarning? warning;

  AutoscalersScopedList();

  AutoscalersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalers')) {
      autoscalers = (_json['autoscalers'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = AutoscalersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalers != null)
          'autoscalers': autoscalers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Cloud Autoscaler policy.
class AutoscalingPolicy {
  /// The number of seconds that the autoscaler waits before it starts
  /// collecting information from a new instance.
  ///
  /// This prevents the autoscaler from collecting information when the instance
  /// is initializing, during which the collected usage would not be reliable.
  /// The default time autoscaler waits is 60 seconds.
  ///
  /// Virtual machine initialization times might vary because of numerous
  /// factors. We recommend that you test how long an instance may take to
  /// initialize. To do this, create an instance and time the startup process.
  core.int? coolDownPeriodSec;

  /// Defines the CPU utilization policy that allows the autoscaler to scale
  /// based on the average CPU utilization of a managed instance group.
  AutoscalingPolicyCpuUtilization? cpuUtilization;

  /// Configuration parameters of autoscaling based on a custom metric.
  core.List<AutoscalingPolicyCustomMetricUtilization>? customMetricUtilizations;

  /// Configuration parameters of autoscaling based on load balancer.
  AutoscalingPolicyLoadBalancingUtilization? loadBalancingUtilization;

  /// The maximum number of instances that the autoscaler can scale out to.
  ///
  /// This is required when creating or updating an autoscaler. The maximum
  /// number of replicas must not be lower than minimal number of replicas.
  core.int? maxNumReplicas;

  /// The minimum number of replicas that the autoscaler can scale in to.
  ///
  /// This cannot be less than 0. If not provided, autoscaler chooses a default
  /// value depending on maximum number of instances allowed.
  core.int? minNumReplicas;

  /// Defines operating mode for this policy.
  /// Possible string values are:
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_SCALE_OUT"
  /// - "ONLY_UP"
  core.String? mode;
  AutoscalingPolicyScaleInControl? scaleInControl;

  AutoscalingPolicy();

  AutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('coolDownPeriodSec')) {
      coolDownPeriodSec = _json['coolDownPeriodSec'] as core.int;
    }
    if (_json.containsKey('cpuUtilization')) {
      cpuUtilization = AutoscalingPolicyCpuUtilization.fromJson(
          _json['cpuUtilization'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('customMetricUtilizations')) {
      customMetricUtilizations =
          (_json['customMetricUtilizations'] as core.List)
              .map<AutoscalingPolicyCustomMetricUtilization>((value) =>
                  AutoscalingPolicyCustomMetricUtilization.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList();
    }
    if (_json.containsKey('loadBalancingUtilization')) {
      loadBalancingUtilization =
          AutoscalingPolicyLoadBalancingUtilization.fromJson(
              _json['loadBalancingUtilization']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxNumReplicas')) {
      maxNumReplicas = _json['maxNumReplicas'] as core.int;
    }
    if (_json.containsKey('minNumReplicas')) {
      minNumReplicas = _json['minNumReplicas'] as core.int;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('scaleInControl')) {
      scaleInControl = AutoscalingPolicyScaleInControl.fromJson(
          _json['scaleInControl'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (coolDownPeriodSec != null) 'coolDownPeriodSec': coolDownPeriodSec!,
        if (cpuUtilization != null) 'cpuUtilization': cpuUtilization!.toJson(),
        if (customMetricUtilizations != null)
          'customMetricUtilizations':
              customMetricUtilizations!.map((value) => value.toJson()).toList(),
        if (loadBalancingUtilization != null)
          'loadBalancingUtilization': loadBalancingUtilization!.toJson(),
        if (maxNumReplicas != null) 'maxNumReplicas': maxNumReplicas!,
        if (minNumReplicas != null) 'minNumReplicas': minNumReplicas!,
        if (mode != null) 'mode': mode!,
        if (scaleInControl != null) 'scaleInControl': scaleInControl!.toJson(),
      };
}

/// CPU utilization policy.
class AutoscalingPolicyCpuUtilization {
  /// The target CPU utilization that the autoscaler maintains.
  ///
  /// Must be a float value in the range (0, 1\]. If not specified, the default
  /// is 0.6.
  ///
  /// If the CPU level is below the target utilization, the autoscaler scales in
  /// the number of instances until it reaches the minimum number of instances
  /// you specified or until the average CPU of your instances reaches the
  /// target utilization.
  ///
  /// If the average CPU is above the target utilization, the autoscaler scales
  /// out until it reaches the maximum number of instances you specified or
  /// until the average utilization reaches the target utilization.
  core.double? utilizationTarget;

  AutoscalingPolicyCpuUtilization();

  AutoscalingPolicyCpuUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
      };
}

/// Custom utilization metric policy.
class AutoscalingPolicyCustomMetricUtilization {
  /// A filter string, compatible with a Stackdriver Monitoring filter string
  /// for TimeSeries.list API call.
  ///
  /// This filter is used to select a specific TimeSeries for the purpose of
  /// autoscaling and to determine whether the metric is exporting per-instance
  /// or per-group data.
  ///
  /// For the filter to be valid for autoscaling purposes, the following rules
  /// apply:
  /// - You can only use the AND operator for joining selectors.
  /// - You can only use direct equality comparison operator (=) without any
  /// functions for each selector.
  /// - You can specify the metric in both the filter string and in the metric
  /// field. However, if specified in both places, the metric must be identical.
  /// - The monitored resource type determines what kind of values are expected
  /// for the metric. If it is a gce_instance, the autoscaler expects the metric
  /// to include a separate TimeSeries for each instance in a group. In such a
  /// case, you cannot filter on resource labels.
  /// If the resource type is any other value, the autoscaler expects this
  /// metric to contain values that apply to the entire autoscaled instance
  /// group and resource label filtering can be performed to point autoscaler at
  /// the correct TimeSeries to scale upon. This is called a per-group metric
  /// for the purpose of autoscaling.
  ///
  /// If not specified, the type defaults to gce_instance.
  ///
  /// Try to provide a filter that is selective enough to pick just one
  /// TimeSeries for the autoscaled group or for each of the instances (if you
  /// are using gce_instance resource type). If multiple TimeSeries are returned
  /// upon the query execution, the autoscaler will sum their respective values
  /// to obtain its scaling value.
  core.String? filter;

  /// The identifier (type) of the Stackdriver Monitoring metric.
  ///
  /// The metric cannot have negative values.
  ///
  /// The metric must have a value type of INT64 or DOUBLE.
  core.String? metric;

  /// If scaling is based on a per-group metric value that represents the total
  /// amount of work to be done or resource usage, set this value to an amount
  /// assigned for a single instance of the scaled group.
  ///
  /// Autoscaler keeps the number of instances proportional to the value of this
  /// metric. The metric itself does not change value due to group resizing.
  ///
  /// A good metric to use with the target is for example
  /// pubsub.googleapis.com/subscription/num_undelivered_messages or a custom
  /// metric exporting the total number of requests coming to your instances.
  ///
  /// A bad example would be a metric exporting an average or median latency,
  /// since this value can't include a chunk assignable to a single instance, it
  /// could be better used with utilization_target instead.
  core.double? singleInstanceAssignment;

  /// The target value of the metric that autoscaler maintains.
  ///
  /// This must be a positive value. A utilization metric scales number of
  /// virtual machines handling requests to increase or decrease proportionally
  /// to the metric.
  ///
  /// For example, a good metric to use as a utilization_target is
  /// https://www.googleapis.com/compute/v1/instance/network/received_bytes_count.
  /// The autoscaler works to keep this value constant for each of the
  /// instances.
  core.double? utilizationTarget;

  /// Defines how target utilization value is expressed for a Stackdriver
  /// Monitoring metric.
  ///
  /// Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
  /// Possible string values are:
  /// - "DELTA_PER_MINUTE"
  /// - "DELTA_PER_SECOND"
  /// - "GAUGE"
  core.String? utilizationTargetType;

  AutoscalingPolicyCustomMetricUtilization();

  AutoscalingPolicyCustomMetricUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('filter')) {
      filter = _json['filter'] as core.String;
    }
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
    if (_json.containsKey('singleInstanceAssignment')) {
      singleInstanceAssignment =
          (_json['singleInstanceAssignment'] as core.num).toDouble();
    }
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
    if (_json.containsKey('utilizationTargetType')) {
      utilizationTargetType = _json['utilizationTargetType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (metric != null) 'metric': metric!,
        if (singleInstanceAssignment != null)
          'singleInstanceAssignment': singleInstanceAssignment!,
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
        if (utilizationTargetType != null)
          'utilizationTargetType': utilizationTargetType!,
      };
}

/// Configuration parameters of autoscaling based on load balancing.
class AutoscalingPolicyLoadBalancingUtilization {
  /// Fraction of backend capacity utilization (set in HTTP(S) load balancing
  /// configuration) that the autoscaler maintains.
  ///
  /// Must be a positive float value. If not defined, the default is 0.8.
  core.double? utilizationTarget;

  AutoscalingPolicyLoadBalancingUtilization();

  AutoscalingPolicyLoadBalancingUtilization.fromJson(core.Map _json) {
    if (_json.containsKey('utilizationTarget')) {
      utilizationTarget = (_json['utilizationTarget'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (utilizationTarget != null) 'utilizationTarget': utilizationTarget!,
      };
}

/// Configuration that allows for slower scale in so that even if Autoscaler
/// recommends an abrupt scale in of a MIG, it will be throttled as specified by
/// the parameters below.
class AutoscalingPolicyScaleInControl {
  /// Maximum allowed number (or %) of VMs that can be deducted from the peak
  /// recommendation during the window autoscaler looks at when computing
  /// recommendations.
  ///
  /// Possibly all these VMs can be deleted at once so user service needs to be
  /// prepared to lose that many VMs in one step.
  FixedOrPercent? maxScaledInReplicas;

  /// How far back autoscaling looks when computing recommendations to include
  /// directives regarding slower scale in, as described above.
  core.int? timeWindowSec;

  AutoscalingPolicyScaleInControl();

  AutoscalingPolicyScaleInControl.fromJson(core.Map _json) {
    if (_json.containsKey('maxScaledInReplicas')) {
      maxScaledInReplicas = FixedOrPercent.fromJson(
          _json['maxScaledInReplicas'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeWindowSec')) {
      timeWindowSec = _json['timeWindowSec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxScaledInReplicas != null)
          'maxScaledInReplicas': maxScaledInReplicas!.toJson(),
        if (timeWindowSec != null) 'timeWindowSec': timeWindowSec!,
      };
}

/// Message containing information of one individual backend.
class Backend {
  /// Specifies how to determine whether the backend of a load balancer can
  /// handle additional traffic or is fully loaded.
  ///
  /// For usage guidelines, see  Connection balancing mode.
  /// Possible string values are:
  /// - "CONNECTION"
  /// - "RATE"
  /// - "UTILIZATION"
  core.String? balancingMode;

  /// A multiplier applied to the backend's target capacity of its balancing
  /// mode.
  ///
  /// The default value is 1, which means the group serves up to 100% of its
  /// configured capacity (depending on balancingMode). A setting of 0 means the
  /// group is completely drained, offering 0% of its available capacity. The
  /// valid ranges are 0.0 and \[0.1,1.0\]. You cannot configure a setting
  /// larger than 0 and smaller than 0.1. You cannot configure a setting of 0
  /// when there is only one backend attached to the backend service.
  ///
  /// Not supported by:
  ///
  /// - Internal TCP/UDP Load Balancing - Network Load Balancing
  core.double? capacityScaler;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// This field designates whether this is a failover backend.
  ///
  /// More than one failover backend can be configured for a given
  /// BackendService.
  core.bool? failover;

  /// The fully-qualified URL of an instance group or network endpoint group
  /// (NEG) resource.
  ///
  /// The type of backend that a backend service supports depends on the backend
  /// service's loadBalancingScheme.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is EXTERNAL (except
  /// Network Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the
  /// backend can be either an instance group or a NEG. The backends on the
  /// backend service must be either all instance groups or all NEGs. You cannot
  /// mix instance group and NEG backends on the same backend service.
  ///
  ///
  /// - When the loadBalancingScheme for the backend service is EXTERNAL for
  /// Network Load Balancing or INTERNAL for Internal TCP/UDP Load Balancing,
  /// the backend must be an instance group. NEGs are not supported.
  ///
  /// For regional services, the backend must be in the same region as the
  /// backend service.
  ///
  /// You must use the fully-qualified URL (starting with
  /// https://www.googleapis.com/) to specify the instance group or NEG. Partial
  /// URLs are not supported.
  core.String? group;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode. Not available if the backend's balancingMode is RATE. Not
  /// supported by:
  ///
  /// - Internal TCP/UDP Load Balancing - Network Load Balancing
  core.int? maxConnections;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode.
  ///
  /// Not available if the backend's balancingMode is RATE. Not supported by:
  ///
  /// - Internal TCP/UDP Load Balancing - Network Load Balancing.
  core.int? maxConnectionsPerEndpoint;

  /// Defines a target maximum number of simultaneous connections.
  ///
  /// For usage guidelines, see Connection balancing mode and Utilization
  /// balancing mode.
  ///
  /// Not available if the backend's balancingMode is RATE. Not supported by:
  ///
  /// - Internal TCP/UDP Load Balancing - Network Load Balancing.
  core.int? maxConnectionsPerInstance;

  /// Defines a maximum number of HTTP requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.int? maxRate;

  /// Defines a maximum target for requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double? maxRatePerEndpoint;

  /// Defines a maximum target for requests per second (RPS).
  ///
  /// For usage guidelines, see Rate balancing mode and Utilization balancing
  /// mode.
  ///
  /// Not available if the backend's balancingMode is CONNECTION.
  core.double? maxRatePerInstance;
  core.double? maxUtilization;

  Backend();

  Backend.fromJson(core.Map _json) {
    if (_json.containsKey('balancingMode')) {
      balancingMode = _json['balancingMode'] as core.String;
    }
    if (_json.containsKey('capacityScaler')) {
      capacityScaler = (_json['capacityScaler'] as core.num).toDouble();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('failover')) {
      failover = _json['failover'] as core.bool;
    }
    if (_json.containsKey('group')) {
      group = _json['group'] as core.String;
    }
    if (_json.containsKey('maxConnections')) {
      maxConnections = _json['maxConnections'] as core.int;
    }
    if (_json.containsKey('maxConnectionsPerEndpoint')) {
      maxConnectionsPerEndpoint =
          _json['maxConnectionsPerEndpoint'] as core.int;
    }
    if (_json.containsKey('maxConnectionsPerInstance')) {
      maxConnectionsPerInstance =
          _json['maxConnectionsPerInstance'] as core.int;
    }
    if (_json.containsKey('maxRate')) {
      maxRate = _json['maxRate'] as core.int;
    }
    if (_json.containsKey('maxRatePerEndpoint')) {
      maxRatePerEndpoint = (_json['maxRatePerEndpoint'] as core.num).toDouble();
    }
    if (_json.containsKey('maxRatePerInstance')) {
      maxRatePerInstance = (_json['maxRatePerInstance'] as core.num).toDouble();
    }
    if (_json.containsKey('maxUtilization')) {
      maxUtilization = (_json['maxUtilization'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (balancingMode != null) 'balancingMode': balancingMode!,
        if (capacityScaler != null) 'capacityScaler': capacityScaler!,
        if (description != null) 'description': description!,
        if (failover != null) 'failover': failover!,
        if (group != null) 'group': group!,
        if (maxConnections != null) 'maxConnections': maxConnections!,
        if (maxConnectionsPerEndpoint != null)
          'maxConnectionsPerEndpoint': maxConnectionsPerEndpoint!,
        if (maxConnectionsPerInstance != null)
          'maxConnectionsPerInstance': maxConnectionsPerInstance!,
        if (maxRate != null) 'maxRate': maxRate!,
        if (maxRatePerEndpoint != null)
          'maxRatePerEndpoint': maxRatePerEndpoint!,
        if (maxRatePerInstance != null)
          'maxRatePerInstance': maxRatePerInstance!,
        if (maxUtilization != null) 'maxUtilization': maxUtilization!,
      };
}

/// Represents a Cloud Storage Bucket resource.
///
/// This Cloud Storage bucket resource is referenced by a URL map of a load
/// balancer.
///
/// For more information, read Backend Buckets.
class BackendBucket {
  /// Cloud Storage bucket name.
  core.String? bucketName;

  /// Cloud CDN configuration for this BackendBucket.
  BackendBucketCdnPolicy? cdnPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Headers that the HTTP/S load balancer should add to proxied responses.
  core.List<core.String>? customResponseHeaders;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String? description;

  /// If true, enable Cloud CDN for this BackendBucket.
  core.bool? enableCdn;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  BackendBucket();

  BackendBucket.fromJson(core.Map _json) {
    if (_json.containsKey('bucketName')) {
      bucketName = _json['bucketName'] as core.String;
    }
    if (_json.containsKey('cdnPolicy')) {
      cdnPolicy = BackendBucketCdnPolicy.fromJson(
          _json['cdnPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customResponseHeaders')) {
      customResponseHeaders = (_json['customResponseHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableCdn')) {
      enableCdn = _json['enableCdn'] as core.bool;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bucketName != null) 'bucketName': bucketName!,
        if (cdnPolicy != null) 'cdnPolicy': cdnPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customResponseHeaders != null)
          'customResponseHeaders': customResponseHeaders!,
        if (description != null) 'description': description!,
        if (enableCdn != null) 'enableCdn': enableCdn!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Message containing Cloud CDN configuration for a backend bucket.
class BackendBucketCdnPolicy {
  /// Specifies the cache setting for all responses from this backend.
  ///
  /// The possible values are:
  ///
  /// USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to
  /// cache content. Responses without these headers will not be cached at
  /// Google's edge, and will require a full trip to the origin on every
  /// request, potentially impacting performance and increasing load on the
  /// origin server.
  ///
  /// FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or
  /// "no-cache" directives in Cache-Control response headers. Warning: this may
  /// result in Cloud CDN caching private, per-user (user identifiable) content.
  ///
  /// CACHE_ALL_STATIC Automatically cache static content, including common
  /// image formats, media (video and audio), and web assets (JavaScript and
  /// CSS). Requests and responses that are marked as uncacheable, as well as
  /// dynamic content (including HTML), will not be cached.
  /// Possible string values are:
  /// - "CACHE_ALL_STATIC"
  /// - "FORCE_CACHE_ALL"
  /// - "INVALID_CACHE_MODE"
  /// - "USE_ORIGIN_HEADERS"
  core.String? cacheMode;

  /// Specifies a separate client (e.g. browser client) maximum TTL.
  ///
  /// This is used to clamp the max-age (or Expires) value sent to the client.
  /// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
  /// the response max-age directive, along with a "public" directive. For
  /// cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age
  /// from the origin (if specified), or else sets the response max-age
  /// directive to the lesser of the client_ttl and default_ttl, and also
  /// ensures a "public" cache-control directive is present. If a client TTL is
  /// not specified, a default value (1 hour) will be used. The maximum allowed
  /// value is 86400s (1 day).
  core.int? clientTtl;

  /// Specifies the default TTL for cached content served by this origin for
  /// responses that do not have an existing valid TTL (max-age or s-max-age).
  ///
  /// Setting a TTL of "0" means "always revalidate". The value of defaultTTL
  /// cannot be set to a value greater than that of maxTTL, but can be equal.
  /// When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will
  /// overwrite the TTL set in all responses. The maximum allowed value is
  /// 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? defaultTtl;

  /// Specifies the maximum allowed TTL for cached content served by this
  /// origin.
  ///
  /// Cache directives that attempt to set a max-age or s-maxage higher than
  /// this, or an Expires header more than maxTTL seconds in the future will be
  /// capped at the value of maxTTL, as if it were the value of an s-maxage
  /// Cache-Control directive. Headers sent to the client will not be modified.
  /// Setting a TTL of "0" means "always revalidate". The maximum allowed value
  /// is 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? maxTtl;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh.
  ///
  /// After this time period, the response will be revalidated before being
  /// served. Defaults to 1hr (3600s). When serving responses to signed URL
  /// requests, Cloud CDN will internally behave as though all responses from
  /// this backend had a "Cache-Control: public, max-age=\[TTL\]" header,
  /// regardless of any existing Cache-Control header. The actual headers served
  /// in responses will not be altered.
  core.String? signedUrlCacheMaxAgeSec;

  /// Names of the keys for signing request URLs.
  ///
  /// Output only.
  core.List<core.String>? signedUrlKeyNames;

  BackendBucketCdnPolicy();

  BackendBucketCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('cacheMode')) {
      cacheMode = _json['cacheMode'] as core.String;
    }
    if (_json.containsKey('clientTtl')) {
      clientTtl = _json['clientTtl'] as core.int;
    }
    if (_json.containsKey('defaultTtl')) {
      defaultTtl = _json['defaultTtl'] as core.int;
    }
    if (_json.containsKey('maxTtl')) {
      maxTtl = _json['maxTtl'] as core.int;
    }
    if (_json.containsKey('signedUrlCacheMaxAgeSec')) {
      signedUrlCacheMaxAgeSec = _json['signedUrlCacheMaxAgeSec'] as core.String;
    }
    if (_json.containsKey('signedUrlKeyNames')) {
      signedUrlKeyNames = (_json['signedUrlKeyNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (cacheMode != null) 'cacheMode': cacheMode!,
        if (clientTtl != null) 'clientTtl': clientTtl!,
        if (defaultTtl != null) 'defaultTtl': defaultTtl!,
        if (maxTtl != null) 'maxTtl': maxTtl!,
        if (signedUrlCacheMaxAgeSec != null)
          'signedUrlCacheMaxAgeSec': signedUrlCacheMaxAgeSec!,
        if (signedUrlKeyNames != null) 'signedUrlKeyNames': signedUrlKeyNames!,
      };
}

class BackendBucketListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendBucketListWarningData();

  BackendBucketListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendBucketListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendBucketListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendBucketListWarning();

  BackendBucketListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendBucketListWarningData>((value) =>
              BackendBucketListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendBucket resources.
class BackendBucketList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendBucket resources.
  core.List<BackendBucket>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  BackendBucketListWarning? warning;

  BackendBucketList();

  BackendBucketList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<BackendBucket>((value) => BackendBucket.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = BackendBucketListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Backend Service resource.
///
/// A backend service defines how Google Cloud load balancers distribute
/// traffic.
///
/// The backend service configuration contains a set of values, such as the
/// protocol used to connect to backends, various distribution and session
/// settings, health checks, and timeouts. These settings provide fine-grained
/// control over how your load balancer behaves. Most of the settings have
/// default values that allow for easy configuration if you need to get started
/// quickly.
///
/// Backend services in Google Compute Engine can be either regionally or
/// globally scoped.
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/backendServices) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionBackendServices)
///
/// For more information, see Backend Services.
///
/// (== resource_for {$api_version}.backendService ==)
class BackendService {
  /// Lifetime of cookies in seconds.
  ///
  /// Only applicable if the loadBalancingScheme is EXTERNAL,
  /// INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, the protocol is HTTP or HTTPS,
  /// and the sessionAffinity is GENERATED_COOKIE, or HTTP_COOKIE.
  ///
  /// If set to 0, the cookie is non-persistent and lasts only until the end of
  /// the browser session (or equivalent). The maximum allowed value is one day
  /// (86,400).
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  core.int? affinityCookieTtlSec;

  /// The list of backends that serve this BackendService.
  core.List<Backend>? backends;

  /// Cloud CDN configuration for this BackendService.
  ///
  /// Only available for  external HTTP(S) Load Balancing.
  BackendServiceCdnPolicy? cdnPolicy;

  /// Settings controlling the volume of connections to a backend service.
  ///
  /// If not set, this feature is considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  CircuitBreakers? circuitBreakers;
  ConnectionDraining? connectionDraining;

  /// Consistent Hash-based load balancing can be used to provide soft session
  /// affinity based on HTTP headers, cookies or other properties.
  ///
  /// This load balancing policy is applicable only for HTTP connections. The
  /// affinity to a particular destination host will be lost when one or more
  /// hosts are added/removed from the destination service. This field specifies
  /// parameters that control consistent hashing. This field is only applicable
  /// when localityLbPolicy is set to MAGLEV or RING_HASH.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  ConsistentHashLoadBalancerSettings? consistentHash;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Headers that the HTTP/S load balancer should add to proxied requests.
  core.List<core.String>? customRequestHeaders;

  /// Headers that the HTTP/S load balancer should add to proxied responses.
  core.List<core.String>? customResponseHeaders;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// If true, enables Cloud CDN for the backend service.
  ///
  /// Only applicable if the loadBalancingScheme is EXTERNAL and the protocol is
  /// HTTP or HTTPS.
  core.bool? enableCDN;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing and
  /// Network Load Balancing.
  ///
  /// Requires at least one backend instance group to be defined as a backup
  /// (failover) backend.
  BackendServiceFailoverPolicy? failoverPolicy;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// BackendService. An up-to-date fingerprint must be provided in order to
  /// update the BackendService, otherwise the request will fail with error 412
  /// conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// BackendService.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of URLs to the healthChecks, httpHealthChecks (legacy), or
  /// httpsHealthChecks (legacy) resource for health checking this backend
  /// service.
  ///
  /// Not all backend services support legacy health checks. See Load balancer
  /// guide. Currently, at most one health check can be specified for each
  /// backend service. Backend services with instance group or zonal NEG
  /// backends must have a health check. Backend services with internet or
  /// serverless NEG backends must not have a health check.
  core.List<core.String>? healthChecks;

  /// The configurations for Identity-Aware Proxy on this resource.
  ///
  /// Not available for Internal TCP/UDP Load Balancing and Network Load
  /// Balancing.
  BackendServiceIAP? iap;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#backendService for backend services.
  ///
  /// Output only.
  core.String? kind;

  /// Specifies the load balancer type.
  ///
  /// Choose EXTERNAL for external HTTP(S), SSL Proxy, TCP Proxy and Network
  /// Load Balancing. Choose INTERNAL for Internal TCP/UDP Load Balancing.
  /// Choose INTERNAL_MANAGED for Internal HTTP(S) Load Balancing.
  /// INTERNAL_SELF_MANAGED for Traffic Director. A backend service created for
  /// one type of load balancer cannot be used with another. For more
  /// information, refer to Choosing a load balancer.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID_LOAD_BALANCING_SCHEME"
  core.String? loadBalancingScheme;

  /// The load balancing algorithm used within the scope of the locality.
  ///
  /// The possible values are:
  /// - ROUND_ROBIN: This is a simple policy in which each healthy backend is
  /// selected in round robin order. This is the default.
  /// - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts
  /// and picks the host which has fewer active requests.
  /// - RING_HASH: The ring/modulo hash load balancer implements consistent
  /// hashing to backends. The algorithm has the property that the
  /// addition/removal of a host from a set of N hosts only affects 1/N of the
  /// requests.
  /// - RANDOM: The load balancer selects a random healthy host.
  /// - ORIGINAL_DESTINATION: Backend host is selected based on the client
  /// connection metadata, i.e., connections are opened to the same address as
  /// the destination address of the incoming connection before the connection
  /// was redirected to the load balancer.
  /// - MAGLEV: used as a drop in replacement for the ring hash load balancer.
  /// Maglev is not as stable as ring hash but has faster table lookup build
  /// times and host selection times. For more information about Maglev, see
  /// https://ai.google/research/pubs/pub44824
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// If sessionAffinity is not NONE, and this field is not set to MAGLEV or
  /// RING_HASH, session affinity settings will not take effect.
  ///
  /// Only the default ROUND_ROBIN policy is supported when the backend service
  /// is referenced by a URL map that is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  /// Possible string values are:
  /// - "INVALID_LB_POLICY"
  /// - "LEAST_REQUEST"
  /// - "MAGLEV"
  /// - "ORIGINAL_DESTINATION"
  /// - "RANDOM"
  /// - "RING_HASH"
  /// - "ROUND_ROBIN"
  core.String? localityLbPolicy;

  /// This field denotes the logging options for the load balancer traffic
  /// served by this backend service.
  ///
  /// If logging is enabled, logs will be exported to Stackdriver.
  BackendServiceLogConfig? logConfig;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The URL of the network to which this backend service belongs.
  ///
  /// This field can only be specified when the load balancing scheme is set to
  /// INTERNAL.
  core.String? network;

  /// Settings controlling the eviction of unhealthy hosts from the load
  /// balancing pool for the backend service.
  ///
  /// If not set, this feature is considered disabled.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  OutlierDetection? outlierDetection;

  /// Deprecated in favor of portName.
  ///
  /// The TCP port to connect on the backend. The default value is 80.
  ///
  /// Backend services for Internal TCP/UDP Load Balancing and Network Load
  /// Balancing require you omit port.
  core.int? port;

  /// A named port on a backend instance group representing the port for
  /// communication to the backend VMs in that group.
  ///
  /// Required when the loadBalancingScheme is EXTERNAL (except Network Load
  /// Balancing), INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED and the backends
  /// are instance groups. The named port must be defined on each backend
  /// instance group. This parameter has no meaning if the backends are NEGs.
  ///
  ///
  ///
  /// Backend services for Internal TCP/UDP Load Balancing and Network Load
  /// Balancing require you omit port_name.
  core.String? portName;

  /// The protocol this BackendService uses to communicate with backends.
  ///
  /// Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC.
  ///
  /// depending on the chosen load balancer or Traffic Director configuration.
  /// Refer to the documentation for the load balancer or for Traffic Director
  /// for more information.
  ///
  /// Must be set to GRPC when the backend service is referenced by a URL map
  /// that is bound to target gRPC proxy.
  /// Possible string values are:
  /// - "GRPC"
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "SSL"
  /// - "TCP"
  /// - "UDP"
  core.String? protocol;

  /// URL of the region where the regional backend service resides.
  ///
  /// This field is not applicable to global backend services. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  ///
  /// Output only.
  core.String? region;

  /// The resource URL for the security policy associated with this backend
  /// service.
  ///
  /// Output only.
  core.String? securityPolicy;

  /// This field specifies the security policy that applies to this backend
  /// service.
  ///
  /// This field is applicable to either:
  /// - A regional backend service with the service_protocol set to HTTP, HTTPS,
  /// or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED.
  /// - A global backend service with the load_balancing_scheme set to
  /// INTERNAL_SELF_MANAGED.
  SecuritySettings? securitySettings;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Type of session affinity to use.
  ///
  /// The default is NONE.
  ///
  /// When the loadBalancingScheme is EXTERNAL: * For Network Load Balancing,
  /// the possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or
  /// CLIENT_IP_PORT_PROTO. * For all other load balancers that use
  /// loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP, or
  /// GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is HTTP,
  /// HTTP2, or HTTPS.
  ///
  /// When the loadBalancingScheme is INTERNAL, possible values are NONE,
  /// CLIENT_IP, CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
  ///
  /// When the loadBalancingScheme is INTERNAL_SELF_MANAGED, or
  /// INTERNAL_MANAGED, possible values are NONE, CLIENT_IP, GENERATED_COOKIE,
  /// HEADER_FIELD, or HTTP_COOKIE.
  ///
  /// Not supported when the backend service is referenced by a URL map that is
  /// bound to target gRPC proxy that has validateForProxyless field set to
  /// true.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String? sessionAffinity;

  /// The backend service timeout has a different meaning depending on the type
  /// of load balancer.
  ///
  /// For more information see, Backend service settings The default is 30
  /// seconds. The full range of timeout values allowed is 1 - 2,147,483,647
  /// seconds.
  core.int? timeoutSec;

  BackendService();

  BackendService.fromJson(core.Map _json) {
    if (_json.containsKey('affinityCookieTtlSec')) {
      affinityCookieTtlSec = _json['affinityCookieTtlSec'] as core.int;
    }
    if (_json.containsKey('backends')) {
      backends = (_json['backends'] as core.List)
          .map<Backend>((value) =>
              Backend.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('cdnPolicy')) {
      cdnPolicy = BackendServiceCdnPolicy.fromJson(
          _json['cdnPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('circuitBreakers')) {
      circuitBreakers = CircuitBreakers.fromJson(
          _json['circuitBreakers'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('connectionDraining')) {
      connectionDraining = ConnectionDraining.fromJson(
          _json['connectionDraining'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('consistentHash')) {
      consistentHash = ConsistentHashLoadBalancerSettings.fromJson(
          _json['consistentHash'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customRequestHeaders')) {
      customRequestHeaders = (_json['customRequestHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('customResponseHeaders')) {
      customResponseHeaders = (_json['customResponseHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableCDN')) {
      enableCDN = _json['enableCDN'] as core.bool;
    }
    if (_json.containsKey('failoverPolicy')) {
      failoverPolicy = BackendServiceFailoverPolicy.fromJson(
          _json['failoverPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('iap')) {
      iap = BackendServiceIAP.fromJson(
          _json['iap'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('loadBalancingScheme')) {
      loadBalancingScheme = _json['loadBalancingScheme'] as core.String;
    }
    if (_json.containsKey('localityLbPolicy')) {
      localityLbPolicy = _json['localityLbPolicy'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = BackendServiceLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('outlierDetection')) {
      outlierDetection = OutlierDetection.fromJson(
          _json['outlierDetection'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('protocol')) {
      protocol = _json['protocol'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('securityPolicy')) {
      securityPolicy = _json['securityPolicy'] as core.String;
    }
    if (_json.containsKey('securitySettings')) {
      securitySettings = SecuritySettings.fromJson(
          _json['securitySettings'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sessionAffinity')) {
      sessionAffinity = _json['sessionAffinity'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (affinityCookieTtlSec != null)
          'affinityCookieTtlSec': affinityCookieTtlSec!,
        if (backends != null)
          'backends': backends!.map((value) => value.toJson()).toList(),
        if (cdnPolicy != null) 'cdnPolicy': cdnPolicy!.toJson(),
        if (circuitBreakers != null)
          'circuitBreakers': circuitBreakers!.toJson(),
        if (connectionDraining != null)
          'connectionDraining': connectionDraining!.toJson(),
        if (consistentHash != null) 'consistentHash': consistentHash!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customRequestHeaders != null)
          'customRequestHeaders': customRequestHeaders!,
        if (customResponseHeaders != null)
          'customResponseHeaders': customResponseHeaders!,
        if (description != null) 'description': description!,
        if (enableCDN != null) 'enableCDN': enableCDN!,
        if (failoverPolicy != null) 'failoverPolicy': failoverPolicy!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (iap != null) 'iap': iap!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (loadBalancingScheme != null)
          'loadBalancingScheme': loadBalancingScheme!,
        if (localityLbPolicy != null) 'localityLbPolicy': localityLbPolicy!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (outlierDetection != null)
          'outlierDetection': outlierDetection!.toJson(),
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (protocol != null) 'protocol': protocol!,
        if (region != null) 'region': region!,
        if (securityPolicy != null) 'securityPolicy': securityPolicy!,
        if (securitySettings != null)
          'securitySettings': securitySettings!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
      };
}

class BackendServiceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServiceAggregatedListWarningData();

  BackendServiceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendServiceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServiceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServiceAggregatedListWarning();

  BackendServiceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServiceAggregatedListWarningData>((value) =>
              BackendServiceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendServicesScopedList.
class BackendServiceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendServicesScopedList resources.
  core.Map<core.String, BackendServicesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  BackendServiceAggregatedListWarning? warning;

  BackendServiceAggregatedList();

  BackendServiceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          BackendServicesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = BackendServiceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Message containing Cloud CDN configuration for a backend service.
class BackendServiceCdnPolicy {
  /// The CacheKeyPolicy for this CdnPolicy.
  CacheKeyPolicy? cacheKeyPolicy;

  /// Specifies the cache setting for all responses from this backend.
  ///
  /// The possible values are:
  ///
  /// USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to
  /// cache content. Responses without these headers will not be cached at
  /// Google's edge, and will require a full trip to the origin on every
  /// request, potentially impacting performance and increasing load on the
  /// origin server.
  ///
  /// FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or
  /// "no-cache" directives in Cache-Control response headers. Warning: this may
  /// result in Cloud CDN caching private, per-user (user identifiable) content.
  ///
  /// CACHE_ALL_STATIC Automatically cache static content, including common
  /// image formats, media (video and audio), and web assets (JavaScript and
  /// CSS). Requests and responses that are marked as uncacheable, as well as
  /// dynamic content (including HTML), will not be cached.
  /// Possible string values are:
  /// - "CACHE_ALL_STATIC"
  /// - "FORCE_CACHE_ALL"
  /// - "INVALID_CACHE_MODE"
  /// - "USE_ORIGIN_HEADERS"
  core.String? cacheMode;

  /// Specifies a separate client (e.g. browser client) maximum TTL.
  ///
  /// This is used to clamp the max-age (or Expires) value sent to the client.
  /// With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
  /// the response max-age directive, along with a "public" directive. For
  /// cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age
  /// from the origin (if specified), or else sets the response max-age
  /// directive to the lesser of the client_ttl and default_ttl, and also
  /// ensures a "public" cache-control directive is present. If a client TTL is
  /// not specified, a default value (1 hour) will be used. The maximum allowed
  /// value is 86400s (1 day).
  core.int? clientTtl;

  /// Specifies the default TTL for cached content served by this origin for
  /// responses that do not have an existing valid TTL (max-age or s-max-age).
  ///
  /// Setting a TTL of "0" means "always revalidate". The value of defaultTTL
  /// cannot be set to a value greater than that of maxTTL, but can be equal.
  /// When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will
  /// overwrite the TTL set in all responses. The maximum allowed value is
  /// 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? defaultTtl;

  /// Specifies the maximum allowed TTL for cached content served by this
  /// origin.
  ///
  /// Cache directives that attempt to set a max-age or s-maxage higher than
  /// this, or an Expires header more than maxTTL seconds in the future will be
  /// capped at the value of maxTTL, as if it were the value of an s-maxage
  /// Cache-Control directive. Headers sent to the client will not be modified.
  /// Setting a TTL of "0" means "always revalidate". The maximum allowed value
  /// is 31,622,400s (1 year), noting that infrequently accessed objects may be
  /// evicted from the cache before the defined TTL.
  core.int? maxTtl;

  /// Maximum number of seconds the response to a signed URL request will be
  /// considered fresh.
  ///
  /// After this time period, the response will be revalidated before being
  /// served. Defaults to 1hr (3600s). When serving responses to signed URL
  /// requests, Cloud CDN will internally behave as though all responses from
  /// this backend had a "Cache-Control: public, max-age=\[TTL\]" header,
  /// regardless of any existing Cache-Control header. The actual headers served
  /// in responses will not be altered.
  core.String? signedUrlCacheMaxAgeSec;

  /// Names of the keys for signing request URLs.
  ///
  /// Output only.
  core.List<core.String>? signedUrlKeyNames;

  BackendServiceCdnPolicy();

  BackendServiceCdnPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('cacheKeyPolicy')) {
      cacheKeyPolicy = CacheKeyPolicy.fromJson(
          _json['cacheKeyPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cacheMode')) {
      cacheMode = _json['cacheMode'] as core.String;
    }
    if (_json.containsKey('clientTtl')) {
      clientTtl = _json['clientTtl'] as core.int;
    }
    if (_json.containsKey('defaultTtl')) {
      defaultTtl = _json['defaultTtl'] as core.int;
    }
    if (_json.containsKey('maxTtl')) {
      maxTtl = _json['maxTtl'] as core.int;
    }
    if (_json.containsKey('signedUrlCacheMaxAgeSec')) {
      signedUrlCacheMaxAgeSec = _json['signedUrlCacheMaxAgeSec'] as core.String;
    }
    if (_json.containsKey('signedUrlKeyNames')) {
      signedUrlKeyNames = (_json['signedUrlKeyNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (cacheKeyPolicy != null) 'cacheKeyPolicy': cacheKeyPolicy!.toJson(),
        if (cacheMode != null) 'cacheMode': cacheMode!,
        if (clientTtl != null) 'clientTtl': clientTtl!,
        if (defaultTtl != null) 'defaultTtl': defaultTtl!,
        if (maxTtl != null) 'maxTtl': maxTtl!,
        if (signedUrlCacheMaxAgeSec != null)
          'signedUrlCacheMaxAgeSec': signedUrlCacheMaxAgeSec!,
        if (signedUrlKeyNames != null) 'signedUrlKeyNames': signedUrlKeyNames!,
      };
}

/// Applicable only to Failover for Internal TCP/UDP Load Balancing and Network
/// Load Balancing.
///
/// On failover or failback, this field indicates whether connection draining
/// will be honored. GCP has a fixed connection draining timeout of 10 minutes.
/// A setting of true terminates existing TCP connections to the active pool
/// during failover and failback, immediately draining traffic. A setting of
/// false allows existing TCP connections to persist, even on VMs no longer in
/// the active pool, for up to the duration of the connection draining timeout
/// (10 minutes).
class BackendServiceFailoverPolicy {
  /// This can be set to true only if the protocol is TCP.
  ///
  /// The default is false.
  core.bool? disableConnectionDrainOnFailover;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing and
  /// Network Load Balancing, If set to true, connections to the load balancer
  /// are dropped when all primary and all backup backend VMs are unhealthy.If
  /// set to false, connections are distributed among all primary VMs when all
  /// primary and all backup backend VMs are unhealthy.
  ///
  /// The default is false.
  core.bool? dropTrafficIfUnhealthy;

  /// Applicable only to Failover for Internal TCP/UDP Load Balancing and
  /// Network Load Balancing.
  ///
  /// The value of the field must be in the range \[0, 1\]. If the value is 0,
  /// the load balancer performs a failover when the number of healthy primary
  /// VMs equals zero. For all other values, the load balancer performs a
  /// failover when the total number of healthy primary VMs is less than this
  /// ratio.
  core.double? failoverRatio;

  BackendServiceFailoverPolicy();

  BackendServiceFailoverPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('disableConnectionDrainOnFailover')) {
      disableConnectionDrainOnFailover =
          _json['disableConnectionDrainOnFailover'] as core.bool;
    }
    if (_json.containsKey('dropTrafficIfUnhealthy')) {
      dropTrafficIfUnhealthy = _json['dropTrafficIfUnhealthy'] as core.bool;
    }
    if (_json.containsKey('failoverRatio')) {
      failoverRatio = (_json['failoverRatio'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableConnectionDrainOnFailover != null)
          'disableConnectionDrainOnFailover': disableConnectionDrainOnFailover!,
        if (dropTrafficIfUnhealthy != null)
          'dropTrafficIfUnhealthy': dropTrafficIfUnhealthy!,
        if (failoverRatio != null) 'failoverRatio': failoverRatio!,
      };
}

class BackendServiceGroupHealth {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String>? annotations;

  /// Health state of the backend instances or endpoints in requested instance
  /// or network endpoint group, determined based on configured health checks.
  core.List<HealthStatus>? healthStatus;

  /// Type of resource.
  ///
  /// Always compute#backendServiceGroupHealth for the health of backend
  /// services.
  ///
  /// Output only.
  core.String? kind;

  BackendServiceGroupHealth();

  BackendServiceGroupHealth.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations =
          (_json['annotations'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('healthStatus')) {
      healthStatus = (_json['healthStatus'] as core.List)
          .map<HealthStatus>((value) => HealthStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (healthStatus != null)
          'healthStatus': healthStatus!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Identity-Aware Proxy
class BackendServiceIAP {
  /// Whether the serving infrastructure will authenticate and authorize all
  /// incoming requests.
  ///
  /// If true, the oauth2ClientId and oauth2ClientSecret fields must be
  /// non-empty.
  core.bool? enabled;

  /// OAuth2 client ID to use for the authentication flow.
  core.String? oauth2ClientId;

  /// OAuth2 client secret to use for the authentication flow.
  ///
  /// For security reasons, this value cannot be retrieved via the API. Instead,
  /// the SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
  /// field.
  core.String? oauth2ClientSecret;

  /// SHA256 hash value for the field oauth2_client_secret above.
  ///
  /// Output only.
  core.String? oauth2ClientSecretSha256;

  BackendServiceIAP();

  BackendServiceIAP.fromJson(core.Map _json) {
    if (_json.containsKey('enabled')) {
      enabled = _json['enabled'] as core.bool;
    }
    if (_json.containsKey('oauth2ClientId')) {
      oauth2ClientId = _json['oauth2ClientId'] as core.String;
    }
    if (_json.containsKey('oauth2ClientSecret')) {
      oauth2ClientSecret = _json['oauth2ClientSecret'] as core.String;
    }
    if (_json.containsKey('oauth2ClientSecretSha256')) {
      oauth2ClientSecretSha256 =
          _json['oauth2ClientSecretSha256'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enabled != null) 'enabled': enabled!,
        if (oauth2ClientId != null) 'oauth2ClientId': oauth2ClientId!,
        if (oauth2ClientSecret != null)
          'oauth2ClientSecret': oauth2ClientSecret!,
        if (oauth2ClientSecretSha256 != null)
          'oauth2ClientSecretSha256': oauth2ClientSecretSha256!,
      };
}

class BackendServiceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServiceListWarningData();

  BackendServiceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class BackendServiceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServiceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServiceListWarning();

  BackendServiceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServiceListWarningData>((value) =>
              BackendServiceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of BackendService resources.
class BackendServiceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of BackendService resources.
  core.List<BackendService>? items;

  /// Type of resource.
  ///
  /// Always compute#backendServiceList for lists of backend services.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  BackendServiceListWarning? warning;

  BackendServiceList();

  BackendServiceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<BackendService>((value) => BackendService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = BackendServiceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for the load balancer traffic served by this
/// backend service.
class BackendServiceLogConfig {
  /// This field denotes whether to enable logging for the load balancer traffic
  /// served by this backend service.
  core.bool? enable;

  /// This field can only be specified if logging is enabled for this backend
  /// service.
  ///
  /// The value of the field must be in \[0, 1\]. This configures the sampling
  /// rate of requests to the load balancer where 1.0 means all logged requests
  /// are reported and 0.0 means no logged requests are reported. The default
  /// value is 1.0.
  core.double? sampleRate;

  BackendServiceLogConfig();

  BackendServiceLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('sampleRate')) {
      sampleRate = (_json['sampleRate'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (sampleRate != null) 'sampleRate': sampleRate!,
      };
}

class BackendServiceReference {
  core.String? backendService;

  BackendServiceReference();

  BackendServiceReference.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
      };
}

class BackendServicesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  BackendServicesScopedListWarningData();

  BackendServicesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class BackendServicesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<BackendServicesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  BackendServicesScopedListWarning();

  BackendServicesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<BackendServicesScopedListWarningData>((value) =>
              BackendServicesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class BackendServicesScopedList {
  /// A list of BackendServices contained in this scope.
  core.List<BackendService>? backendServices;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  BackendServicesScopedListWarning? warning;

  BackendServicesScopedList();

  BackendServicesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('backendServices')) {
      backendServices = (_json['backendServices'] as core.List)
          .map<BackendService>((value) => BackendService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = BackendServicesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendServices != null)
          'backendServices':
              backendServices!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Associates `members` with a `role`.
class Binding {
  core.String? bindingId;

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request.
  ///
  /// If the condition evaluates to `false`, then this binding does not apply to
  /// the current request.
  ///
  /// However, a different role binding might grant the same role to one or more
  /// of the members in this binding.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  Expr? condition;

  /// Specifies the identities requesting access for a Cloud Platform resource.
  ///
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is on the
  /// internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone who
  /// is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  /// account. For example, `alice@example.com` .
  ///
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  /// account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a user that has been recently deleted. For
  /// example, `alice@example.com?uid=123456789012345678901`. If the user is
  /// recovered, this value reverts to `user:{emailid}` and the recovered user
  /// retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address
  /// (plus unique identifier) representing a service account that has been
  /// recently deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a Google group that has been recently deleted.
  /// For example, `admins@example.com?uid=123456789012345678901`. If the group
  /// is recovered, this value reverts to `group:{emailid}` and the recovered
  /// group retains the role in the binding.
  ///
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  /// users of that domain. For example, `google.com` or `example.com`.
  core.List<core.String>? members;

  /// Role that is assigned to `members`.
  ///
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  core.String? role;

  Binding();

  Binding.fromJson(core.Map _json) {
    if (_json.containsKey('bindingId')) {
      bindingId = _json['bindingId'] as core.String;
    }
    if (_json.containsKey('condition')) {
      condition = Expr.fromJson(
          _json['condition'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('members')) {
      members = (_json['members'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('role')) {
      role = _json['role'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindingId != null) 'bindingId': bindingId!,
        if (condition != null) 'condition': condition!.toJson(),
        if (members != null) 'members': members!,
        if (role != null) 'role': role!,
      };
}

class BulkInsertInstanceResource {
  /// The maximum number of instances to create.
  core.String? count;

  /// The instance properties defining the VM instances to be created.
  ///
  /// Required if sourceInstanceTemplate is not provided.
  InstanceProperties? instanceProperties;
  LocationPolicy? locationPolicy;

  /// The minimum number of instances to create.
  ///
  /// If no min_count is specified then count is used as the default value. If
  /// min_count instances cannot be created, then no instances will be created.
  core.String? minCount;

  /// The string pattern used for the names of the VMs.
  ///
  /// Either name_pattern or predefined_names must be set. The pattern should
  /// contain one consecutive sequence of placeholder hash characters (#) with
  /// each character corresponding to one digit of the generated instance name.
  /// Example: name_pattern of inst-#### will generate instance names like
  /// inst-0001, inst-0002, ... . If there already exist instance(s) whose names
  /// match the name pattern in the same project and zone, then the generated
  /// instance numbers will start after the biggest existing number. For
  /// example, if there exists an instance with name inst-0050, then instance
  /// names generated using the pattern inst-#### will be inst-0051, inst-0052,
  /// etc. The name pattern placeholder #...# can contain up to 18 characters.
  core.String? namePattern;

  /// Per-instance properties to be set on individual instances.
  ///
  /// Keys of this map specify requested instance names. Can be empty if
  /// name_pattern is used.
  core.Map<core.String, BulkInsertInstanceResourcePerInstanceProperties>?
      perInstanceProperties;

  /// Specifies the instance template from which to create instances.
  ///
  /// You may combine sourceInstanceTemplate with instanceProperties to override
  /// specific values from an existing instance template. Bulk API follows the
  /// semantics of JSON Merge Patch described by RFC 7396.
  ///
  /// It can be a full or partial URL. For example, the following are all valid
  /// URLs to an instance template:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
  /// - projects/project/global/instanceTemplates/instanceTemplate
  /// - global/instanceTemplates/instanceTemplate
  ///
  /// This field is optional.
  core.String? sourceInstanceTemplate;

  BulkInsertInstanceResource();

  BulkInsertInstanceResource.fromJson(core.Map _json) {
    if (_json.containsKey('count')) {
      count = _json['count'] as core.String;
    }
    if (_json.containsKey('instanceProperties')) {
      instanceProperties = InstanceProperties.fromJson(
          _json['instanceProperties'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('locationPolicy')) {
      locationPolicy = LocationPolicy.fromJson(
          _json['locationPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minCount')) {
      minCount = _json['minCount'] as core.String;
    }
    if (_json.containsKey('namePattern')) {
      namePattern = _json['namePattern'] as core.String;
    }
    if (_json.containsKey('perInstanceProperties')) {
      perInstanceProperties = (_json['perInstanceProperties']
              as core.Map<core.String, core.dynamic>)
          .map(
        (key, item) => core.MapEntry(
          key,
          BulkInsertInstanceResourcePerInstanceProperties.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('sourceInstanceTemplate')) {
      sourceInstanceTemplate = _json['sourceInstanceTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (count != null) 'count': count!,
        if (instanceProperties != null)
          'instanceProperties': instanceProperties!.toJson(),
        if (locationPolicy != null) 'locationPolicy': locationPolicy!.toJson(),
        if (minCount != null) 'minCount': minCount!,
        if (namePattern != null) 'namePattern': namePattern!,
        if (perInstanceProperties != null)
          'perInstanceProperties': perInstanceProperties!
              .map((key, item) => core.MapEntry(key, item.toJson())),
        if (sourceInstanceTemplate != null)
          'sourceInstanceTemplate': sourceInstanceTemplate!,
      };
}

/// Per-instance properties to be set on individual instances.
///
/// To be extended in the future.
class BulkInsertInstanceResourcePerInstanceProperties {
  /// This field is only temporary.
  ///
  /// It will be removed. Do not use it.
  core.String? name;

  BulkInsertInstanceResourcePerInstanceProperties();

  BulkInsertInstanceResourcePerInstanceProperties.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

class CacheInvalidationRule {
  /// If set, this invalidation rule will only apply to requests with a Host
  /// header matching host.
  core.String? host;
  core.String? path;

  CacheInvalidationRule();

  CacheInvalidationRule.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
      };
}

/// Message containing what to include in the cache key for a request for Cloud
/// CDN.
class CacheKeyPolicy {
  /// If true, requests to different hosts will be cached separately.
  core.bool? includeHost;

  /// If true, http and https requests will be cached separately.
  core.bool? includeProtocol;

  /// If true, include query string parameters in the cache key according to
  /// query_string_whitelist and query_string_blacklist.
  ///
  /// If neither is set, the entire query string will be included. If false, the
  /// query string will be excluded from the cache key entirely.
  core.bool? includeQueryString;

  /// Names of query string parameters to exclude in cache keys.
  ///
  /// All other parameters will be included. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringBlacklist;

  /// Names of query string parameters to include in cache keys.
  ///
  /// All other parameters will be excluded. Either specify
  /// query_string_whitelist or query_string_blacklist, not both. '&' and '='
  /// will be percent encoded and not treated as delimiters.
  core.List<core.String>? queryStringWhitelist;

  CacheKeyPolicy();

  CacheKeyPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('includeHost')) {
      includeHost = _json['includeHost'] as core.bool;
    }
    if (_json.containsKey('includeProtocol')) {
      includeProtocol = _json['includeProtocol'] as core.bool;
    }
    if (_json.containsKey('includeQueryString')) {
      includeQueryString = _json['includeQueryString'] as core.bool;
    }
    if (_json.containsKey('queryStringBlacklist')) {
      queryStringBlacklist = (_json['queryStringBlacklist'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('queryStringWhitelist')) {
      queryStringWhitelist = (_json['queryStringWhitelist'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (includeHost != null) 'includeHost': includeHost!,
        if (includeProtocol != null) 'includeProtocol': includeProtocol!,
        if (includeQueryString != null)
          'includeQueryString': includeQueryString!,
        if (queryStringBlacklist != null)
          'queryStringBlacklist': queryStringBlacklist!,
        if (queryStringWhitelist != null)
          'queryStringWhitelist': queryStringWhitelist!,
      };
}

/// Settings controlling the volume of connections to a backend service.
class CircuitBreakers {
  /// The maximum number of connections to the backend service.
  ///
  /// If not specified, there is no limit.
  core.int? maxConnections;

  /// The maximum number of pending requests allowed to the backend service.
  ///
  /// If not specified, there is no limit.
  core.int? maxPendingRequests;

  /// The maximum number of parallel requests that allowed to the backend
  /// service.
  ///
  /// If not specified, there is no limit.
  core.int? maxRequests;

  /// Maximum requests for a single connection to the backend service.
  ///
  /// This parameter is respected by both the HTTP/1.1 and HTTP/2
  /// implementations. If not specified, there is no limit. Setting this
  /// parameter to 1 will effectively disable keep alive.
  core.int? maxRequestsPerConnection;

  /// The maximum number of parallel retries allowed to the backend cluster.
  ///
  /// If not specified, the default is 1.
  core.int? maxRetries;

  CircuitBreakers();

  CircuitBreakers.fromJson(core.Map _json) {
    if (_json.containsKey('maxConnections')) {
      maxConnections = _json['maxConnections'] as core.int;
    }
    if (_json.containsKey('maxPendingRequests')) {
      maxPendingRequests = _json['maxPendingRequests'] as core.int;
    }
    if (_json.containsKey('maxRequests')) {
      maxRequests = _json['maxRequests'] as core.int;
    }
    if (_json.containsKey('maxRequestsPerConnection')) {
      maxRequestsPerConnection = _json['maxRequestsPerConnection'] as core.int;
    }
    if (_json.containsKey('maxRetries')) {
      maxRetries = _json['maxRetries'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxConnections != null) 'maxConnections': maxConnections!,
        if (maxPendingRequests != null)
          'maxPendingRequests': maxPendingRequests!,
        if (maxRequests != null) 'maxRequests': maxRequests!,
        if (maxRequestsPerConnection != null)
          'maxRequestsPerConnection': maxRequestsPerConnection!,
        if (maxRetries != null) 'maxRetries': maxRetries!,
      };
}

/// Represents a regional Commitment resource.
///
/// Creating a commitment resource means that you are purchasing a committed use
/// contract with an explicit start and end time.
///
/// You can create commitments based on vCPUs and memory usage and receive
/// discounted rates. For full details, read Signing Up for Committed Use
/// Discounts. (== resource_for {$api_version}.regionCommitments ==)
class Commitment {
  /// The category of the commitment.
  ///
  /// Category MACHINE specifies commitments composed of machine resources such
  /// as VCPU or MEMORY, listed in resources. Category LICENSE specifies
  /// commitments composed of software licenses, listed in licenseResources.
  /// Note that only MACHINE commitments should have a Type specified.
  /// Possible string values are:
  /// - "CATEGORY_UNSPECIFIED"
  /// - "LICENSE"
  /// - "MACHINE"
  core.String? category;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Commitment end time in RFC3339 text format.
  ///
  /// Output only.
  core.String? endTimestamp;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#commitment for commitments.
  ///
  /// Output only.
  core.String? kind;

  /// The license specification required as part of a license commitment.
  LicenseResourceCommitment? licenseResource;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The plan for this commitment, which determines duration and discount rate.
  ///
  /// The currently supported plans are TWELVE_MONTH (1 year), and
  /// THIRTY_SIX_MONTH (3 years).
  /// Possible string values are:
  /// - "INVALID"
  /// - "THIRTY_SIX_MONTH"
  /// - "TWELVE_MONTH"
  core.String? plan;

  /// URL of the region where this commitment may be used.
  ///
  /// Output only.
  core.String? region;

  /// List of reservations in this commitment.
  core.List<Reservation>? reservations;

  /// A list of commitment amounts for particular resources.
  ///
  /// Note that VCPU and MEMORY resource commitments must occur together.
  core.List<ResourceCommitment>? resources;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Commitment start time in RFC3339 text format.
  ///
  /// Output only.
  core.String? startTimestamp;

  /// Status of the commitment with regards to eventual expiration (each
  /// commitment has an end date defined).
  ///
  /// One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CREATING"
  /// - "EXPIRED"
  /// - "NOT_YET_ACTIVE"
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  Commitment();

  Commitment.fromJson(core.Map _json) {
    if (_json.containsKey('category')) {
      category = _json['category'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTimestamp')) {
      endTimestamp = _json['endTimestamp'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseResource')) {
      licenseResource = LicenseResourceCommitment.fromJson(
          _json['licenseResource'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('plan')) {
      plan = _json['plan'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('reservations')) {
      reservations = (_json['reservations'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('resources')) {
      resources = (_json['resources'] as core.List)
          .map<ResourceCommitment>((value) => ResourceCommitment.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('startTimestamp')) {
      startTimestamp = _json['startTimestamp'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (category != null) 'category': category!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (endTimestamp != null) 'endTimestamp': endTimestamp!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseResource != null)
          'licenseResource': licenseResource!.toJson(),
        if (name != null) 'name': name!,
        if (plan != null) 'plan': plan!,
        if (region != null) 'region': region!,
        if (reservations != null)
          'reservations': reservations!.map((value) => value.toJson()).toList(),
        if (resources != null)
          'resources': resources!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (startTimestamp != null) 'startTimestamp': startTimestamp!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
      };
}

class CommitmentAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentAggregatedListWarningData();

  CommitmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class CommitmentAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentAggregatedListWarning();

  CommitmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentAggregatedListWarningData>((value) =>
              CommitmentAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class CommitmentAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of CommitmentsScopedList resources.
  core.Map<core.String, CommitmentsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#commitmentAggregatedList for aggregated lists of
  /// commitments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  CommitmentAggregatedListWarning? warning;

  CommitmentAggregatedList();

  CommitmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          CommitmentsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class CommitmentListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentListWarningData();

  CommitmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class CommitmentListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentListWarning();

  CommitmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentListWarningData>((value) =>
              CommitmentListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Commitment resources.
class CommitmentList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Commitment resources.
  core.List<Commitment>? items;

  /// Type of resource.
  ///
  /// Always compute#commitmentList for lists of commitments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  CommitmentListWarning? warning;

  CommitmentList();

  CommitmentList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Commitment>((value) =>
              Commitment.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class CommitmentsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  CommitmentsScopedListWarningData();

  CommitmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of commitments when the list
/// is empty.
///
/// Output only.
class CommitmentsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<CommitmentsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  CommitmentsScopedListWarning();

  CommitmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<CommitmentsScopedListWarningData>((value) =>
              CommitmentsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class CommitmentsScopedList {
  /// A list of commitments contained in this scope.
  ///
  /// Output only.
  core.List<Commitment>? commitments;

  /// Informational warning which replaces the list of commitments when the list
  /// is empty.
  ///
  /// Output only.
  CommitmentsScopedListWarning? warning;

  CommitmentsScopedList();

  CommitmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('commitments')) {
      commitments = (_json['commitments'] as core.List)
          .map<Commitment>((value) =>
              Commitment.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = CommitmentsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (commitments != null)
          'commitments': commitments!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A condition to be met.
class Condition {
  /// Trusted attributes supplied by the IAM system.
  /// Possible string values are:
  /// - "APPROVER"
  /// - "ATTRIBUTION"
  /// - "AUTHORITY"
  /// - "CREDENTIALS_TYPE"
  /// - "CREDS_ASSERTION"
  /// - "JUSTIFICATION_TYPE"
  /// - "NO_ATTR"
  /// - "SECURITY_REALM"
  core.String? iam;

  /// An operator to apply the subject with.
  /// Possible string values are:
  /// - "DISCHARGED"
  /// - "EQUALS"
  /// - "IN"
  /// - "NOT_EQUALS"
  /// - "NOT_IN"
  /// - "NO_OP"
  core.String? op;

  /// Trusted attributes discharged by the service.
  core.String? svc;

  /// Trusted attributes supplied by any service that owns resources and uses
  /// the IAM system for access control.
  /// Possible string values are:
  /// - "IP"
  /// - "NAME"
  /// - "NO_ATTR"
  /// - "REGION"
  /// - "SERVICE"
  core.String? sys;

  /// The objects of the condition.
  core.List<core.String>? values;

  Condition();

  Condition.fromJson(core.Map _json) {
    if (_json.containsKey('iam')) {
      iam = _json['iam'] as core.String;
    }
    if (_json.containsKey('op')) {
      op = _json['op'] as core.String;
    }
    if (_json.containsKey('svc')) {
      svc = _json['svc'] as core.String;
    }
    if (_json.containsKey('sys')) {
      sys = _json['sys'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (iam != null) 'iam': iam!,
        if (op != null) 'op': op!,
        if (svc != null) 'svc': svc!,
        if (sys != null) 'sys': sys!,
        if (values != null) 'values': values!,
      };
}

/// A set of Confidential Instance options.
class ConfidentialInstanceConfig {
  /// Defines whether the instance should have confidential compute enabled.
  core.bool? enableConfidentialCompute;

  ConfidentialInstanceConfig();

  ConfidentialInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enableConfidentialCompute')) {
      enableConfidentialCompute =
          _json['enableConfidentialCompute'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableConfidentialCompute != null)
          'enableConfidentialCompute': enableConfidentialCompute!,
      };
}

/// Message containing connection draining configuration.
class ConnectionDraining {
  /// Configures a duration timeout for existing requests on a removed backend
  /// instance.
  ///
  /// For supported load balancers and protocols, as described in Enabling
  /// connection draining.
  core.int? drainingTimeoutSec;

  ConnectionDraining();

  ConnectionDraining.fromJson(core.Map _json) {
    if (_json.containsKey('drainingTimeoutSec')) {
      drainingTimeoutSec = _json['drainingTimeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainingTimeoutSec != null)
          'drainingTimeoutSec': drainingTimeoutSec!,
      };
}

/// This message defines settings for a consistent hash style load balancer.
class ConsistentHashLoadBalancerSettings {
  /// Hash is based on HTTP Cookie.
  ///
  /// This field describes a HTTP cookie that will be used as the hash key for
  /// the consistent hash load balancer. If the cookie is not present, it will
  /// be generated. This field is applicable if the sessionAffinity is set to
  /// HTTP_COOKIE.
  ConsistentHashLoadBalancerSettingsHttpCookie? httpCookie;

  /// The hash based on the value of the specified header field.
  ///
  /// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
  core.String? httpHeaderName;

  /// The minimum number of virtual nodes to use for the hash ring.
  ///
  /// Defaults to 1024. Larger ring sizes result in more granular load
  /// distributions. If the number of hosts in the load balancing pool is larger
  /// than the ring size, each host will be assigned a single virtual node.
  core.String? minimumRingSize;

  ConsistentHashLoadBalancerSettings();

  ConsistentHashLoadBalancerSettings.fromJson(core.Map _json) {
    if (_json.containsKey('httpCookie')) {
      httpCookie = ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(
          _json['httpCookie'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpHeaderName')) {
      httpHeaderName = _json['httpHeaderName'] as core.String;
    }
    if (_json.containsKey('minimumRingSize')) {
      minimumRingSize = _json['minimumRingSize'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpCookie != null) 'httpCookie': httpCookie!.toJson(),
        if (httpHeaderName != null) 'httpHeaderName': httpHeaderName!,
        if (minimumRingSize != null) 'minimumRingSize': minimumRingSize!,
      };
}

/// The information about the HTTP Cookie on which the hash function is based
/// for load balancing policies that use a consistent hash.
class ConsistentHashLoadBalancerSettingsHttpCookie {
  /// Name of the cookie.
  core.String? name;

  /// Path to set for the cookie.
  core.String? path;

  /// Lifetime of the cookie.
  Duration? ttl;

  ConsistentHashLoadBalancerSettingsHttpCookie();

  ConsistentHashLoadBalancerSettingsHttpCookie.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
    if (_json.containsKey('ttl')) {
      ttl = Duration.fromJson(
          _json['ttl'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (path != null) 'path': path!,
        if (ttl != null) 'ttl': ttl!.toJson(),
      };
}

/// The specification for allowing client side cross-origin requests.
///
/// Please see W3C Recommendation for Cross Origin Resource Sharing
class CorsPolicy {
  /// In response to a preflight request, setting this to true indicates that
  /// the actual request can include user credentials.
  ///
  /// This translates to the Access-Control-Allow-Credentials header.
  /// Default is false.
  core.bool? allowCredentials;

  /// Specifies the content for the Access-Control-Allow-Headers header.
  core.List<core.String>? allowHeaders;

  /// Specifies the content for the Access-Control-Allow-Methods header.
  core.List<core.String>? allowMethods;

  /// Specifies the regualar expression patterns that match allowed origins.
  ///
  /// For regular expression grammar please see
  /// github.com/google/re2/wiki/Syntax
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String>? allowOriginRegexes;

  /// Specifies the list of origins that will be allowed to do CORS requests.
  /// An origin is allowed if it matches either an item in allowOrigins or an
  /// item in allowOriginRegexes.
  core.List<core.String>? allowOrigins;

  /// If true, specifies the CORS policy is disabled.
  ///
  /// The default value of false, which indicates that the CORS policy is in
  /// effect.
  core.bool? disabled;

  /// Specifies the content for the Access-Control-Expose-Headers header.
  core.List<core.String>? exposeHeaders;

  /// Specifies how long results of a preflight request can be cached in
  /// seconds.
  ///
  /// This translates to the Access-Control-Max-Age header.
  core.int? maxAge;

  CorsPolicy();

  CorsPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('allowCredentials')) {
      allowCredentials = _json['allowCredentials'] as core.bool;
    }
    if (_json.containsKey('allowHeaders')) {
      allowHeaders = (_json['allowHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowMethods')) {
      allowMethods = (_json['allowMethods'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowOriginRegexes')) {
      allowOriginRegexes = (_json['allowOriginRegexes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('allowOrigins')) {
      allowOrigins = (_json['allowOrigins'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('disabled')) {
      disabled = _json['disabled'] as core.bool;
    }
    if (_json.containsKey('exposeHeaders')) {
      exposeHeaders = (_json['exposeHeaders'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('maxAge')) {
      maxAge = _json['maxAge'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowCredentials != null) 'allowCredentials': allowCredentials!,
        if (allowHeaders != null) 'allowHeaders': allowHeaders!,
        if (allowMethods != null) 'allowMethods': allowMethods!,
        if (allowOriginRegexes != null)
          'allowOriginRegexes': allowOriginRegexes!,
        if (allowOrigins != null) 'allowOrigins': allowOrigins!,
        if (disabled != null) 'disabled': disabled!,
        if (exposeHeaders != null) 'exposeHeaders': exposeHeaders!,
        if (maxAge != null) 'maxAge': maxAge!,
      };
}

class CustomerEncryptionKey {
  /// The name of the encryption key that is stored in Google Cloud KMS.
  core.String? kmsKeyName;

  /// The service account being used for the encryption request for the given
  /// KMS key.
  ///
  /// If absent, the Compute Engine default service account is used.
  core.String? kmsKeyServiceAccount;

  /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648
  /// base64 to either encrypt or decrypt this resource.
  core.String? rawKey;

  /// The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied
  /// encryption key that protects this resource.
  ///
  /// Output only.
  core.String? sha256;

  CustomerEncryptionKey();

  CustomerEncryptionKey.fromJson(core.Map _json) {
    if (_json.containsKey('kmsKeyName')) {
      kmsKeyName = _json['kmsKeyName'] as core.String;
    }
    if (_json.containsKey('kmsKeyServiceAccount')) {
      kmsKeyServiceAccount = _json['kmsKeyServiceAccount'] as core.String;
    }
    if (_json.containsKey('rawKey')) {
      rawKey = _json['rawKey'] as core.String;
    }
    if (_json.containsKey('sha256')) {
      sha256 = _json['sha256'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
        if (kmsKeyServiceAccount != null)
          'kmsKeyServiceAccount': kmsKeyServiceAccount!,
        if (rawKey != null) 'rawKey': rawKey!,
        if (sha256 != null) 'sha256': sha256!,
      };
}

class CustomerEncryptionKeyProtectedDisk {
  /// Decrypts data associated with the disk with a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? diskEncryptionKey;

  /// Specifies a valid partial or full URL to an existing Persistent Disk
  /// resource.
  ///
  /// This field is only applicable for persistent disks.
  core.String? source;

  CustomerEncryptionKeyProtectedDisk();

  CustomerEncryptionKeyProtectedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (source != null) 'source': source!,
      };
}

/// Deprecation status for a public resource.
class DeprecationStatus {
  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DELETED.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? deleted;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to DEPRECATED.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? deprecated;

  /// An optional RFC3339 timestamp on or after which the state of this resource
  /// is intended to change to OBSOLETE.
  ///
  /// This is only informational and the status will not change unless the
  /// client explicitly changes it.
  core.String? obsolete;

  /// The URL of the suggested replacement for a deprecated resource.
  ///
  /// The suggested replacement resource must be the same kind of resource as
  /// the deprecated resource.
  core.String? replacement;

  /// The deprecation state of this resource.
  ///
  /// This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which
  /// communicate the end of life date for an image, can use ACTIVE. Operations
  /// which create a new resource using a DEPRECATED resource will return
  /// successfully, but with a warning indicating the deprecated resource and
  /// recommending its replacement. Operations which use OBSOLETE or DELETED
  /// resources will be rejected and result in an error.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DELETED"
  /// - "DEPRECATED"
  /// - "OBSOLETE"
  core.String? state;

  DeprecationStatus();

  DeprecationStatus.fromJson(core.Map _json) {
    if (_json.containsKey('deleted')) {
      deleted = _json['deleted'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = _json['deprecated'] as core.String;
    }
    if (_json.containsKey('obsolete')) {
      obsolete = _json['obsolete'] as core.String;
    }
    if (_json.containsKey('replacement')) {
      replacement = _json['replacement'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (deleted != null) 'deleted': deleted!,
        if (deprecated != null) 'deprecated': deprecated!,
        if (obsolete != null) 'obsolete': obsolete!,
        if (replacement != null) 'replacement': replacement!,
        if (state != null) 'state': state!,
      };
}

/// Represents a Persistent Disk resource.
///
/// Google Compute Engine has two Disk resources:
///
/// * \[Zonal\](/compute/docs/reference/rest/{$api_version}/disks) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionDisks)
///
/// Persistent disks are required for running your VM instances.
///
/// Create both boot and non-boot (data) persistent disks. For more information,
/// read Persistent Disks. For more storage options, read Storage options.
///
/// The disks resource represents a zonal persistent disk. For more information,
/// read Zonal persistent disks.
///
/// The regionDisks resource represents a regional persistent disk. For more
/// information, read Regional resources. (== resource_for {$api_version}.disks
/// ==) (== resource_for {$api_version}.regionDisks ==)
class Disk {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Encrypts the disk using a customer-supplied encryption key.
  ///
  /// After you encrypt a disk with a customer-supplied key, you must provide
  /// the same key if you use the disk later (e.g. to create a disk snapshot, to
  /// create a disk image, to create a machine image, or to attach the disk to a
  /// virtual machine).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the disk, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the disk later.
  CustomerEncryptionKey? diskEncryptionKey;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#disk for disks.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this disk, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a disk.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this disk.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Last attach timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastAttachTimestamp;

  /// Last detach timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastDetachTimestamp;

  /// Integer license codes indicating which licenses are attached to this disk.
  core.List<core.String>? licenseCodes;

  /// A list of publicly visible licenses.
  ///
  /// Reserved for Google's use.
  core.List<core.String>? licenses;

  /// An opaque location hint used to place the disk close to other resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Internal use only.
  core.String? options;

  /// Physical block size of the persistent disk, in bytes.
  ///
  /// If not present in a request, a default value is used. The currently
  /// supported size is 4096, other sizes may be added in the future. If an
  /// unsupported value is requested, the error message will list the supported
  /// values for the caller's project.
  core.String? physicalBlockSizeBytes;

  /// Indicates how many IOPS must be provisioned for the disk.
  core.String? provisionedIops;

  /// URL of the region where the disk resides.
  ///
  /// Only applicable for regional resources. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  ///
  /// Output only.
  core.String? region;

  /// URLs of the zones where the disk should be replicated to.
  ///
  /// Only applicable for regional resources.
  core.List<core.String>? replicaZones;

  /// Resource policies applied to this disk for automatic snapshot creations.
  core.List<core.String>? resourcePolicies;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Size, in GB, of the persistent disk.
  ///
  /// You can specify this field when creating a persistent disk using the
  /// sourceImage, sourceSnapshot, or sourceDisk parameter, or specify it alone
  /// to create an empty persistent disk.
  ///
  /// If you specify this field along with a source, the value of sizeGb must
  /// not be less than the size of the source. Acceptable values are 1 to 65536,
  /// inclusive.
  core.String? sizeGb;

  /// The source disk used to create this disk.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - projects/project/regions/region/disks/disk
  /// - zones/zone/disks/disk
  /// - regions/region/disks/disk
  core.String? sourceDisk;

  /// The unique ID of the disk used to create this disk.
  ///
  /// This value identifies the exact disk that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// disk that was later deleted and recreated under the same name, the source
  /// disk ID would identify the exact version of the disk that was used.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// The source image used to create this disk.
  ///
  /// If the source image is deleted, this field will not be set.
  ///
  /// To create a disk with one of the public operating system images, specify
  /// the image by its family name. For example, specify family/debian-9 to use
  /// the latest Debian 9 image:
  /// projects/debian-cloud/global/images/family/debian-9
  ///
  ///
  /// Alternatively, use a specific version of a public operating system image:
  /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
  ///
  ///
  /// To create a disk with a custom image that you created, specify the image
  /// name in the following format:
  /// global/images/my-custom-image
  ///
  ///
  /// You can also specify a custom image by its image family, which returns the
  /// latest version of the image in that family. Replace the image name with
  /// family/family-name:
  /// global/images/family/my-image-family
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The ID value of the image used to create this disk.
  ///
  /// This value identifies the exact image that was used to create this
  /// persistent disk. For example, if you created the persistent disk from an
  /// image that was later deleted and recreated under the same name, the source
  /// image ID would identify the exact version of the image that was used.
  ///
  /// Output only.
  core.String? sourceImageId;

  /// The source snapshot used to create this disk.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/snapshots/snapshot
  /// - projects/project/global/snapshots/snapshot
  /// - global/snapshots/snapshot
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  ///
  /// Required if the source snapshot is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  /// The unique ID of the snapshot used to create this disk.
  ///
  /// This value identifies the exact snapshot that was used to create this
  /// persistent disk. For example, if you created the persistent disk from a
  /// snapshot that was later deleted and recreated under the same name, the
  /// source snapshot ID would identify the exact version of the snapshot that
  /// was used.
  ///
  /// Output only.
  core.String? sourceSnapshotId;

  /// The full Google Cloud Storage URI where the disk image is stored.
  ///
  /// This file must be a gzip-compressed tarball whose name ends in .tar.gz or
  /// virtual machine disk whose name ends in vmdk. Valid URIs may start with
  /// gs:// or https://storage.googleapis.com/. This flag is not optimized for
  /// creating multiple disks from a source storage object. To create many disks
  /// from a source storage object, use gcloud compute images import instead.
  core.String? sourceStorageObject;

  /// The status of disk creation.
  ///
  ///
  /// - CREATING: Disk is provisioning.
  /// - RESTORING: Source data is being copied into the disk.
  /// - FAILED: Disk creation failed.
  /// - READY: Disk is ready for use.
  /// - DELETING: Disk is deleting.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "RESTORING"
  core.String? status;

  /// URL of the disk type resource describing which disk type to use to create
  /// the disk.
  ///
  /// Provide this when creating the disk. For example:
  /// projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
  core.String? type;

  /// Links to the users of the disk (attached instances) in form:
  /// projects/project/zones/zone/instances/instance
  ///
  /// Output only.
  core.List<core.String>? users;

  /// URL of the zone where the disk resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  Disk();

  Disk.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskEncryptionKey')) {
      diskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['diskEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('lastAttachTimestamp')) {
      lastAttachTimestamp = _json['lastAttachTimestamp'] as core.String;
    }
    if (_json.containsKey('lastDetachTimestamp')) {
      lastDetachTimestamp = _json['lastDetachTimestamp'] as core.String;
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('locationHint')) {
      locationHint = _json['locationHint'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('options')) {
      options = _json['options'] as core.String;
    }
    if (_json.containsKey('physicalBlockSizeBytes')) {
      physicalBlockSizeBytes = _json['physicalBlockSizeBytes'] as core.String;
    }
    if (_json.containsKey('provisionedIops')) {
      provisionedIops = _json['provisionedIops'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('replicaZones')) {
      replicaZones = (_json['replicaZones'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceImageId')) {
      sourceImageId = _json['sourceImageId'] as core.String;
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshotId')) {
      sourceSnapshotId = _json['sourceSnapshotId'] as core.String;
    }
    if (_json.containsKey('sourceStorageObject')) {
      sourceStorageObject = _json['sourceStorageObject'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('users')) {
      users = (_json['users'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (diskEncryptionKey != null)
          'diskEncryptionKey': diskEncryptionKey!.toJson(),
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (lastAttachTimestamp != null)
          'lastAttachTimestamp': lastAttachTimestamp!,
        if (lastDetachTimestamp != null)
          'lastDetachTimestamp': lastDetachTimestamp!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (name != null) 'name': name!,
        if (options != null) 'options': options!,
        if (physicalBlockSizeBytes != null)
          'physicalBlockSizeBytes': physicalBlockSizeBytes!,
        if (provisionedIops != null) 'provisionedIops': provisionedIops!,
        if (region != null) 'region': region!,
        if (replicaZones != null) 'replicaZones': replicaZones!,
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sizeGb != null) 'sizeGb': sizeGb!,
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceImageId != null) 'sourceImageId': sourceImageId!,
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
        if (sourceSnapshotId != null) 'sourceSnapshotId': sourceSnapshotId!,
        if (sourceStorageObject != null)
          'sourceStorageObject': sourceStorageObject!,
        if (status != null) 'status': status!,
        if (type != null) 'type': type!,
        if (users != null) 'users': users!,
        if (zone != null) 'zone': zone!,
      };
}

class DiskAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskAggregatedListWarningData();

  DiskAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskAggregatedListWarning();

  DiskAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskAggregatedListWarningData>((value) =>
              DiskAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DisksScopedList resources.
  core.Map<core.String, DisksScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#diskAggregatedList for aggregated lists of persistent
  /// disks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  DiskAggregatedListWarning? warning;

  DiskAggregatedList();

  DiskAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          DisksScopedList.fromJson(item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A specification of the desired way to instantiate a disk in the instance
/// template when its created from a source instance.
class DiskInstantiationConfig {
  /// Specifies whether the disk will be auto-deleted when the instance is
  /// deleted (but not when the disk is detached from the instance).
  core.bool? autoDelete;

  /// The custom source image to be used to restore this disk when instantiating
  /// this instance template.
  core.String? customImage;

  /// Specifies the device name of the disk to which the configurations apply
  /// to.
  core.String? deviceName;

  /// Specifies whether to include the disk and what image to use.
  ///
  /// Possible values are:
  /// - source-image: to use the same image that was used to create the source
  /// instance's corresponding disk. Applicable to the boot disk and additional
  /// read-write disks.
  /// - source-image-family: to use the same image family that was used to
  /// create the source instance's corresponding disk. Applicable to the boot
  /// disk and additional read-write disks.
  /// - custom-image: to use a user-provided image url for disk creation.
  /// Applicable to the boot disk and additional read-write disks.
  /// - attach-read-only: to attach a read-only disk. Applicable to read-only
  /// disks.
  /// - do-not-include: to exclude a disk from the template. Applicable to
  /// additional read-write disks, local SSDs, and read-only disks.
  /// Possible string values are:
  /// - "ATTACH_READ_ONLY"
  /// - "BLANK"
  /// - "CUSTOM_IMAGE"
  /// - "DEFAULT"
  /// - "DO_NOT_INCLUDE"
  /// - "SOURCE_IMAGE"
  /// - "SOURCE_IMAGE_FAMILY"
  core.String? instantiateFrom;

  DiskInstantiationConfig();

  DiskInstantiationConfig.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.bool;
    }
    if (_json.containsKey('customImage')) {
      customImage = _json['customImage'] as core.String;
    }
    if (_json.containsKey('deviceName')) {
      deviceName = _json['deviceName'] as core.String;
    }
    if (_json.containsKey('instantiateFrom')) {
      instantiateFrom = _json['instantiateFrom'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (customImage != null) 'customImage': customImage!,
        if (deviceName != null) 'deviceName': deviceName!,
        if (instantiateFrom != null) 'instantiateFrom': instantiateFrom!,
      };
}

class DiskListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskListWarningData();

  DiskListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskListWarning();

  DiskListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskListWarningData>((value) => DiskListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of Disk resources.
class DiskList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Disk resources.
  core.List<Disk>? items;

  /// Type of resource.
  ///
  /// Always compute#diskList for lists of disks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  DiskListWarning? warning;

  DiskList();

  DiskList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Disk>((value) =>
              Disk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = DiskListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskMoveRequest {
  /// The URL of the destination zone to move the disk.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String? destinationZone;

  /// The URL of the target disk to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a disk:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String? targetDisk;

  DiskMoveRequest();

  DiskMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey('destinationZone')) {
      destinationZone = _json['destinationZone'] as core.String;
    }
    if (_json.containsKey('targetDisk')) {
      targetDisk = _json['targetDisk'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationZone != null) 'destinationZone': destinationZone!,
        if (targetDisk != null) 'targetDisk': targetDisk!,
      };
}

/// Represents a Disk Type resource.
///
/// Google Compute Engine has two Disk Type resources:
///
/// * \[Regional\](/compute/docs/reference/rest/{$api_version}/regionDiskTypes)
/// * \[Zonal\](/compute/docs/reference/rest/{$api_version}/diskTypes)
///
/// You can choose from a variety of disk types based on your needs.
///
/// For more information, read Storage options.
///
/// The diskTypes resource represents disk types for a zonal persistent disk.
/// For more information, read Zonal persistent disks.
///
/// The regionDiskTypes resource represents disk types for a regional persistent
/// disk. For more information, read Regional persistent disks. (== resource_for
/// {$api_version}.diskTypes ==) (== resource_for {$api_version}.regionDiskTypes
/// ==)
class DiskType {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Server-defined default disk size in GB.
  ///
  /// Output only.
  core.String? defaultDiskSizeGb;

  /// The deprecation status associated with this disk type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional description of this resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#diskType for disk types.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// URL of the region where the disk type resides.
  ///
  /// Only applicable for regional resources. You must specify this field as
  /// part of the HTTP request URL. It is not settable as a field in the request
  /// body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// An optional textual description of the valid disk size, such as
  /// "10GB-10TB".
  ///
  /// Output only.
  core.String? validDiskSize;

  /// URL of the zone where the disk type resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  DiskType();

  DiskType.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultDiskSizeGb')) {
      defaultDiskSizeGb = _json['defaultDiskSizeGb'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('validDiskSize')) {
      validDiskSize = _json['validDiskSize'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultDiskSizeGb != null) 'defaultDiskSizeGb': defaultDiskSizeGb!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (validDiskSize != null) 'validDiskSize': validDiskSize!,
        if (zone != null) 'zone': zone!,
      };
}

class DiskTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypeAggregatedListWarningData();

  DiskTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypeAggregatedListWarning();

  DiskTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypeAggregatedListWarningData>((value) =>
              DiskTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskTypesScopedList resources.
  core.Map<core.String, DiskTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#diskTypeAggregatedList.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  DiskTypeAggregatedListWarning? warning;

  DiskTypeAggregatedList();

  DiskTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          DiskTypesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypeListWarningData();

  DiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class DiskTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypeListWarning();

  DiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypeListWarningData>((value) =>
              DiskTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of disk types.
class DiskTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskType resources.
  core.List<DiskType>? items;

  /// Type of resource.
  ///
  /// Always compute#diskTypeList for disk types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  DiskTypeListWarning? warning;

  DiskTypeList();

  DiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DiskTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DiskTypesScopedListWarningData();

  DiskTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of disk types when the list is
/// empty.
///
/// Output only.
class DiskTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DiskTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DiskTypesScopedListWarning();

  DiskTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DiskTypesScopedListWarningData>((value) =>
              DiskTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DiskTypesScopedList {
  /// A list of disk types contained in this scope.
  ///
  /// Output only.
  core.List<DiskType>? diskTypes;

  /// Informational warning which replaces the list of disk types when the list
  /// is empty.
  ///
  /// Output only.
  DiskTypesScopedListWarning? warning;

  DiskTypesScopedList();

  DiskTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('diskTypes')) {
      diskTypes = (_json['diskTypes'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DiskTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskTypes != null)
          'diskTypes': diskTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class DisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  ///
  /// Currently you can only specify one policy here.
  core.List<core.String>? resourcePolicies;

  DisksAddResourcePoliciesRequest();

  DisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class DisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String>? resourcePolicies;

  DisksRemoveResourcePoliciesRequest();

  DisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class DisksResizeRequest {
  /// The new size of the persistent disk, which is specified in GB.
  core.String? sizeGb;

  DisksResizeRequest();

  DisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sizeGb != null) 'sizeGb': sizeGb!,
      };
}

class DisksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  DisksScopedListWarningData();

  DisksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of disks when the list is
/// empty.
///
/// Output only.
class DisksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<DisksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  DisksScopedListWarning();

  DisksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<DisksScopedListWarningData>((value) =>
              DisksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class DisksScopedList {
  /// A list of disks contained in this scope.
  ///
  /// Output only.
  core.List<Disk>? disks;

  /// Informational warning which replaces the list of disks when the list is
  /// empty.
  ///
  /// Output only.
  DisksScopedListWarning? warning;

  DisksScopedList();

  DisksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<Disk>((value) =>
              Disk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = DisksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A set of Display Device options
class DisplayDevice {
  /// Defines whether the instance has Display enabled.
  core.bool? enableDisplay;

  DisplayDevice();

  DisplayDevice.fromJson(core.Map _json) {
    if (_json.containsKey('enableDisplay')) {
      enableDisplay = _json['enableDisplay'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableDisplay != null) 'enableDisplay': enableDisplay!,
      };
}

class DistributionPolicy {
  /// Zones where the regional managed instance group will create and manage its
  /// instances.
  core.List<DistributionPolicyZoneConfiguration>? zones;

  DistributionPolicy();

  DistributionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('zones')) {
      zones = (_json['zones'] as core.List)
          .map<DistributionPolicyZoneConfiguration>((value) =>
              DistributionPolicyZoneConfiguration.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (zones != null)
          'zones': zones!.map((value) => value.toJson()).toList(),
      };
}

class DistributionPolicyZoneConfiguration {
  /// The URL of the zone.
  ///
  /// The zone must exist in the region where the managed instance group is
  /// located.
  core.String? zone;

  DistributionPolicyZoneConfiguration();

  DistributionPolicyZoneConfiguration.fromJson(core.Map _json) {
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (zone != null) 'zone': zone!,
      };
}

/// A Duration represents a fixed-length span of time represented as a count of
/// seconds and fractions of seconds at nanosecond resolution.
///
/// It is independent of any calendar and concepts like "day" or "month". Range
/// is approximately 10,000 years.
class Duration {
  /// Span of time that's a fraction of a second at nanosecond resolution.
  ///
  /// Durations less than one second are represented with a 0 `seconds` field
  /// and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
  core.int? nanos;

  /// Span of time at a resolution of a second.
  ///
  /// Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are
  /// computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year *
  /// 10000 years
  core.String? seconds;

  Duration();

  Duration.fromJson(core.Map _json) {
    if (_json.containsKey('nanos')) {
      nanos = _json['nanos'] as core.int;
    }
    if (_json.containsKey('seconds')) {
      seconds = _json['seconds'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nanos != null) 'nanos': nanos!,
        if (seconds != null) 'seconds': seconds!,
      };
}

class ExchangedPeeringRoute {
  /// The destination range of the route.
  core.String? destRange;

  /// True if the peering route has been imported from a peer.
  ///
  /// The actual import happens if the field networkPeering.importCustomRoutes
  /// is true for this network, and networkPeering.exportCustomRoutes is true
  /// for the peer network, and the import does not result in a route conflict.
  core.bool? imported;

  /// The region of peering route next hop, only applies to dynamic routes.
  core.String? nextHopRegion;

  /// The priority of the peering route.
  core.int? priority;

  /// The type of the peering route.
  /// Possible string values are:
  /// - "DYNAMIC_PEERING_ROUTE"
  /// - "STATIC_PEERING_ROUTE"
  /// - "SUBNET_PEERING_ROUTE"
  core.String? type;

  ExchangedPeeringRoute();

  ExchangedPeeringRoute.fromJson(core.Map _json) {
    if (_json.containsKey('destRange')) {
      destRange = _json['destRange'] as core.String;
    }
    if (_json.containsKey('imported')) {
      imported = _json['imported'] as core.bool;
    }
    if (_json.containsKey('nextHopRegion')) {
      nextHopRegion = _json['nextHopRegion'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (destRange != null) 'destRange': destRange!,
        if (imported != null) 'imported': imported!,
        if (nextHopRegion != null) 'nextHopRegion': nextHopRegion!,
        if (priority != null) 'priority': priority!,
        if (type != null) 'type': type!,
      };
}

class ExchangedPeeringRoutesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ExchangedPeeringRoutesListWarningData();

  ExchangedPeeringRoutesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ExchangedPeeringRoutesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ExchangedPeeringRoutesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ExchangedPeeringRoutesListWarning();

  ExchangedPeeringRoutesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ExchangedPeeringRoutesListWarningData>((value) =>
              ExchangedPeeringRoutesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ExchangedPeeringRoutesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ExchangedPeeringRoute resources.
  core.List<ExchangedPeeringRoute>? items;

  /// Type of resource.
  ///
  /// Always compute#exchangedPeeringRoutesList for exchanged peering routes
  /// lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ExchangedPeeringRoutesListWarning? warning;

  ExchangedPeeringRoutesList();

  ExchangedPeeringRoutesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ExchangedPeeringRoute>((value) => ExchangedPeeringRoute.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ExchangedPeeringRoutesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec.
///
/// Example (Comparison):
///
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() < 100"
///
/// Example (Equality):
///
/// title: "Requestor is owner" description: "Determines if requestor is the
/// document owner" expression: "document.owner == request.auth.claims.email"
///
/// Example (Logic):
///
/// title: "Public documents" description: "Determine whether the document
/// should be publicly visible" expression: "document.type != 'private' &&
/// document.type != 'internal'"
///
/// Example (Data Manipulation):
///
/// title: "Notification string" description: "Create a notification string with
/// a timestamp." expression: "'New message received at ' +
/// string(document.create_time)"
///
/// The exact variables and functions that may be referenced within an
/// expression are determined by the service that evaluates it. See the service
/// documentation for additional information.
class Expr {
  /// Description of the expression.
  ///
  /// This is a longer text which describes the expression, e.g. when hovered
  /// over it in a UI.
  ///
  /// Optional.
  core.String? description;

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  core.String? expression;

  /// String indicating the location of the expression for error reporting, e.g.
  /// a file name and a position in the file.
  ///
  /// Optional.
  core.String? location;

  /// Title for the expression, i.e. a short string describing its purpose.
  ///
  /// This can be used e.g. in UIs which allow to enter the expression.
  ///
  /// Optional.
  core.String? title;

  Expr();

  Expr.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expression')) {
      expression = _json['expression'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('title')) {
      title = _json['title'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (expression != null) 'expression': expression!,
        if (location != null) 'location': location!,
        if (title != null) 'title': title!,
      };
}

/// Represents an external VPN gateway.
///
/// External VPN gateway is the on-premises VPN gateway(s) or another cloud
/// provider's VPN gateway that connects to your Google Cloud VPN gateway.
///
/// To create a highly available VPN from Google Cloud Platform to your VPN
/// gateway or another cloud provider's VPN gateway, you must create a external
/// VPN gateway resource with information about the other gateway.
///
/// For more information about using external VPN gateways, see Creating an HA
/// VPN gateway and tunnel pair to a peer VPN.
///
/// (== resource_for {$api_version}.externalVpnGateways ==)
class ExternalVpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// List of interfaces for this external VPN gateway.
  core.List<ExternalVpnGatewayInterface>? interfaces;

  /// Type of the resource.
  ///
  /// Always compute#externalVpnGateway for externalVpnGateways.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this ExternalVpnGateway,
  /// which is essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// ExternalVpnGateway.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Indicates the user-supplied redundancy type of this external VPN gateway.
  /// Possible string values are:
  /// - "FOUR_IPS_REDUNDANCY"
  /// - "SINGLE_IP_INTERNALLY_REDUNDANT"
  /// - "TWO_IPS_REDUNDANCY"
  core.String? redundancyType;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  ExternalVpnGateway();

  ExternalVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interfaces')) {
      interfaces = (_json['interfaces'] as core.List)
          .map<ExternalVpnGatewayInterface>((value) =>
              ExternalVpnGatewayInterface.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('redundancyType')) {
      redundancyType = _json['redundancyType'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (interfaces != null)
          'interfaces': interfaces!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (redundancyType != null) 'redundancyType': redundancyType!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// The interface for the external VPN gateway.
class ExternalVpnGatewayInterface {
  /// The numeric ID of this interface.
  ///
  /// The allowed input values for this id for different redundancy types of
  /// external VPN gateway: SINGLE_IP_INTERNALLY_REDUNDANT - 0
  /// TWO_IPS_REDUNDANCY - 0, 1 FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
  core.int? id;

  /// IP address of the interface in the external VPN gateway.
  ///
  /// Only IPv4 is supported. This IP address can be either from your on-premise
  /// gateway or another Cloud provider's VPN gateway, it cannot be an IP
  /// address from Google Compute Engine.
  core.String? ipAddress;

  ExternalVpnGatewayInterface();

  ExternalVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.int;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
      };
}

class ExternalVpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ExternalVpnGatewayListWarningData();

  ExternalVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ExternalVpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ExternalVpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ExternalVpnGatewayListWarning();

  ExternalVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ExternalVpnGatewayListWarningData>((value) =>
              ExternalVpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of externalVpnGateways.
class ExternalVpnGatewayList {
  core.String? etag;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ExternalVpnGateway resources.
  core.List<ExternalVpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#externalVpnGatewayList  for lists of externalVpnGateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ExternalVpnGatewayListWarning? warning;

  ExternalVpnGatewayList();

  ExternalVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ExternalVpnGateway>((value) => ExternalVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ExternalVpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class FileContentBuffer {
  /// The raw content in the secure keys file.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> _bytes) {
    content =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The file type of source file.
  /// Possible string values are:
  /// - "BIN"
  /// - "UNDEFINED"
  /// - "X509"
  core.String? fileType;

  FileContentBuffer();

  FileContentBuffer.fromJson(core.Map _json) {
    if (_json.containsKey('content')) {
      content = _json['content'] as core.String;
    }
    if (_json.containsKey('fileType')) {
      fileType = _json['fileType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
        if (fileType != null) 'fileType': fileType!,
      };
}

class FirewallAllowed {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp) or the IP protocol number.
  core.String? IPProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for the UDP or TCP protocol. Each entry must
  /// be either an integer or a range. If not specified, this rule applies to
  /// connections through any port.
  ///
  /// Example inputs include: \["22"\], \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallAllowed();

  FirewallAllowed.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

class FirewallDenied {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp) or the IP protocol number.
  core.String? IPProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for the UDP or TCP protocol. Each entry must
  /// be either an integer or a range. If not specified, this rule applies to
  /// connections through any port.
  ///
  /// Example inputs include: \["22"\], \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallDenied();

  FirewallDenied.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

/// Represents a Firewall Rule resource.
///
/// Firewall rules allow or deny ingress traffic to, and egress traffic from
/// your instances.
///
/// For more information, read Firewall rules.
class Firewall {
  /// The list of ALLOW rules specified by this firewall.
  ///
  /// Each rule specifies a protocol and port-range tuple that describes a
  /// permitted connection.
  core.List<FirewallAllowed>? allowed;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The list of DENY rules specified by this firewall.
  ///
  /// Each rule specifies a protocol and port-range tuple that describes a
  /// denied connection.
  core.List<FirewallDenied>? denied;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// If destination ranges are specified, the firewall rule applies only to
  /// traffic that has destination IP address in these ranges.
  ///
  /// These ranges must be expressed in CIDR format. Only IPv4 is supported.
  core.List<core.String>? destinationRanges;

  /// Direction of traffic to which this firewall applies, either `INGRESS` or
  /// `EGRESS`.
  ///
  /// The default is `INGRESS`. For `INGRESS` traffic, you cannot specify the
  /// destinationRanges field, and for `EGRESS` traffic, you cannot specify the
  /// sourceRanges or sourceTags fields.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String? direction;

  /// Denotes whether the firewall rule is disabled.
  ///
  /// When set to true, the firewall rule is not enforced and the network
  /// behaves as if it did not exist. If this is unspecified, the firewall rule
  /// will be enabled.
  core.bool? disabled;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#firewall for firewall rules.
  ///
  /// Output only.
  core.String? kind;

  /// This field denotes the logging options for a particular firewall rule.
  ///
  /// If logging is enabled, logs will be exported to Cloud Logging.
  FirewallLogConfig? logConfig;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression \`\[a-z\](\[-a-z0-9\]*\[a-z0-9\])?. The first character must be
  /// a lowercase letter, and all following characters (except for the last
  /// character) must be a dash, lowercase letter, or digit. The last character
  /// must be a lowercase letter or digit.
  core.String? name;

  /// URL of the network resource for this firewall rule.
  ///
  /// If not specified when creating a firewall rule, the default network is
  /// used:
  /// global/networks/default
  /// If you choose to specify this field, you can specify the network as a full
  /// or partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network
  /// - projects/myproject/global/networks/my-network
  /// - global/networks/default
  core.String? network;

  /// Priority for this rule.
  ///
  /// This is an integer between `0` and `65535`, both inclusive. The default
  /// value is `1000`. Relative priorities determine which rule takes effect if
  /// multiple rules apply. Lower values indicate higher priority. For example,
  /// a rule with priority `0` has higher precedence than a rule with priority
  /// `1`. DENY rules take precedence over ALLOW rules if they have equal
  /// priority. Note that VPC networks have implied rules with a priority of
  /// `65535`. To avoid conflicts with the implied rules, use a priority number
  /// less than `65535`.
  core.int? priority;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If source ranges are specified, the firewall rule applies only to traffic
  /// that has a source IP address in these ranges.
  ///
  /// These ranges must be expressed in CIDR format. One or both of sourceRanges
  /// and sourceTags may be set. If both fields are set, the rule applies to
  /// traffic that has a source IP address within sourceRanges OR a source IP
  /// from a resource with a matching tag listed in the sourceTags field. The
  /// connection does not need to match both fields for the rule to apply. Only
  /// IPv4 is supported.
  core.List<core.String>? sourceRanges;

  /// If source service accounts are specified, the firewall rules apply only to
  /// traffic originating from an instance with a service account in this list.
  ///
  /// Source service accounts cannot be used to control traffic to an instance's
  /// external IP address because service accounts are associated with an
  /// instance, not an IP address. sourceRanges can be set at the same time as
  /// sourceServiceAccounts. If both are set, the firewall applies to traffic
  /// that has a source IP address within the sourceRanges OR a source IP that
  /// belongs to an instance with service account listed in
  /// sourceServiceAccount. The connection does not need to match both fields
  /// for the firewall to apply. sourceServiceAccounts cannot be used at the
  /// same time as sourceTags or targetTags.
  core.List<core.String>? sourceServiceAccounts;

  /// If source tags are specified, the firewall rule applies only to traffic
  /// with source IPs that match the primary network interfaces of VM instances
  /// that have the tag and are in the same VPC network.
  ///
  /// Source tags cannot be used to control traffic to an instance's external IP
  /// address, it only applies to traffic between instances in the same virtual
  /// network. Because tags are associated with instances, not IP addresses. One
  /// or both of sourceRanges and sourceTags may be set. If both fields are set,
  /// the firewall applies to traffic that has a source IP address within
  /// sourceRanges OR a source IP from a resource with a matching tag listed in
  /// the sourceTags field. The connection does not need to match both fields
  /// for the firewall to apply.
  core.List<core.String>? sourceTags;

  /// A list of service accounts indicating sets of instances located in the
  /// network that may make network connections as specified in allowed\[\].
  ///
  /// targetServiceAccounts cannot be used at the same time as targetTags or
  /// sourceTags. If neither targetServiceAccounts nor targetTags are specified,
  /// the firewall rule applies to all instances on the specified network.
  core.List<core.String>? targetServiceAccounts;

  /// A list of tags that controls which instances the firewall rule applies to.
  ///
  /// If targetTags are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those tags. If no targetTags
  /// are specified, the firewall rule applies to all instances on the specified
  /// network.
  core.List<core.String>? targetTags;

  Firewall();

  Firewall.fromJson(core.Map _json) {
    if (_json.containsKey('allowed')) {
      allowed = (_json['allowed'] as core.List)
          .map<FirewallAllowed>((value) => FirewallAllowed.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('denied')) {
      denied = (_json['denied'] as core.List)
          .map<FirewallDenied>((value) => FirewallDenied.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('destinationRanges')) {
      destinationRanges = (_json['destinationRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('direction')) {
      direction = _json['direction'] as core.String;
    }
    if (_json.containsKey('disabled')) {
      disabled = _json['disabled'] as core.bool;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = FirewallLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sourceRanges')) {
      sourceRanges = (_json['sourceRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceServiceAccounts')) {
      sourceServiceAccounts = (_json['sourceServiceAccounts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceTags')) {
      sourceTags = (_json['sourceTags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetServiceAccounts')) {
      targetServiceAccounts = (_json['targetServiceAccounts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetTags')) {
      targetTags = (_json['targetTags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowed != null)
          'allowed': allowed!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (denied != null)
          'denied': denied!.map((value) => value.toJson()).toList(),
        if (description != null) 'description': description!,
        if (destinationRanges != null) 'destinationRanges': destinationRanges!,
        if (direction != null) 'direction': direction!,
        if (disabled != null) 'disabled': disabled!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (priority != null) 'priority': priority!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sourceRanges != null) 'sourceRanges': sourceRanges!,
        if (sourceServiceAccounts != null)
          'sourceServiceAccounts': sourceServiceAccounts!,
        if (sourceTags != null) 'sourceTags': sourceTags!,
        if (targetServiceAccounts != null)
          'targetServiceAccounts': targetServiceAccounts!,
        if (targetTags != null) 'targetTags': targetTags!,
      };
}

class FirewallListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  FirewallListWarningData();

  FirewallListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class FirewallListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<FirewallListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  FirewallListWarning();

  FirewallListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<FirewallListWarningData>((value) =>
              FirewallListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of firewalls.
class FirewallList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Firewall resources.
  core.List<Firewall>? items;

  /// Type of resource.
  ///
  /// Always compute#firewallList for lists of firewalls.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  FirewallListWarning? warning;

  FirewallList();

  FirewallList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Firewall>((value) =>
              Firewall.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = FirewallListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for a firewall rule.
class FirewallLogConfig {
  /// This field denotes whether to enable logging for a particular firewall
  /// rule.
  core.bool? enable;

  /// This field can only be specified for a particular firewall rule if logging
  /// is enabled for that rule.
  ///
  /// This field denotes whether to include or exclude metadata for firewall
  /// logs.
  /// Possible string values are:
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  FirewallLogConfig();

  FirewallLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('metadata')) {
      metadata = _json['metadata'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (metadata != null) 'metadata': metadata!,
      };
}

class FirewallPoliciesListAssociationsResponse {
  /// A list of associations.
  core.List<FirewallPolicyAssociation>? associations;

  /// Type of firewallPolicy associations.
  ///
  /// Always compute#FirewallPoliciesListAssociations for lists of
  /// firewallPolicy associations.
  ///
  /// Output only.
  core.String? kind;

  FirewallPoliciesListAssociationsResponse();

  FirewallPoliciesListAssociationsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('associations')) {
      associations = (_json['associations'] as core.List)
          .map<FirewallPolicyAssociation>((value) =>
              FirewallPolicyAssociation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (associations != null)
          'associations': associations!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Represents a Firewall Policy resource.
///
/// (== resource_for {$api_version}.firewallPolicies ==)
class FirewallPolicy {
  /// A list of associations that belong to this firewall policy.
  core.List<FirewallPolicyAssociation>? associations;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// User-provided name of the Organization firewall plicy.
  ///
  /// The name should be unique in the organization in which the firewall policy
  /// is created. The name must be 1-63 characters long, and comply with
  /// RFC1035. Specifically, the name must be 1-63 characters long and match the
  /// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
  /// character must be a lowercase letter, and all following characters must be
  /// a dash, lowercase letter, or digit, except the last character, which
  /// cannot be a dash.
  core.String? displayName;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make get() request to the firewall policy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#firewallPolicyfor firewall policies
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// It is a numeric ID allocated by GCP which uniquely identifies the Firewall
  /// Policy.
  ///
  /// Output only.
  core.String? name;

  /// The parent of the firewall policy.
  ///
  /// Output only.
  core.String? parent;

  /// Total count of all firewall policy rule tuples.
  ///
  /// A firewall policy can not exceed a set number of tuples.
  ///
  /// Output only.
  core.int? ruleTupleCount;

  /// A list of rules that belong to this policy.
  ///
  /// There must always be a default rule (rule with priority 2147483647 and
  /// match "*"). If no rules are provided when creating a firewall policy, a
  /// default rule with action "allow" will be added.
  core.List<FirewallPolicyRule>? rules;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL for this resource with the resource id.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  FirewallPolicy();

  FirewallPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('associations')) {
      associations = (_json['associations'] as core.List)
          .map<FirewallPolicyAssociation>((value) =>
              FirewallPolicyAssociation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('displayName')) {
      displayName = _json['displayName'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('parent')) {
      parent = _json['parent'] as core.String;
    }
    if (_json.containsKey('ruleTupleCount')) {
      ruleTupleCount = _json['ruleTupleCount'] as core.int;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<FirewallPolicyRule>((value) => FirewallPolicyRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('selfLinkWithId')) {
      selfLinkWithId = _json['selfLinkWithId'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (associations != null)
          'associations': associations!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (parent != null) 'parent': parent!,
        if (ruleTupleCount != null) 'ruleTupleCount': ruleTupleCount!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
      };
}

class FirewallPolicyAssociation {
  /// The target that the firewall policy is attached to.
  core.String? attachmentTarget;

  /// The display name of the firewall policy of the association.
  ///
  /// Output only.
  core.String? displayName;

  /// The firewall policy ID of the association.
  ///
  /// Output only.
  core.String? firewallPolicyId;

  /// The name for an association.
  core.String? name;

  FirewallPolicyAssociation();

  FirewallPolicyAssociation.fromJson(core.Map _json) {
    if (_json.containsKey('attachmentTarget')) {
      attachmentTarget = _json['attachmentTarget'] as core.String;
    }
    if (_json.containsKey('displayName')) {
      displayName = _json['displayName'] as core.String;
    }
    if (_json.containsKey('firewallPolicyId')) {
      firewallPolicyId = _json['firewallPolicyId'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (attachmentTarget != null) 'attachmentTarget': attachmentTarget!,
        if (displayName != null) 'displayName': displayName!,
        if (firewallPolicyId != null) 'firewallPolicyId': firewallPolicyId!,
        if (name != null) 'name': name!,
      };
}

class FirewallPolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  FirewallPolicyListWarningData();

  FirewallPolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class FirewallPolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<FirewallPolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  FirewallPolicyListWarning();

  FirewallPolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<FirewallPolicyListWarningData>((value) =>
              FirewallPolicyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class FirewallPolicyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of FirewallPolicy resources.
  core.List<FirewallPolicy>? items;

  /// Type of resource.
  ///
  /// Always compute#firewallPolicyList for listsof FirewallPolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  FirewallPolicyListWarning? warning;

  FirewallPolicyList();

  FirewallPolicyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<FirewallPolicy>((value) => FirewallPolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = FirewallPolicyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class FirewallPolicyRule {
  /// The Action to perform when the client connection triggers the rule.
  ///
  /// Can currently be either "allow" or "deny()" where valid values for status
  /// are 403, 404, and 502.
  core.String? action;

  /// An optional description for this resource.
  core.String? description;

  /// The direction in which this rule applies.
  /// Possible string values are:
  /// - "EGRESS"
  /// - "INGRESS"
  core.String? direction;

  /// Denotes whether the firewall policy rule is disabled.
  ///
  /// When set to true, the firewall policy rule is not enforced and traffic
  /// behaves as if it did not exist. If this is unspecified, the firewall
  /// policy rule will be enabled.
  core.bool? disabled;

  /// Denotes whether to enable logging for a particular rule.
  ///
  /// If logging is enabled, logs will be exported to the configured export
  /// destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub.
  /// Note: you cannot enable logging on "goto_next" rules.
  core.bool? enableLogging;

  /// Type of the resource.
  ///
  /// Always compute#firewallPolicyRule for firewall policy rules
  ///
  /// Output only.
  core.String? kind;

  /// A match condition that incoming traffic is evaluated against.
  ///
  /// If it evaluates to true, the corresponding 'action' is enforced.
  FirewallPolicyRuleMatcher? match;

  /// An integer indicating the priority of a rule in the list.
  ///
  /// The priority must be a positive value between 0 and 2147483647. Rules are
  /// evaluated from highest to lowest priority where 0 is the highest priority
  /// and 2147483647 is the lowest prority.
  core.int? priority;

  /// Calculation of the complexity of a single firewall policy rule.
  ///
  /// Output only.
  core.int? ruleTupleCount;

  /// A list of network resource URLs to which this rule applies.
  ///
  /// This field allows you to control which network's VMs get this rule. If
  /// this field is left blank, all VMs within the organization will receive the
  /// rule.
  core.List<core.String>? targetResources;

  /// A list of secure labels that controls which instances the firewall rule
  /// applies to.
  ///
  /// If targetSecureLabel are specified, then the firewall rule applies only to
  /// instances in the VPC network that have one of those secure labels.
  /// targetSecureLabel may not be set at the same time as
  /// targetServiceAccounts. If neither targetServiceAccounts nor
  /// targetSecureLabel are specified, the firewall rule applies to all
  /// instances on the specified network. Maximum number of target label values
  /// allowed is 256.
  core.List<core.String>? targetSecureLabels;

  /// A list of service accounts indicating the sets of instances that are
  /// applied with this rule.
  core.List<core.String>? targetServiceAccounts;

  FirewallPolicyRule();

  FirewallPolicyRule.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('direction')) {
      direction = _json['direction'] as core.String;
    }
    if (_json.containsKey('disabled')) {
      disabled = _json['disabled'] as core.bool;
    }
    if (_json.containsKey('enableLogging')) {
      enableLogging = _json['enableLogging'] as core.bool;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('match')) {
      match = FirewallPolicyRuleMatcher.fromJson(
          _json['match'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('ruleTupleCount')) {
      ruleTupleCount = _json['ruleTupleCount'] as core.int;
    }
    if (_json.containsKey('targetResources')) {
      targetResources = (_json['targetResources'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetSecureLabels')) {
      targetSecureLabels = (_json['targetSecureLabels'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetServiceAccounts')) {
      targetServiceAccounts = (_json['targetServiceAccounts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (description != null) 'description': description!,
        if (direction != null) 'direction': direction!,
        if (disabled != null) 'disabled': disabled!,
        if (enableLogging != null) 'enableLogging': enableLogging!,
        if (kind != null) 'kind': kind!,
        if (match != null) 'match': match!.toJson(),
        if (priority != null) 'priority': priority!,
        if (ruleTupleCount != null) 'ruleTupleCount': ruleTupleCount!,
        if (targetResources != null) 'targetResources': targetResources!,
        if (targetSecureLabels != null)
          'targetSecureLabels': targetSecureLabels!,
        if (targetServiceAccounts != null)
          'targetServiceAccounts': targetServiceAccounts!,
      };
}

/// Represents a match condition that incoming traffic is evaluated against.
///
/// Exactly one field must be specified.
class FirewallPolicyRuleMatcher {
  /// CIDR IP address range.
  ///
  /// Maximum number of destination CIDR IP ranges allowed is 256.
  core.List<core.String>? destIpRanges;

  /// Pairs of IP protocols and ports that the rule should match.
  core.List<FirewallPolicyRuleMatcherLayer4Config>? layer4Configs;

  /// CIDR IP address range.
  ///
  /// Maximum number of source CIDR IP ranges allowed is 256.
  core.List<core.String>? srcIpRanges;

  /// List of firewall label values, which should be matched at the source of
  /// the traffic.
  ///
  /// Maximum number of source label values allowed is 256.
  core.List<core.String>? srcSecureLabels;

  FirewallPolicyRuleMatcher();

  FirewallPolicyRuleMatcher.fromJson(core.Map _json) {
    if (_json.containsKey('destIpRanges')) {
      destIpRanges = (_json['destIpRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('layer4Configs')) {
      layer4Configs = (_json['layer4Configs'] as core.List)
          .map<FirewallPolicyRuleMatcherLayer4Config>((value) =>
              FirewallPolicyRuleMatcherLayer4Config.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('srcIpRanges')) {
      srcIpRanges = (_json['srcIpRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('srcSecureLabels')) {
      srcSecureLabels = (_json['srcSecureLabels'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (destIpRanges != null) 'destIpRanges': destIpRanges!,
        if (layer4Configs != null)
          'layer4Configs':
              layer4Configs!.map((value) => value.toJson()).toList(),
        if (srcIpRanges != null) 'srcIpRanges': srcIpRanges!,
        if (srcSecureLabels != null) 'srcSecureLabels': srcSecureLabels!,
      };
}

class FirewallPolicyRuleMatcherLayer4Config {
  /// The IP protocol to which this rule applies.
  ///
  /// The protocol type is required when creating a firewall rule. This value
  /// can either be one of the following well known protocol strings (tcp, udp,
  /// icmp, esp, ah, ipip, sctp), or the IP protocol number.
  core.String? ipProtocol;

  /// An optional list of ports to which this rule applies.
  ///
  /// This field is only applicable for UDP or TCP protocol. Each entry must be
  /// either an integer or a range. If not specified, this rule applies to
  /// connections through any port.
  ///
  /// Example inputs include: \["22"\], \["80","443"\], and \["12345-12349"\].
  core.List<core.String>? ports;

  FirewallPolicyRuleMatcherLayer4Config();

  FirewallPolicyRuleMatcherLayer4Config.fromJson(core.Map _json) {
    if (_json.containsKey('ipProtocol')) {
      ipProtocol = _json['ipProtocol'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipProtocol != null) 'ipProtocol': ipProtocol!,
        if (ports != null) 'ports': ports!,
      };
}

/// Encapsulates numeric value that can be either absolute or relative.
class FixedOrPercent {
  /// Absolute value of VM instances calculated based on the specific mode.
  ///
  ///
  /// - If the value is fixed, then the calculated value is equal to the fixed
  /// value.
  ///
  ///
  /// - If the value is a percent, then the calculated value is percent/100 *
  /// targetSize. For example, the calculated value of a 80% of a managed
  /// instance group with 150 instances would be (80/100 * 150) = 120 VM
  /// instances. If there is a remainder, the number is rounded up.
  ///
  /// Output only.
  core.int? calculated;

  /// Specifies a fixed number of VM instances.
  ///
  /// This must be a positive integer.
  core.int? fixed;

  /// Specifies a percentage of instances between 0 to 100%, inclusive.
  ///
  /// For example, specify 80 for 80%.
  core.int? percent;

  FixedOrPercent();

  FixedOrPercent.fromJson(core.Map _json) {
    if (_json.containsKey('calculated')) {
      calculated = _json['calculated'] as core.int;
    }
    if (_json.containsKey('fixed')) {
      fixed = _json['fixed'] as core.int;
    }
    if (_json.containsKey('percent')) {
      percent = _json['percent'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (calculated != null) 'calculated': calculated!,
        if (fixed != null) 'fixed': fixed!,
        if (percent != null) 'percent': percent!,
      };
}

/// Represents a Forwarding Rule resource.
///
/// Forwarding rule resources in GCP can be either regional or global in scope:
///
/// *
/// \[Global\](/compute/docs/reference/rest/{$api_version}/globalForwardingRules)
/// * \[Regional\](/compute/docs/reference/rest/{$api_version}/forwardingRules)
///
/// A forwarding rule and its corresponding IP address represent the frontend
/// configuration of a Google Cloud Platform load balancer.
///
/// Forwarding rules can also reference target instances and Cloud VPN Classic
/// gateways (targetVpnGateway).
///
/// For more information, read Forwarding rule concepts and Using protocol
/// forwarding.
///
/// (== resource_for {$api_version}.forwardingRules ==) (== resource_for
/// {$api_version}.globalForwardingRules ==) (== resource_for
/// {$api_version}.regionForwardingRules ==)
class ForwardingRule {
  /// IP address that this forwarding rule serves.
  ///
  /// When a client sends traffic to this IP address, the forwarding rule
  /// directs the traffic to the target that you specify in the forwarding rule.
  ///
  /// If you don't specify a reserved IP address, an ephemeral IP address is
  /// assigned. Methods for specifying an IP address:
  ///
  /// * IPv4 dotted decimal, as in `100.1.2.3` * Full URL, as in
  /// https://www.googleapis.com/compute/v1/projects/project_id/regions/region/addresses/address-name
  /// * Partial URL or by name, as in:
  /// - projects/project_id/regions/region/addresses/address-name
  /// - regions/region/addresses/address-name
  /// - global/addresses/address-name
  /// - address-name
  ///
  /// The loadBalancingScheme and the forwarding rule's target determine the
  /// type of IP address that you can use. For detailed information, refer to
  /// \[IP address
  /// specifications\](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  ///
  /// Must be set to `0.0.0.0` when the target is targetGrpcProxy that has
  /// validateForProxyless field set to true.
  core.String? IPAddress;

  /// The IP protocol to which this rule applies.
  ///
  /// For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP and
  /// ICMP.
  ///
  /// The valid IP protocols are different for different load balancing
  /// products:
  /// - Internal TCP/UDP Load Balancing: The load balancing scheme is INTERNAL,
  /// and one of TCP, UDP or ALL is valid.
  ///
  ///
  /// - Traffic Director: The load balancing scheme is INTERNAL_SELF_MANAGED,
  /// and only TCP is valid.
  /// - Internal HTTP(S) Load Balancing: The load balancing scheme is
  /// INTERNAL_MANAGED, and only TCP is valid.
  /// - HTTP(S), SSL Proxy, and TCP Proxy Load Balancing: The load balancing
  /// scheme is EXTERNAL and only TCP is valid.
  /// - Network Load Balancing: The load balancing scheme is EXTERNAL, and one
  /// of TCP or UDP is valid.
  /// Possible string values are:
  /// - "AH"
  /// - "ESP"
  /// - "ICMP"
  /// - "SCTP"
  /// - "TCP"
  /// - "UDP"
  core.String? IPProtocol;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance.
  ///
  /// This field cannot be used with port or portRange fields.
  ///
  /// When the load balancing scheme is INTERNAL and protocol is TCP/UDP,
  /// specify this field to allow packets addressed to any ports will be
  /// forwarded to the backends configured with this forwarding rule.
  core.bool? allPorts;

  /// This field is used along with the backend_service field for internal load
  /// balancing or with the target field for internal TargetInstance.
  ///
  /// If the field is set to TRUE, clients can access ILB from all regions.
  /// Otherwise only allows access from clients in the same region as the
  /// internal load balancer.
  core.bool? allowGlobalAccess;

  /// Identifies the backend service to which the forwarding rule sends traffic.
  ///
  /// Required for Internal TCP/UDP Load Balancing and Network Load Balancing;
  /// must be omitted for all other load balancer types.
  core.String? backendService;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// ForwardingRule. Include the fingerprint in patch request to ensure that
  /// you do not overwrite changes that were applied from another concurrent
  /// request.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// ForwardingRule.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The IP Version that will be used by this forwarding rule.
  ///
  /// Valid options are IPV4 or IPV6. This can only be specified for an external
  /// global forwarding rule.
  /// Possible string values are:
  /// - "IPV4"
  /// - "IPV6"
  /// - "UNSPECIFIED_VERSION"
  core.String? ipVersion;

  /// Indicates whether or not this load balancer can be used as a collector for
  /// packet mirroring.
  ///
  /// To prevent mirroring loops, instances behind this load balancer will not
  /// have their traffic mirrored even if a PacketMirroring rule applies to
  /// them. This can only be set to true for load balancers that have their
  /// loadBalancingScheme set to INTERNAL.
  core.bool? isMirroringCollector;

  /// Type of the resource.
  ///
  /// Always compute#forwardingRule for Forwarding Rule resources.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this resource, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// ForwardingRule.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Specifies the forwarding rule type.
  ///
  ///
  /// - EXTERNAL is used for:
  /// - Classic Cloud VPN gateways
  /// - Protocol forwarding to VMs from an external IP address
  /// - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing
  /// - INTERNAL is used for:
  /// - Protocol forwarding to VMs from an internal IP address
  /// - Internal TCP/UDP Load Balancing
  /// - INTERNAL_MANAGED is used for:
  /// - Internal HTTP(S) Load Balancing
  /// - INTERNAL_SELF_MANAGED is used for:
  /// - Traffic Director
  ///
  /// For more information about forwarding rules, refer to Forwarding rule
  /// concepts.
  /// Possible string values are:
  /// - "EXTERNAL"
  /// - "INTERNAL"
  /// - "INTERNAL_MANAGED"
  /// - "INTERNAL_SELF_MANAGED"
  /// - "INVALID"
  core.String? loadBalancingScheme;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients.
  ///
  /// In their xDS requests to Loadbalancer, xDS clients present node metadata.
  /// When there is a match, the relevant configuration is made available to
  /// those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap)
  /// referenced by the ForwardingRule will not be visible to those proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata. If multiple metadataFilters are
  /// specified, all of them need to be satisfied in order to be considered a
  /// match.
  /// metadataFilters specified here will be applifed before those specified in
  /// the UrlMap that this ForwardingRule references.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.List<MetadataFilter>? metadataFilters;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// This field is not used for external load balancing.
  ///
  /// For Internal TCP/UDP Load Balancing, this field identifies the network
  /// that the load balanced IP should belong to for this Forwarding Rule.
  ///
  /// If this field is not specified, the default network will be used.
  core.String? network;

  /// This signifies the networking tier used for configuring this load balancer
  /// and can only take the following values: PREMIUM, STANDARD.
  ///
  /// For regional ForwardingRule, the valid values are PREMIUM and STANDARD.
  ///
  /// For GlobalForwardingRule, the valid value is PREMIUM.
  ///
  /// If this field is not specified, it is assumed to be PREMIUM. If IPAddress
  /// is specified, this value must be equal to the networkTier of the Address.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? networkTier;

  /// This field can be used only if: * Load balancing scheme is one of
  /// EXTERNAL, INTERNAL_SELF_MANAGED or INTERNAL_MANAGED, and * IPProtocol is
  /// one of TCP, UDP, or SCTP.
  ///
  /// Packets addressed to ports in the specified range will be forwarded to
  /// target or backend_service.
  ///
  /// You can only use one of ports, port_range, or allPorts. The three are
  /// mutually exclusive. Forwarding rules with the same \[IPAddress,
  /// IPProtocol\] pair must have disjoint port ranges.
  ///
  /// Some types of forwarding target have constraints on the acceptable ports:
  /// - TargetHttpProxy: 80, 8080
  /// - TargetHttpsProxy: 443
  /// - TargetGrpcProxy: no constraints
  /// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993, 995,
  /// 1688, 1883, 5222
  /// - TargetVpnGateway: 500, 4500
  core.String? portRange;

  /// The ports field is only supported when the forwarding rule references a
  /// backend_service directly.
  ///
  /// Supported load balancing products are Internal TCP/UDP Load Balancing and
  /// Network Load Balancing. Only packets addressed to the specified list of
  /// ports are forwarded to backends.
  ///
  /// You can only use one of ports and port_range, or allPorts. The three are
  /// mutually exclusive.
  ///
  /// You can specify a list of up to five ports, which can be non-contiguous.
  ///
  /// For Internal TCP/UDP Load Balancing, if you specify allPorts, you should
  /// not specify ports.
  ///
  /// For more information, see \[Port
  /// specifications\](/load-balancing/docs/forwarding-rule-concepts#port_specifications).
  core.List<core.String>? ports;

  /// The PSC connection id of the PSC Forwarding Rule.
  ///
  /// Output only.
  core.String? pscConnectionId;

  /// URL of the region where the regional forwarding rule resides.
  ///
  /// This field is not applicable to global forwarding rules. You must specify
  /// this field as part of the HTTP request URL. It is not settable as a field
  /// in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Service Directory resources to register this forwarding rule with.
  ///
  /// Currently, only supports a single Service Directory resource.
  ///
  /// It is only supported for Internal TCP/UDP Load Balancing and Internal
  /// HTTP(S) Load Balancing.
  core.List<ForwardingRuleServiceDirectoryRegistration>?
      serviceDirectoryRegistrations;

  /// An optional prefix to the service name for this Forwarding Rule.
  ///
  /// If specified, the prefix is the first label of the fully qualified service
  /// name.
  ///
  /// The label must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the label must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  ///
  /// This field is only used for internal load balancing.
  core.String? serviceLabel;

  /// The internal fully qualified service name for this Forwarding Rule.
  ///
  /// This field is only used for internal load balancing.
  ///
  /// Output only.
  core.String? serviceName;

  /// This field is only used for internal load balancing.
  ///
  /// For internal load balancing, this field identifies the subnetwork that the
  /// load balanced IP should belong to for this Forwarding Rule.
  ///
  /// If the network specified is in auto subnet mode, this field is optional.
  ///
  /// However, if the network is in custom subnet mode, a subnetwork must be
  /// specified.
  core.String? subnetwork;

  /// The URL of the target resource to receive the matched traffic.
  ///
  /// For regional forwarding rules, this target must be in the same region as
  /// the forwarding rule. For global forwarding rules, this target must be a
  /// global load balancing resource. The forwarded traffic must be of a type
  /// appropriate to the target object. For more information, see the "Target"
  /// column in \[Port
  /// specifications\](/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications).
  core.String? target;

  ForwardingRule();

  ForwardingRule.fromJson(core.Map _json) {
    if (_json.containsKey('IPAddress')) {
      IPAddress = _json['IPAddress'] as core.String;
    }
    if (_json.containsKey('IPProtocol')) {
      IPProtocol = _json['IPProtocol'] as core.String;
    }
    if (_json.containsKey('allPorts')) {
      allPorts = _json['allPorts'] as core.bool;
    }
    if (_json.containsKey('allowGlobalAccess')) {
      allowGlobalAccess = _json['allowGlobalAccess'] as core.bool;
    }
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipVersion')) {
      ipVersion = _json['ipVersion'] as core.String;
    }
    if (_json.containsKey('isMirroringCollector')) {
      isMirroringCollector = _json['isMirroringCollector'] as core.bool;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('loadBalancingScheme')) {
      loadBalancingScheme = _json['loadBalancingScheme'] as core.String;
    }
    if (_json.containsKey('metadataFilters')) {
      metadataFilters = (_json['metadataFilters'] as core.List)
          .map<MetadataFilter>((value) => MetadataFilter.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
    if (_json.containsKey('portRange')) {
      portRange = _json['portRange'] as core.String;
    }
    if (_json.containsKey('ports')) {
      ports = (_json['ports'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('pscConnectionId')) {
      pscConnectionId = _json['pscConnectionId'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serviceDirectoryRegistrations')) {
      serviceDirectoryRegistrations =
          (_json['serviceDirectoryRegistrations'] as core.List)
              .map<ForwardingRuleServiceDirectoryRegistration>((value) =>
                  ForwardingRuleServiceDirectoryRegistration.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList();
    }
    if (_json.containsKey('serviceLabel')) {
      serviceLabel = _json['serviceLabel'] as core.String;
    }
    if (_json.containsKey('serviceName')) {
      serviceName = _json['serviceName'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPAddress != null) 'IPAddress': IPAddress!,
        if (IPProtocol != null) 'IPProtocol': IPProtocol!,
        if (allPorts != null) 'allPorts': allPorts!,
        if (allowGlobalAccess != null) 'allowGlobalAccess': allowGlobalAccess!,
        if (backendService != null) 'backendService': backendService!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (ipVersion != null) 'ipVersion': ipVersion!,
        if (isMirroringCollector != null)
          'isMirroringCollector': isMirroringCollector!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (loadBalancingScheme != null)
          'loadBalancingScheme': loadBalancingScheme!,
        if (metadataFilters != null)
          'metadataFilters':
              metadataFilters!.map((value) => value.toJson()).toList(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkTier != null) 'networkTier': networkTier!,
        if (portRange != null) 'portRange': portRange!,
        if (ports != null) 'ports': ports!,
        if (pscConnectionId != null) 'pscConnectionId': pscConnectionId!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serviceDirectoryRegistrations != null)
          'serviceDirectoryRegistrations': serviceDirectoryRegistrations!
              .map((value) => value.toJson())
              .toList(),
        if (serviceLabel != null) 'serviceLabel': serviceLabel!,
        if (serviceName != null) 'serviceName': serviceName!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (target != null) 'target': target!,
      };
}

class ForwardingRuleAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRuleAggregatedListWarningData();

  ForwardingRuleAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ForwardingRuleAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRuleAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRuleAggregatedListWarning();

  ForwardingRuleAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRuleAggregatedListWarningData>((value) =>
              ForwardingRuleAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ForwardingRuleAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ForwardingRulesScopedList resources.
  core.Map<core.String, ForwardingRulesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#forwardingRuleAggregatedList for lists of forwarding rules.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ForwardingRuleAggregatedListWarning? warning;

  ForwardingRuleAggregatedList();

  ForwardingRuleAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          ForwardingRulesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRuleAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ForwardingRuleListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRuleListWarningData();

  ForwardingRuleListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ForwardingRuleListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRuleListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRuleListWarning();

  ForwardingRuleListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRuleListWarningData>((value) =>
              ForwardingRuleListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of ForwardingRule resources.
class ForwardingRuleList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ForwardingRule resources.
  core.List<ForwardingRule>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ForwardingRuleListWarning? warning;

  ForwardingRuleList();

  ForwardingRuleList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ForwardingRule>((value) => ForwardingRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRuleListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ForwardingRuleReference {
  core.String? forwardingRule;

  ForwardingRuleReference();

  ForwardingRuleReference.fromJson(core.Map _json) {
    if (_json.containsKey('forwardingRule')) {
      forwardingRule = _json['forwardingRule'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (forwardingRule != null) 'forwardingRule': forwardingRule!,
      };
}

/// Describes the auto-registration of the Forwarding Rule to Service Directory.
///
/// The region and project of the Service Directory resource generated from this
/// registration will be the same as this Forwarding Rule.
class ForwardingRuleServiceDirectoryRegistration {
  /// Service Directory namespace to register the forwarding rule under.
  core.String? namespace;

  /// Service Directory service to register the forwarding rule under.
  core.String? service;

  /// Service Directory region to register this global forwarding rule under.
  ///
  /// Default to "us-central1". Only used for PSC for Google APIs. All PSC for
  /// Google APIs Forwarding Rules on the same network should use the same
  /// Service Directory region.
  ///
  /// Optional.
  core.String? serviceDirectoryRegion;

  ForwardingRuleServiceDirectoryRegistration();

  ForwardingRuleServiceDirectoryRegistration.fromJson(core.Map _json) {
    if (_json.containsKey('namespace')) {
      namespace = _json['namespace'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('serviceDirectoryRegion')) {
      serviceDirectoryRegion = _json['serviceDirectoryRegion'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (namespace != null) 'namespace': namespace!,
        if (service != null) 'service': service!,
        if (serviceDirectoryRegion != null)
          'serviceDirectoryRegion': serviceDirectoryRegion!,
      };
}

class ForwardingRulesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ForwardingRulesScopedListWarningData();

  ForwardingRulesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of forwarding rules when the
/// list is empty.
class ForwardingRulesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ForwardingRulesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ForwardingRulesScopedListWarning();

  ForwardingRulesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ForwardingRulesScopedListWarningData>((value) =>
              ForwardingRulesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ForwardingRulesScopedList {
  /// A list of forwarding rules contained in this scope.
  core.List<ForwardingRule>? forwardingRules;

  /// Informational warning which replaces the list of forwarding rules when the
  /// list is empty.
  ForwardingRulesScopedListWarning? warning;

  ForwardingRulesScopedList();

  ForwardingRulesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('forwardingRules')) {
      forwardingRules = (_json['forwardingRules'] as core.List)
          .map<ForwardingRule>((value) => ForwardingRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ForwardingRulesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (forwardingRules != null)
          'forwardingRules':
              forwardingRules!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class GRPCHealthCheck {
  /// The gRPC service name for the health check.
  ///
  /// This field is optional. The value of grpc_service_name has the following
  /// meanings by convention:
  /// - Empty service_name means the overall status of all services at the
  /// backend.
  /// - Non-empty service_name means the health of that gRPC service, as defined
  /// by the owner of the service.
  /// The grpc_service_name can only be ASCII.
  core.String? grpcServiceName;

  /// The port number for the health check request.
  ///
  /// Must be specified if port_name and port_specification are not set or if
  /// port_specification is USE_FIXED_PORT. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence. The
  /// port_name should conform to RFC1035.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, gRPC health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  GRPCHealthCheck();

  GRPCHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('grpcServiceName')) {
      grpcServiceName = _json['grpcServiceName'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (grpcServiceName != null) 'grpcServiceName': grpcServiceName!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
      };
}

class GlobalNetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint>? networkEndpoints;

  GlobalNetworkEndpointGroupsAttachEndpointsRequest();

  GlobalNetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class GlobalNetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint>? networkEndpoints;

  GlobalNetworkEndpointGroupsDetachEndpointsRequest();

  GlobalNetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class GlobalOrganizationSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  GlobalOrganizationSetPolicyRequest();

  GlobalOrganizationSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

class GlobalSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash when updating or changing labels, otherwise
  /// the request will fail with error 412 conditionNotMet. Make a get() request
  /// to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of labels to apply for this resource.
  ///
  /// Each label key & value must comply with RFC1035. Specifically, the name
  /// must be 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash. For
  /// example, "webserver-frontend": "images". A label value can also be empty
  /// (e.g. "my-label": "").
  core.Map<core.String, core.String>? labels;

  GlobalSetLabelsRequest();

  GlobalSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class GlobalSetPolicyRequest {
  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  GlobalSetPolicyRequest();

  GlobalSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

/// A guest attributes entry.
class GuestAttributes {
  /// Type of the resource.
  ///
  /// Always compute#guestAttributes for guest attributes entry.
  ///
  /// Output only.
  core.String? kind;

  /// The path to be queried.
  ///
  /// This can be the default namespace ('/') or a nested namespace ('/\/') or a
  /// specified key ('/\/\')
  core.String? queryPath;

  /// The value of the requested queried path.
  ///
  /// Output only.
  GuestAttributesValue? queryValue;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The key to search for.
  core.String? variableKey;

  /// The value found for the requested key.
  ///
  /// Output only.
  core.String? variableValue;

  GuestAttributes();

  GuestAttributes.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('queryPath')) {
      queryPath = _json['queryPath'] as core.String;
    }
    if (_json.containsKey('queryValue')) {
      queryValue = GuestAttributesValue.fromJson(
          _json['queryValue'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('variableKey')) {
      variableKey = _json['variableKey'] as core.String;
    }
    if (_json.containsKey('variableValue')) {
      variableValue = _json['variableValue'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (queryPath != null) 'queryPath': queryPath!,
        if (queryValue != null) 'queryValue': queryValue!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (variableKey != null) 'variableKey': variableKey!,
        if (variableValue != null) 'variableValue': variableValue!,
      };
}

/// A guest attributes namespace/key/value entry.
class GuestAttributesEntry {
  /// Key for the guest attribute entry.
  core.String? key;

  /// Namespace for the guest attribute entry.
  core.String? namespace;

  /// Value for the guest attribute entry.
  core.String? value;

  GuestAttributesEntry();

  GuestAttributesEntry.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('namespace')) {
      namespace = _json['namespace'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (namespace != null) 'namespace': namespace!,
        if (value != null) 'value': value!,
      };
}

/// Array of guest attribute namespace/key/value tuples.
class GuestAttributesValue {
  core.List<GuestAttributesEntry>? items;

  GuestAttributesValue();

  GuestAttributesValue.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<GuestAttributesEntry>((value) => GuestAttributesEntry.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
      };
}

/// Guest OS features.
class GuestOsFeature {
  /// The ID of a supported feature.
  ///
  /// Read Enabling guest operating system features to see a list of available
  /// options.
  /// Possible string values are:
  /// - "FEATURE_TYPE_UNSPECIFIED"
  /// - "GVNIC"
  /// - "MULTI_IP_SUBNET"
  /// - "SECURE_BOOT"
  /// - "SEV_CAPABLE"
  /// - "UEFI_COMPATIBLE"
  /// - "VIRTIO_SCSI_MULTIQUEUE"
  /// - "WINDOWS"
  core.String? type;

  GuestOsFeature();

  GuestOsFeature.fromJson(core.Map _json) {
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (type != null) 'type': type!,
      };
}

class HTTP2HealthCheck {
  /// The value of the host header in the HTTP/2 health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, HTTP2 health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP/2 health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTP2HealthCheck();

  HTTP2HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

class HTTPHealthCheck {
  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, HTTP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTPHealthCheck();

  HTTPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

class HTTPSHealthCheck {
  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the IP on behalf of which this health check
  /// is performed will be used.
  core.String? host;

  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, HTTPS health check follows behavior specified in port
  /// and portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is /.
  core.String? requestPath;

  /// The string to match anywhere in the first 1024 bytes of the response body.
  ///
  /// If left empty (the default value), the status code determines health. The
  /// response data can only be ASCII.
  core.String? response;

  HTTPSHealthCheck();

  HTTPSHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (response != null) 'response': response!,
      };
}

/// Represents a Health Check resource.
///
/// Google Compute Engine has two Health Check resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/healthChecks) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionHealthChecks)
///
/// Internal HTTP(S) load balancers must use regional health checks
/// (`compute.v1.regionHealthChecks`).
///
/// Traffic Director must use global health checks (`compute.v1.HealthChecks`).
///
/// Internal TCP/UDP load balancers can use either regional or global health
/// checks (`compute.v1.regionHealthChecks` or `compute.v1.HealthChecks`).
///
/// External HTTP(S), TCP proxy, and SSL proxy load balancers as well as managed
/// instance group auto-healing must use global health checks
/// (`compute.v1.HealthChecks`).
///
/// Network load balancers must use legacy HTTP health checks
/// (httpHealthChecks).
///
/// For more information, see Health checks overview.
class HealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in 3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  GRPCHealthCheck? grpcHealthCheck;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;
  HTTP2HealthCheck? http2HealthCheck;
  HTTPHealthCheck? httpHealthCheck;
  HTTPSHealthCheck? httpsHealthCheck;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Configure logging on this health check.
  HealthCheckLogConfig? logConfig;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. For example, a name that is 1-63
  /// characters long, matches the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise complies with RFC1035. This
  /// regular expression describes a name where the first character is a
  /// lowercase letter, and all following characters are a dash, lowercase
  /// letter, or digit, except the last character, which isn't a dash.
  core.String? name;

  /// Region where the health check resides.
  ///
  /// Not applicable to global health checks.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;
  SSLHealthCheck? sslHealthCheck;
  TCPHealthCheck? tcpHealthCheck;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or
  /// HTTP2.
  ///
  /// If not specified, the default is TCP. Exactly one of the protocol-specific
  /// health check field must be specified, which must match type field.
  /// Possible string values are:
  /// - "GRPC"
  /// - "HTTP"
  /// - "HTTP2"
  /// - "HTTPS"
  /// - "INVALID"
  /// - "SSL"
  /// - "TCP"
  core.String? type;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HealthCheck();

  HealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('grpcHealthCheck')) {
      grpcHealthCheck = GRPCHealthCheck.fromJson(
          _json['grpcHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('http2HealthCheck')) {
      http2HealthCheck = HTTP2HealthCheck.fromJson(
          _json['http2HealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpHealthCheck')) {
      httpHealthCheck = HTTPHealthCheck.fromJson(
          _json['httpHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpsHealthCheck')) {
      httpsHealthCheck = HTTPSHealthCheck.fromJson(
          _json['httpsHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = HealthCheckLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sslHealthCheck')) {
      sslHealthCheck = SSLHealthCheck.fromJson(
          _json['sslHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tcpHealthCheck')) {
      tcpHealthCheck = TCPHealthCheck.fromJson(
          _json['tcpHealthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (grpcHealthCheck != null)
          'grpcHealthCheck': grpcHealthCheck!.toJson(),
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (http2HealthCheck != null)
          'http2HealthCheck': http2HealthCheck!.toJson(),
        if (httpHealthCheck != null)
          'httpHealthCheck': httpHealthCheck!.toJson(),
        if (httpsHealthCheck != null)
          'httpsHealthCheck': httpsHealthCheck!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sslHealthCheck != null) 'sslHealthCheck': sslHealthCheck!.toJson(),
        if (tcpHealthCheck != null) 'tcpHealthCheck': tcpHealthCheck!.toJson(),
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (type != null) 'type': type!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthCheckListWarningData();

  HealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthCheckListWarning();

  HealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthCheckListWarningData>((value) =>
              HealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HealthCheck resources.
class HealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthCheck resources.
  core.List<HealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HealthCheckListWarning? warning;

  HealthCheckList();

  HealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HealthCheck>((value) => HealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration of logging on a health check.
///
/// If logging is enabled, logs will be exported to Stackdriver.
class HealthCheckLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default, which means no health check logging will be
  /// done.
  core.bool? enable;

  HealthCheckLogConfig();

  HealthCheckLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
      };
}

/// A full or valid partial URL to a health check.
///
/// For example, the following are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check
/// - projects/project-id/global/httpHealthChecks/health-check
/// - global/httpHealthChecks/health-check
class HealthCheckReference {
  core.String? healthCheck;

  HealthCheckReference();

  HealthCheckReference.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheck != null) 'healthCheck': healthCheck!,
      };
}

/// Represents a Health-Check as a Service resource.
///
/// (== resource_for {$api_version}.regionHealthCheckServices ==)
class HealthCheckService {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// HealthCheckService. An up-to-date fingerprint must be provided in order to
  /// patch/update the HealthCheckService; Otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the HealthCheckService.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// List of URLs to the HealthCheck resources.
  ///
  /// Must have at least one HealthCheck, and not more than 10. HealthCheck
  /// resources must have portSpecification=USE_SERVING_PORT. For regional
  /// HealthCheckService, the HealthCheck must be regional and in the same
  /// region. For global HealthCheckService, HealthCheck must be global. Mix of
  /// regional and global HealthChecks is not supported. Multiple regional
  /// HealthChecks must belong to the same region. Regional HealthChecks</code?
  /// must belong to the same region as zones of NEGs.
  core.List<core.String>? healthChecks;

  /// Policy for how the results from multiple health checks for the same
  /// endpoint are aggregated.
  ///
  /// Defaults to NO_AGGREGATION if unspecified.
  /// - NO_AGGREGATION. An EndpointHealth message is returned for each backend
  /// in the health check service.
  /// - AND. If any backend's health check reports UNHEALTHY, then UNHEALTHY is
  /// the HealthState of the entire health check service. If all backend's are
  /// healthy, the HealthState of the health check service is HEALTHY. .
  ///
  /// Optional.
  /// Possible string values are:
  /// - "AND"
  /// - "NO_AGGREGATION"
  core.String? healthStatusAggregationPolicy;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#healthCheckServicefor health check services.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// List of URLs to the NetworkEndpointGroup resources.
  ///
  /// Must not have more than 100. For regional HealthCheckService, NEGs must be
  /// in zones in the region of the HealthCheckService.
  core.List<core.String>? networkEndpointGroups;

  /// List of URLs to the NotificationEndpoint resources.
  ///
  /// Must not have more than 10. A list of endpoints for receiving
  /// notifications of change in health status. For regional HealthCheckService,
  /// NotificationEndpoint must be regional and in the same region. For global
  /// HealthCheckService, NotificationEndpoint must be global.
  core.List<core.String>? notificationEndpoints;

  /// URL of the region where the health check service resides.
  ///
  /// This field is not applicable to global health check services. You must
  /// specify this field as part of the HTTP request URL. It is not settable as
  /// a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  HealthCheckService();

  HealthCheckService.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('healthStatusAggregationPolicy')) {
      healthStatusAggregationPolicy =
          _json['healthStatusAggregationPolicy'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkEndpointGroups')) {
      networkEndpointGroups = (_json['networkEndpointGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('notificationEndpoints')) {
      notificationEndpoints = (_json['notificationEndpoints'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (healthStatusAggregationPolicy != null)
          'healthStatusAggregationPolicy': healthStatusAggregationPolicy!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (networkEndpointGroups != null)
          'networkEndpointGroups': networkEndpointGroups!,
        if (notificationEndpoints != null)
          'notificationEndpoints': notificationEndpoints!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// A full or valid partial URL to a health check service.
///
/// For example, the following are valid URLs:
/// -
/// https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// -
/// projects/project-id/regions/us-west1/healthCheckServices/health-check-service
/// - regions/us-west1/healthCheckServices/health-check-service
class HealthCheckServiceReference {
  core.String? healthCheckService;

  HealthCheckServiceReference();

  HealthCheckServiceReference.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheckService')) {
      healthCheckService = _json['healthCheckService'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheckService != null)
          'healthCheckService': healthCheckService!,
      };
}

class HealthCheckServicesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthCheckServicesListWarningData();

  HealthCheckServicesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthCheckServicesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthCheckServicesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthCheckServicesListWarning();

  HealthCheckServicesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthCheckServicesListWarningData>((value) =>
              HealthCheckServicesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthCheckServicesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthCheckService resources.
  core.List<HealthCheckService>? items;

  /// Type of the resource.
  ///
  /// Always compute#healthCheckServicesList for lists of HealthCheckServices.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HealthCheckServicesListWarning? warning;

  HealthCheckServicesList();

  HealthCheckServicesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HealthCheckService>((value) => HealthCheckService.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HealthCheckServicesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthChecksAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthChecksAggregatedListWarningData();

  HealthChecksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HealthChecksAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthChecksAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthChecksAggregatedListWarning();

  HealthChecksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthChecksAggregatedListWarningData>((value) =>
              HealthChecksAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthChecksAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HealthChecksScopedList resources.
  core.Map<core.String, HealthChecksScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  HealthChecksAggregatedListWarning? warning;

  HealthChecksAggregatedList();

  HealthChecksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          HealthChecksScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = HealthChecksAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthChecksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HealthChecksScopedListWarningData();

  HealthChecksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class HealthChecksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HealthChecksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HealthChecksScopedListWarning();

  HealthChecksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HealthChecksScopedListWarningData>((value) =>
              HealthChecksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class HealthChecksScopedList {
  /// A list of HealthChecks contained in this scope.
  core.List<HealthCheck>? healthChecks;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  HealthChecksScopedListWarning? warning;

  HealthChecksScopedList();

  HealthChecksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheck>((value) => HealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = HealthChecksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class HealthStatus {
  /// Metadata defined as annotations for network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// Health state of the instance.
  /// Possible string values are:
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  core.String? healthState;

  /// URL of the instance resource.
  core.String? instance;

  /// For target pool based Network Load Balancing, it indicates the forwarding
  /// rule's IP address assigned to this instance.
  ///
  /// For other types of load balancing, the field indicates VM internal ip.
  core.String? ipAddress;

  /// The named port of the instance group, not necessarily the port that is
  /// health-checked.
  core.int? port;
  core.String? weight;

  ///
  /// Possible string values are:
  /// - "INVALID_WEIGHT"
  /// - "MISSING_WEIGHT"
  /// - "UNAVAILABLE_WEIGHT"
  /// - "WEIGHT_NONE"
  core.String? weightError;

  HealthStatus();

  HealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations =
          (_json['annotations'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('healthState')) {
      healthState = _json['healthState'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('weight')) {
      weight = _json['weight'] as core.String;
    }
    if (_json.containsKey('weightError')) {
      weightError = _json['weightError'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (healthState != null) 'healthState': healthState!,
        if (instance != null) 'instance': instance!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (port != null) 'port': port!,
        if (weight != null) 'weight': weight!,
        if (weightError != null) 'weightError': weightError!,
      };
}

class HealthStatusForNetworkEndpoint {
  /// URL of the backend service associated with the health state of the network
  /// endpoint.
  BackendServiceReference? backendService;

  /// URL of the forwarding rule associated with the health state of the network
  /// endpoint.
  ForwardingRuleReference? forwardingRule;

  /// URL of the health check associated with the health state of the network
  /// endpoint.
  HealthCheckReference? healthCheck;

  /// URL of the health check service associated with the health state of the
  /// network endpoint.
  HealthCheckServiceReference? healthCheckService;

  /// Health state of the network endpoint determined based on the health checks
  /// configured.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String? healthState;

  HealthStatusForNetworkEndpoint();

  HealthStatusForNetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = BackendServiceReference.fromJson(
          _json['backendService'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('forwardingRule')) {
      forwardingRule = ForwardingRuleReference.fromJson(
          _json['forwardingRule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthCheck')) {
      healthCheck = HealthCheckReference.fromJson(
          _json['healthCheck'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthCheckService')) {
      healthCheckService = HealthCheckServiceReference.fromJson(
          _json['healthCheckService'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('healthState')) {
      healthState = _json['healthState'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!.toJson(),
        if (forwardingRule != null) 'forwardingRule': forwardingRule!.toJson(),
        if (healthCheck != null) 'healthCheck': healthCheck!.toJson(),
        if (healthCheckService != null)
          'healthCheckService': healthCheckService!.toJson(),
        if (healthState != null) 'healthState': healthState!,
      };
}

/// UrlMaps A host-matching rule for a URL.
///
/// If matched, will use the named PathMatcher to select the BackendService.
class HostRule {
  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of host patterns to match.
  ///
  /// They must be valid hostnames with optional port numbers in the format
  /// host:port. * matches any string of (\[a-z0-9-.\]*). In that case, * must
  /// be the first character and must be followed in the pattern by either - or
  /// ..
  /// * based matching is not supported when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  core.List<core.String>? hosts;

  /// The name of the PathMatcher to use to match the path portion of the URL if
  /// the hostRule matches the URL's host portion.
  core.String? pathMatcher;

  HostRule();

  HostRule.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('hosts')) {
      hosts = (_json['hosts'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('pathMatcher')) {
      pathMatcher = _json['pathMatcher'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (hosts != null) 'hosts': hosts!,
        if (pathMatcher != null) 'pathMatcher': pathMatcher!,
      };
}

/// Specification for how requests are aborted as part of fault injection.
class HttpFaultAbort {
  /// The HTTP status code used to abort the request.
  /// The value must be between 200 and 599 inclusive.
  core.int? httpStatus;

  /// The percentage of traffic (connections/operations/requests) which will be
  /// aborted as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double? percentage;

  HttpFaultAbort();

  HttpFaultAbort.fromJson(core.Map _json) {
    if (_json.containsKey('httpStatus')) {
      httpStatus = _json['httpStatus'] as core.int;
    }
    if (_json.containsKey('percentage')) {
      percentage = (_json['percentage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpStatus != null) 'httpStatus': httpStatus!,
        if (percentage != null) 'percentage': percentage!,
      };
}

/// Specifies the delay introduced by Loadbalancer before forwarding the request
/// to the backend service as part of fault injection.
class HttpFaultDelay {
  /// Specifies the value of the fixed delay interval.
  Duration? fixedDelay;

  /// The percentage of traffic (connections/operations/requests) on which delay
  /// will be introduced as part of fault injection.
  /// The value must be between 0.0 and 100.0 inclusive.
  core.double? percentage;

  HttpFaultDelay();

  HttpFaultDelay.fromJson(core.Map _json) {
    if (_json.containsKey('fixedDelay')) {
      fixedDelay = Duration.fromJson(
          _json['fixedDelay'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('percentage')) {
      percentage = (_json['percentage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fixedDelay != null) 'fixedDelay': fixedDelay!.toJson(),
        if (percentage != null) 'percentage': percentage!,
      };
}

/// The specification for fault injection introduced into traffic to test the
/// resiliency of clients to backend service failure.
///
/// As part of fault injection, when clients send requests to a backend service,
/// delays can be introduced by Loadbalancer on a percentage of requests before
/// sending those request to the backend service. Similarly requests from
/// clients can be aborted by the Loadbalancer for a percentage of requests.
class HttpFaultInjection {
  /// The specification for how client requests are aborted as part of fault
  /// injection.
  HttpFaultAbort? abort;

  /// The specification for how client requests are delayed as part of fault
  /// injection, before being sent to a backend service.
  HttpFaultDelay? delay;

  HttpFaultInjection();

  HttpFaultInjection.fromJson(core.Map _json) {
    if (_json.containsKey('abort')) {
      abort = HttpFaultAbort.fromJson(
          _json['abort'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('delay')) {
      delay = HttpFaultDelay.fromJson(
          _json['delay'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (abort != null) 'abort': abort!.toJson(),
        if (delay != null) 'delay': delay!.toJson(),
      };
}

/// The request and response header transformations that take effect before the
/// request is passed along to the selected backendService.
class HttpHeaderAction {
  /// Headers to add to a matching request prior to forwarding the request to
  /// the backendService.
  core.List<HttpHeaderOption>? requestHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// request prior to forwarding the request to the backendService.
  core.List<core.String>? requestHeadersToRemove;

  /// Headers to add the response prior to sending the response back to the
  /// client.
  core.List<HttpHeaderOption>? responseHeadersToAdd;

  /// A list of header names for headers that need to be removed from the
  /// response prior to sending the response back to the client.
  core.List<core.String>? responseHeadersToRemove;

  HttpHeaderAction();

  HttpHeaderAction.fromJson(core.Map _json) {
    if (_json.containsKey('requestHeadersToAdd')) {
      requestHeadersToAdd = (_json['requestHeadersToAdd'] as core.List)
          .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('requestHeadersToRemove')) {
      requestHeadersToRemove = (_json['requestHeadersToRemove'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('responseHeadersToAdd')) {
      responseHeadersToAdd = (_json['responseHeadersToAdd'] as core.List)
          .map<HttpHeaderOption>((value) => HttpHeaderOption.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('responseHeadersToRemove')) {
      responseHeadersToRemove = (_json['responseHeadersToRemove'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (requestHeadersToAdd != null)
          'requestHeadersToAdd':
              requestHeadersToAdd!.map((value) => value.toJson()).toList(),
        if (requestHeadersToRemove != null)
          'requestHeadersToRemove': requestHeadersToRemove!,
        if (responseHeadersToAdd != null)
          'responseHeadersToAdd':
              responseHeadersToAdd!.map((value) => value.toJson()).toList(),
        if (responseHeadersToRemove != null)
          'responseHeadersToRemove': responseHeadersToRemove!,
      };
}

/// matchRule criteria for request header matches.
class HttpHeaderMatch {
  /// The value should exactly match contents of exactMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? exactMatch;

  /// The name of the HTTP header to match.
  /// For matching against the HTTP request's authority, use a headerMatch with
  /// the header name ":authority".
  /// For matching a request's method, use the headerName ":method".
  /// When the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true, only non-binary user-specified
  /// custom metadata and the \`content-type\` header are supported.
  ///
  /// The following transport-level headers cannot be used in header matching
  /// rules: \`:authority\`, \`:method\`, \`:path\`, \`:scheme\`,
  /// \`user-agent\`, \`accept-encoding\`, \`content-encoding\`,
  /// \`grpc-accept-encoding\`, \`grpc-encoding\`,
  /// \`grpc-previous-rpc-attempts\`, \`grpc-tags-bin\`, \`grpc-timeout\` and
  /// \`grpc-trace-bin.
  core.String? headerName;

  /// If set to false, the headerMatch is considered a match if the match
  /// criteria above are met.
  ///
  /// If set to true, the headerMatch is considered a match if the match
  /// criteria above are NOT met.
  /// The default setting is false.
  core.bool? invertMatch;

  /// The value of the header must start with the contents of prefixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? prefixMatch;

  /// A header with the contents of headerName must exist.
  ///
  /// The match takes place whether or not the request's header has a value.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.bool? presentMatch;

  /// The header value must be an integer and its value must be in the range
  /// specified in rangeMatch.
  ///
  /// If the header does not contain an integer, number or is empty, the match
  /// fails.
  /// For example for a range \[-5, 0\]
  /// - -3 will match.
  /// - 0 will not match.
  /// - 0.25 will not match.
  /// - -3someString will not match.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that rangeMatch is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  Int64RangeMatch? rangeMatch;

  /// The value of the header must match the regular expression specified in
  /// regexMatch.
  ///
  /// For regular expression grammar, please see:
  /// github.com/google/re2/wiki/Syntax
  /// For matching against a port specified in the HTTP request, use a
  /// headerMatch with headerName set to PORT and a regular expression that
  /// satisfies the RFC2616 Host header's port specifier.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  /// The value of the header must end with the contents of suffixMatch.
  /// Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch
  /// or rangeMatch must be set.
  core.String? suffixMatch;

  HttpHeaderMatch();

  HttpHeaderMatch.fromJson(core.Map _json) {
    if (_json.containsKey('exactMatch')) {
      exactMatch = _json['exactMatch'] as core.String;
    }
    if (_json.containsKey('headerName')) {
      headerName = _json['headerName'] as core.String;
    }
    if (_json.containsKey('invertMatch')) {
      invertMatch = _json['invertMatch'] as core.bool;
    }
    if (_json.containsKey('prefixMatch')) {
      prefixMatch = _json['prefixMatch'] as core.String;
    }
    if (_json.containsKey('presentMatch')) {
      presentMatch = _json['presentMatch'] as core.bool;
    }
    if (_json.containsKey('rangeMatch')) {
      rangeMatch = Int64RangeMatch.fromJson(
          _json['rangeMatch'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
    if (_json.containsKey('suffixMatch')) {
      suffixMatch = _json['suffixMatch'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (exactMatch != null) 'exactMatch': exactMatch!,
        if (headerName != null) 'headerName': headerName!,
        if (invertMatch != null) 'invertMatch': invertMatch!,
        if (prefixMatch != null) 'prefixMatch': prefixMatch!,
        if (presentMatch != null) 'presentMatch': presentMatch!,
        if (rangeMatch != null) 'rangeMatch': rangeMatch!.toJson(),
        if (regexMatch != null) 'regexMatch': regexMatch!,
        if (suffixMatch != null) 'suffixMatch': suffixMatch!,
      };
}

/// Specification determining how headers are added to requests or responses.
class HttpHeaderOption {
  /// The name of the header.
  core.String? headerName;

  /// The value of the header to add.
  core.String? headerValue;

  /// If false, headerValue is appended to any values that already exist for the
  /// header.
  ///
  /// If true, headerValue is set for the header, discarding any values that
  /// were set for that header.
  /// The default value is false.
  core.bool? replace;

  HttpHeaderOption();

  HttpHeaderOption.fromJson(core.Map _json) {
    if (_json.containsKey('headerName')) {
      headerName = _json['headerName'] as core.String;
    }
    if (_json.containsKey('headerValue')) {
      headerValue = _json['headerValue'] as core.String;
    }
    if (_json.containsKey('replace')) {
      replace = _json['replace'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (headerName != null) 'headerName': headerName!,
        if (headerValue != null) 'headerValue': headerValue!,
        if (replace != null) 'replace': replace!,
      };
}

/// Represents a legacy HTTP Health Check resource.
///
/// Legacy health checks are required by network load balancers.
///
/// For more information, read Health Check Concepts.
class HttpHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTP health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#httpHealthCheck for HTTP health checks.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTP health check request.
  ///
  /// The default value is 80.
  core.int? port;

  /// The request path of the HTTP health check request.
  ///
  /// The default value is /. This field does not support query parameters.
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HttpHealthCheck();

  HttpHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (host != null) 'host': host!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HttpHealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HttpHealthCheckListWarningData();

  HttpHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HttpHealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HttpHealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HttpHealthCheckListWarning();

  HttpHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HttpHealthCheckListWarningData>((value) =>
              HttpHealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HttpHealthCheck resources.
class HttpHealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HttpHealthCheck resources.
  core.List<HttpHealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HttpHealthCheckListWarning? warning;

  HttpHealthCheckList();

  HttpHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HttpHealthCheck>((value) => HttpHealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HttpHealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// HttpRouteRuleMatch criteria for a request's query parameter.
class HttpQueryParameterMatch {
  /// The queryParameterMatch matches if the value of the parameter exactly
  /// matches the contents of exactMatch.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.String? exactMatch;

  /// The name of the query parameter to match.
  ///
  /// The query parameter must exist in the request, in the absence of which the
  /// request match fails.
  core.String? name;

  /// Specifies that the queryParameterMatch matches if the request contains the
  /// query parameter, irrespective of whether the parameter has a value or not.
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  core.bool? presentMatch;

  /// The queryParameterMatch matches if the value of the parameter matches the
  /// regular expression specified by regexMatch.
  ///
  /// For the regular expression grammar, please see
  /// github.com/google/re2/wiki/Syntax
  /// Only one of presentMatch, exactMatch or regexMatch must be set.
  /// Note that regexMatch only applies when the loadBalancingScheme is set to
  /// INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  HttpQueryParameterMatch();

  HttpQueryParameterMatch.fromJson(core.Map _json) {
    if (_json.containsKey('exactMatch')) {
      exactMatch = _json['exactMatch'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('presentMatch')) {
      presentMatch = _json['presentMatch'] as core.bool;
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (exactMatch != null) 'exactMatch': exactMatch!,
        if (name != null) 'name': name!,
        if (presentMatch != null) 'presentMatch': presentMatch!,
        if (regexMatch != null) 'regexMatch': regexMatch!,
      };
}

/// Specifies settings for an HTTP redirect.
class HttpRedirectAction {
  /// The host that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// The value must be between 1 and 255 characters.
  core.String? hostRedirect;

  /// If set to true, the URL scheme in the redirected request is set to https.
  ///
  /// If set to false, the URL scheme of the redirected request will remain the
  /// same as that of the request.
  /// This must only be set for UrlMaps used in TargetHttpProxys. Setting this
  /// true for TargetHttpsProxy is not permitted.
  /// The default is set to false.
  core.bool? httpsRedirect;

  /// The path that will be used in the redirect response instead of the one
  /// that was supplied in the request.
  /// pathRedirect cannot be supplied together with prefixRedirect.
  ///
  /// Supply one alone or neither. If neither is supplied, the path of the
  /// original request will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String? pathRedirect;

  /// The prefix that replaces the prefixMatch specified in the
  /// HttpRouteRuleMatch, retaining the remaining portion of the URL before
  /// redirecting the request.
  /// prefixRedirect cannot be supplied together with pathRedirect.
  ///
  /// Supply one alone or neither. If neither is supplied, the path of the
  /// original request will be used for the redirect.
  /// The value must be between 1 and 1024 characters.
  core.String? prefixRedirect;

  /// The HTTP Status code to use for this RedirectAction.
  /// Supported values are:
  /// - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to
  /// 301.
  ///
  ///
  /// - FOUND, which corresponds to 302.
  /// - SEE_OTHER which corresponds to 303.
  /// - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request
  /// method will be retained.
  /// - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request
  /// method will be retained.
  /// Possible string values are:
  /// - "FOUND"
  /// - "MOVED_PERMANENTLY_DEFAULT"
  /// - "PERMANENT_REDIRECT"
  /// - "SEE_OTHER"
  /// - "TEMPORARY_REDIRECT"
  core.String? redirectResponseCode;

  /// If set to true, any accompanying query portion of the original URL is
  /// removed prior to redirecting the request.
  ///
  /// If set to false, the query portion of the original URL is retained.
  /// The default is set to false.
  core.bool? stripQuery;

  HttpRedirectAction();

  HttpRedirectAction.fromJson(core.Map _json) {
    if (_json.containsKey('hostRedirect')) {
      hostRedirect = _json['hostRedirect'] as core.String;
    }
    if (_json.containsKey('httpsRedirect')) {
      httpsRedirect = _json['httpsRedirect'] as core.bool;
    }
    if (_json.containsKey('pathRedirect')) {
      pathRedirect = _json['pathRedirect'] as core.String;
    }
    if (_json.containsKey('prefixRedirect')) {
      prefixRedirect = _json['prefixRedirect'] as core.String;
    }
    if (_json.containsKey('redirectResponseCode')) {
      redirectResponseCode = _json['redirectResponseCode'] as core.String;
    }
    if (_json.containsKey('stripQuery')) {
      stripQuery = _json['stripQuery'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (hostRedirect != null) 'hostRedirect': hostRedirect!,
        if (httpsRedirect != null) 'httpsRedirect': httpsRedirect!,
        if (pathRedirect != null) 'pathRedirect': pathRedirect!,
        if (prefixRedirect != null) 'prefixRedirect': prefixRedirect!,
        if (redirectResponseCode != null)
          'redirectResponseCode': redirectResponseCode!,
        if (stripQuery != null) 'stripQuery': stripQuery!,
      };
}

/// The retry policy associates with HttpRouteRule
class HttpRetryPolicy {
  /// Specifies the allowed number retries.
  ///
  /// This number must be > 0. If not specified, defaults to 1.
  core.int? numRetries;

  /// Specifies a non-zero timeout per retry attempt.
  /// If not specified, will use the timeout set in HttpRouteAction.
  ///
  /// If timeout in HttpRouteAction is not set, will use the largest timeout
  /// among all backend services associated with the route.
  Duration? perTryTimeout;

  /// Specfies one or more conditions when this retry rule applies.
  ///
  /// Valid values are:
  /// - 5xx: Loadbalancer will attempt a retry if the backend service responds
  /// with any 5xx response code, or if the backend service does not respond at
  /// all, example: disconnects, reset, read timeout, connection failure, and
  /// refused streams.
  /// - gateway-error: Similar to 5xx, but only applies to response codes 502,
  /// 503 or 504.
  /// -
  /// - connect-failure: Loadbalancer will retry on failures connecting to
  /// backend services, for example due to connection timeouts.
  /// - retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
  /// Currently the only retriable error supported is 409.
  /// - refused-stream:Loadbalancer will retry if the backend service resets the
  /// stream with a REFUSED_STREAM error code. This reset type indicates that it
  /// is safe to retry.
  /// - cancelledLoadbalancer will retry if the gRPC status code in the response
  /// header is set to cancelled
  /// - deadline-exceeded: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to deadline-exceeded
  /// - resource-exhausted: Loadbalancer will retry if the gRPC status code in
  /// the response header is set to resource-exhausted
  /// - unavailable: Loadbalancer will retry if the gRPC status code in the
  /// response header is set to unavailable
  core.List<core.String>? retryConditions;

  HttpRetryPolicy();

  HttpRetryPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('numRetries')) {
      numRetries = _json['numRetries'] as core.int;
    }
    if (_json.containsKey('perTryTimeout')) {
      perTryTimeout = Duration.fromJson(
          _json['perTryTimeout'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryConditions')) {
      retryConditions = (_json['retryConditions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (numRetries != null) 'numRetries': numRetries!,
        if (perTryTimeout != null) 'perTryTimeout': perTryTimeout!.toJson(),
        if (retryConditions != null) 'retryConditions': retryConditions!,
      };
}

class HttpRouteAction {
  /// The specification for allowing client side cross-origin requests.
  ///
  /// Please see W3C Recommendation for Cross Origin Resource Sharing
  /// Not supported when the URL map is bound to target gRPC proxy.
  CorsPolicy? corsPolicy;

  /// The specification for fault injection introduced into traffic to test the
  /// resiliency of clients to backend service failure.
  ///
  /// As part of fault injection, when clients send requests to a backend
  /// service, delays can be introduced by Loadbalancer on a percentage of
  /// requests before sending those request to the backend service. Similarly
  /// requests from clients can be aborted by the Loadbalancer for a percentage
  /// of requests.
  /// timeout and retry_policy will be ignored by clients that are configured
  /// with a fault_injection_policy.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpFaultInjection? faultInjectionPolicy;

  /// Specifies the policy on how requests intended for the route's backends are
  /// shadowed to a separate mirrored backend service.
  ///
  /// Loadbalancer does not wait for responses from the shadow service. Prior to
  /// sending traffic to the shadow service, the host / authority header is
  /// suffixed with -shadow.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  RequestMirrorPolicy? requestMirrorPolicy;

  /// Specifies the retry policy associated with this route.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpRetryPolicy? retryPolicy;

  /// Specifies the timeout for the selected route.
  ///
  /// Timeout is computed from the time the request has been fully processed
  /// (i.e. end-of-stream) up until the response has been completely processed.
  /// Timeout includes all retries.
  /// If not specified, will use the largest timeout among all backend services
  /// associated with the route.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  Duration? timeout;

  /// The spec to modify the URL of the request, prior to forwarding the request
  /// to the matched service.
  /// urlRewrite is the only action supported in UrlMaps for external HTTP(S)
  /// load balancers.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  UrlRewrite? urlRewrite;

  /// A list of weighted backend services to send traffic to when a route match
  /// occurs.
  ///
  /// The weights determine the fraction of traffic that flows to their
  /// corresponding backend service. If all traffic needs to go to a single
  /// backend service, there must be one weightedBackendService with weight set
  /// to a non-zero number.
  /// Once a backendService is identified and before forwarding the request to
  /// the backend service, advanced routing actions such as URL rewrites and
  /// header transformations are applied depending on additional settings
  /// specified in this HttpRouteAction.
  core.List<WeightedBackendService>? weightedBackendServices;

  HttpRouteAction();

  HttpRouteAction.fromJson(core.Map _json) {
    if (_json.containsKey('corsPolicy')) {
      corsPolicy = CorsPolicy.fromJson(
          _json['corsPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('faultInjectionPolicy')) {
      faultInjectionPolicy = HttpFaultInjection.fromJson(
          _json['faultInjectionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('requestMirrorPolicy')) {
      requestMirrorPolicy = RequestMirrorPolicy.fromJson(
          _json['requestMirrorPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryPolicy')) {
      retryPolicy = HttpRetryPolicy.fromJson(
          _json['retryPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timeout')) {
      timeout = Duration.fromJson(
          _json['timeout'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('urlRewrite')) {
      urlRewrite = UrlRewrite.fromJson(
          _json['urlRewrite'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weightedBackendServices')) {
      weightedBackendServices = (_json['weightedBackendServices'] as core.List)
          .map<WeightedBackendService>((value) =>
              WeightedBackendService.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (corsPolicy != null) 'corsPolicy': corsPolicy!.toJson(),
        if (faultInjectionPolicy != null)
          'faultInjectionPolicy': faultInjectionPolicy!.toJson(),
        if (requestMirrorPolicy != null)
          'requestMirrorPolicy': requestMirrorPolicy!.toJson(),
        if (retryPolicy != null) 'retryPolicy': retryPolicy!.toJson(),
        if (timeout != null) 'timeout': timeout!.toJson(),
        if (urlRewrite != null) 'urlRewrite': urlRewrite!.toJson(),
        if (weightedBackendServices != null)
          'weightedBackendServices':
              weightedBackendServices!.map((value) => value.toJson()).toList(),
      };
}

/// An HttpRouteRule specifies how to match an HTTP request and the
/// corresponding routing action that load balancing proxies will perform.
class HttpRouteRule {
  /// The short description conveying the intent of this routeRule.
  /// The description can have a maximum length of 1024 characters.
  core.String? description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here are applied before the matching
  /// pathMatchers\[\].headerAction and after
  /// pathMatchers\[\].routeRules\[\].routeAction.weightedBackendService.backendServiceWeightAction\[\].headerAction
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// The list of criteria for matching attributes of a request to this
  /// routeRule.
  ///
  /// This list has OR semantics: the request matches this routeRule when any of
  /// the matchRules are satisfied. However predicates within a given matchRule
  /// have AND semantics. All predicates within a matchRule must match for the
  /// request to match the rule.
  core.List<HttpRouteRuleMatch>? matchRules;

  /// For routeRules within a given pathMatcher, priority determines the order
  /// in which load balancer will interpret routeRules.
  ///
  /// RouteRules are evaluated in order of priority, from the lowest to highest
  /// number. The priority of a rule decreases as its number increases (1, 2, 3,
  /// N+1). The first rule that matches the request is applied.
  /// You cannot configure two or more routeRules with the same priority.
  /// Priority for each rule must be set to a number between 0 and 2147483647
  /// inclusive.
  /// Priority numbers can have gaps, which enable you to add or remove rules in
  /// the future without affecting the rest of the rules. For example, 1, 2, 3,
  /// 4, 5, 9, 12, 16 is a valid series of priority numbers to which you could
  /// add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future
  /// without any impact on existing rules.
  core.int? priority;

  /// In response to a matching matchRule, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc.
  ///
  /// prior to forwarding the request to the selected backend. If routeAction
  /// specifies any weightedBackendServices, service must not be set. Conversely
  /// if service is set, routeAction cannot contain any weightedBackendServices.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a routeRule's routeAction.
  HttpRouteAction? routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched.
  ///
  /// If routeAction is additionally specified, advanced routing actions like
  /// URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if service is specified, routeAction cannot contain any
  /// weightedBackendService s. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String? service;

  /// When this rule is matched, the request is redirected to a URL specified by
  /// urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? urlRedirect;

  HttpRouteRule();

  HttpRouteRule.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('matchRules')) {
      matchRules = (_json['matchRules'] as core.List)
          .map<HttpRouteRuleMatch>((value) => HttpRouteRuleMatch.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('routeAction')) {
      routeAction = HttpRouteAction.fromJson(
          _json['routeAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlRedirect')) {
      urlRedirect = HttpRedirectAction.fromJson(
          _json['urlRedirect'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (matchRules != null)
          'matchRules': matchRules!.map((value) => value.toJson()).toList(),
        if (priority != null) 'priority': priority!,
        if (routeAction != null) 'routeAction': routeAction!.toJson(),
        if (service != null) 'service': service!,
        if (urlRedirect != null) 'urlRedirect': urlRedirect!.toJson(),
      };
}

/// HttpRouteRuleMatch specifies a set of criteria for matching requests to an
/// HttpRouteRule.
///
/// All specified criteria must be satisfied for a match to occur.
class HttpRouteRuleMatch {
  /// For satisfying the matchRule condition, the path of the request must
  /// exactly match the value specified in fullPathMatch after removing any
  /// query parameters and anchor that may be part of the original URL.
  /// fullPathMatch must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String? fullPathMatch;

  /// Specifies a list of header match criteria, all of which must match
  /// corresponding headers in the request.
  core.List<HttpHeaderMatch>? headerMatches;

  /// Specifies that prefixMatch and fullPathMatch matches are case sensitive.
  /// The default value is false.
  /// ignoreCase must not be used with regexMatch.
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.bool? ignoreCase;

  /// Opaque filter criteria used by Loadbalancer to restrict routing
  /// configuration to a limited set of xDS compliant clients.
  ///
  /// In their xDS requests to Loadbalancer, xDS clients present node metadata.
  /// When there is a match, the relevant routing configuration is made
  /// available to those proxies.
  /// For each metadataFilter in this list, if its filterMatchCriteria is set to
  /// MATCH_ANY, at least one of the filterLabels must match the corresponding
  /// label provided in the metadata. If its filterMatchCriteria is set to
  /// MATCH_ALL, then all of its filterLabels must match with corresponding
  /// labels provided in the metadata. If multiple metadataFilters are
  /// specified, all of them need to be satisfied in order to be considered a
  /// match.
  /// metadataFilters specified here will be applied after those specified in
  /// ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch belongs
  /// to.
  /// metadataFilters only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.List<MetadataFilter>? metadataFilters;

  /// For satisfying the matchRule condition, the request's path must begin with
  /// the specified prefixMatch.
  ///
  /// prefixMatch must begin with a /.
  /// The value must be between 1 and 1024 characters.
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  core.String? prefixMatch;

  /// Specifies a list of query parameter match criteria, all of which must
  /// match corresponding query parameters in the request.
  /// Not supported when the URL map is bound to target gRPC proxy.
  core.List<HttpQueryParameterMatch>? queryParameterMatches;

  /// For satisfying the matchRule condition, the path of the request must
  /// satisfy the regular expression specified in regexMatch after removing any
  /// query parameters and anchor supplied with the original URL.
  ///
  /// For regular expression grammar please see
  /// github.com/google/re2/wiki/Syntax
  /// Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
  /// Note that regexMatch only applies to Loadbalancers that have their
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  core.String? regexMatch;

  HttpRouteRuleMatch();

  HttpRouteRuleMatch.fromJson(core.Map _json) {
    if (_json.containsKey('fullPathMatch')) {
      fullPathMatch = _json['fullPathMatch'] as core.String;
    }
    if (_json.containsKey('headerMatches')) {
      headerMatches = (_json['headerMatches'] as core.List)
          .map<HttpHeaderMatch>((value) => HttpHeaderMatch.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('ignoreCase')) {
      ignoreCase = _json['ignoreCase'] as core.bool;
    }
    if (_json.containsKey('metadataFilters')) {
      metadataFilters = (_json['metadataFilters'] as core.List)
          .map<MetadataFilter>((value) => MetadataFilter.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('prefixMatch')) {
      prefixMatch = _json['prefixMatch'] as core.String;
    }
    if (_json.containsKey('queryParameterMatches')) {
      queryParameterMatches = (_json['queryParameterMatches'] as core.List)
          .map<HttpQueryParameterMatch>((value) =>
              HttpQueryParameterMatch.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('regexMatch')) {
      regexMatch = _json['regexMatch'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fullPathMatch != null) 'fullPathMatch': fullPathMatch!,
        if (headerMatches != null)
          'headerMatches':
              headerMatches!.map((value) => value.toJson()).toList(),
        if (ignoreCase != null) 'ignoreCase': ignoreCase!,
        if (metadataFilters != null)
          'metadataFilters':
              metadataFilters!.map((value) => value.toJson()).toList(),
        if (prefixMatch != null) 'prefixMatch': prefixMatch!,
        if (queryParameterMatches != null)
          'queryParameterMatches':
              queryParameterMatches!.map((value) => value.toJson()).toList(),
        if (regexMatch != null) 'regexMatch': regexMatch!,
      };
}

/// Represents a legacy HTTPS Health Check resource.
///
/// Legacy health checks are required by network load balancers.
///
/// For more information, read Health Check Concepts.
class HttpsHealthCheck {
  /// How often (in seconds) to send a health check.
  ///
  /// The default value is 5 seconds.
  core.int? checkIntervalSec;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A so-far unhealthy instance will be marked healthy after this many
  /// consecutive successes.
  ///
  /// The default value is 2.
  core.int? healthyThreshold;

  /// The value of the host header in the HTTPS health check request.
  ///
  /// If left empty (default value), the public IP on behalf of which this
  /// health check is performed will be used.
  core.String? host;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The TCP port number for the HTTPS health check request.
  ///
  /// The default value is 443.
  core.int? port;

  /// The request path of the HTTPS health check request.
  ///
  /// The default value is "/".
  core.String? requestPath;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// How long (in seconds) to wait before claiming failure.
  ///
  /// The default value is 5 seconds. It is invalid for timeoutSec to have a
  /// greater value than checkIntervalSec.
  core.int? timeoutSec;

  /// A so-far healthy instance will be marked unhealthy after this many
  /// consecutive failures.
  ///
  /// The default value is 2.
  core.int? unhealthyThreshold;

  HttpsHealthCheck();

  HttpsHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('checkIntervalSec')) {
      checkIntervalSec = _json['checkIntervalSec'] as core.int;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('healthyThreshold')) {
      healthyThreshold = _json['healthyThreshold'] as core.int;
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('requestPath')) {
      requestPath = _json['requestPath'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('timeoutSec')) {
      timeoutSec = _json['timeoutSec'] as core.int;
    }
    if (_json.containsKey('unhealthyThreshold')) {
      unhealthyThreshold = _json['unhealthyThreshold'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkIntervalSec != null) 'checkIntervalSec': checkIntervalSec!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (healthyThreshold != null) 'healthyThreshold': healthyThreshold!,
        if (host != null) 'host': host!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
        if (requestPath != null) 'requestPath': requestPath!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (timeoutSec != null) 'timeoutSec': timeoutSec!,
        if (unhealthyThreshold != null)
          'unhealthyThreshold': unhealthyThreshold!,
      };
}

class HttpsHealthCheckListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  HttpsHealthCheckListWarningData();

  HttpsHealthCheckListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class HttpsHealthCheckListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<HttpsHealthCheckListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  HttpsHealthCheckListWarning();

  HttpsHealthCheckListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<HttpsHealthCheckListWarningData>((value) =>
              HttpsHealthCheckListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of HttpsHealthCheck resources.
class HttpsHealthCheckList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of HttpsHealthCheck resources.
  core.List<HttpsHealthCheck>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  HttpsHealthCheckListWarning? warning;

  HttpsHealthCheckList();

  HttpsHealthCheckList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<HttpsHealthCheck>((value) => HttpsHealthCheck.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = HttpsHealthCheckListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The parameters of the raw disk image.
class ImageRawDisk {
  /// The format used to encode and transmit the block device, which should be
  /// TAR.
  ///
  /// This is just a container and transmission format and not a runtime format.
  /// Provided by the client when the disk image is created.
  /// Possible string values are:
  /// - "TAR"
  core.String? containerType;

  /// This field is deprecated.
  ///
  /// An optional SHA1 checksum of the disk image before unpackaging provided by
  /// the client when the disk image is created.
  ///
  /// Deprecated.
  core.String? sha1Checksum;

  /// The full Google Cloud Storage URL where the disk image is stored.
  ///
  /// You must provide either this property or the sourceDisk property but not
  /// both.
  core.String? source;

  ImageRawDisk();

  ImageRawDisk.fromJson(core.Map _json) {
    if (_json.containsKey('containerType')) {
      containerType = _json['containerType'] as core.String;
    }
    if (_json.containsKey('sha1Checksum')) {
      sha1Checksum = _json['sha1Checksum'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerType != null) 'containerType': containerType!,
        if (sha1Checksum != null) 'sha1Checksum': sha1Checksum!,
        if (source != null) 'source': source!,
      };
}

/// Represents an Image resource.
///
/// You can use images to create boot disks for your VM instances.
///
/// For more information, read Images. (== resource_for {$api_version}.images
/// ==)
class Image {
  /// Size of the image tar.gz archive stored in Google Cloud Storage (in
  /// bytes).
  core.String? archiveSizeBytes;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this image.
  DeprecationStatus? deprecated;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Size of the image when restored onto a persistent disk (in GB).
  core.String? diskSizeGb;

  /// The name of the image family to which this image belongs.
  ///
  /// You can create disks by specifying an image family instead of a specific
  /// image name. The image family always returns its latest image that is not
  /// deprecated. The name of the image family must comply with RFC1035.
  core.String? family;

  /// A list of features to enable on the guest operating system.
  ///
  /// Applicable only for bootable images. Read Enabling guest operating system
  /// features to see a list of available options.
  core.List<GuestOsFeature>? guestOsFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Encrypts the image using a customer-supplied encryption key.
  ///
  /// After you encrypt an image with a customer-supplied key, you must provide
  /// the same key if you use the image later (e.g. to create a disk from the
  /// image).
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// disk.
  ///
  /// If you do not provide an encryption key when creating the image, then the
  /// disk will be encrypted using an automatically generated key and you do not
  /// need to provide a key to use the image later.
  CustomerEncryptionKey? imageEncryptionKey;

  /// Type of the resource.
  ///
  /// Always compute#image for images.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this image, which is
  /// essentially a hash of the labels used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an image.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this image.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Integer license codes indicating which licenses are attached to this
  /// image.
  core.List<core.String>? licenseCodes;

  /// Any applicable license URI.
  core.List<core.String>? licenses;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The parameters of the raw disk image.
  ImageRawDisk? rawDisk;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Set the secure boot keys of shielded instance.
  InitialStateConfig? shieldedInstanceInitialState;

  /// URL of the source disk used to create this image.
  ///
  /// This can be a full or valid partial URL. You must provide either this
  /// property or the rawDisk.source property but not both to create an image.
  /// For example, the following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk
  /// - projects/project/zones/zone/disks/disk
  /// - zones/zone/disks/disk
  core.String? sourceDisk;

  /// The customer-supplied encryption key of the source disk.
  ///
  /// Required if the source disk is protected by a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? sourceDiskEncryptionKey;

  /// The ID value of the disk used to create this image.
  ///
  /// This value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given disk name.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// URL of the source image used to create this image.
  ///
  /// In order to create an image, you must provide the full or partial URL of
  /// one of the following:
  /// - The selfLink URL
  /// - This property
  /// - The rawDisk.source URL
  /// - The sourceDisk URL
  core.String? sourceImage;

  /// The customer-supplied encryption key of the source image.
  ///
  /// Required if the source image is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceImageEncryptionKey;

  /// The ID value of the image used to create this image.
  ///
  /// This value may be used to determine whether the image was taken from the
  /// current or a previous instance of a given image name.
  ///
  /// Output only.
  core.String? sourceImageId;

  /// URL of the source snapshot used to create this image.
  ///
  /// In order to create an image, you must provide the full or partial URL of
  /// one of the following:
  /// - The selfLink URL
  /// - This property
  /// - The sourceImage URL
  /// - The rawDisk.source URL
  /// - The sourceDisk URL
  core.String? sourceSnapshot;

  /// The customer-supplied encryption key of the source snapshot.
  ///
  /// Required if the source snapshot is protected by a customer-supplied
  /// encryption key.
  CustomerEncryptionKey? sourceSnapshotEncryptionKey;

  /// The ID value of the snapshot used to create this image.
  ///
  /// This value may be used to determine whether the snapshot was taken from
  /// the current or a previous instance of a given snapshot name.
  ///
  /// Output only.
  core.String? sourceSnapshotId;

  /// The type of the image used to create this disk.
  ///
  /// The default and only value is RAW
  /// Possible string values are:
  /// - "RAW"
  core.String? sourceType;

  /// The status of the image.
  ///
  /// An image can be used to create other resources, such as instances, only
  /// after the image has been successfully created and the status is set to
  /// READY. Possible values are FAILED, PENDING, or READY.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DELETING"
  /// - "FAILED"
  /// - "PENDING"
  /// - "READY"
  core.String? status;

  /// Cloud Storage bucket storage location of the image (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  Image();

  Image.fromJson(core.Map _json) {
    if (_json.containsKey('archiveSizeBytes')) {
      archiveSizeBytes = _json['archiveSizeBytes'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('family')) {
      family = _json['family'] as core.String;
    }
    if (_json.containsKey('guestOsFeatures')) {
      guestOsFeatures = (_json['guestOsFeatures'] as core.List)
          .map<GuestOsFeature>((value) => GuestOsFeature.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('imageEncryptionKey')) {
      imageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['imageEncryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rawDisk')) {
      rawDisk = ImageRawDisk.fromJson(
          _json['rawDisk'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('shieldedInstanceInitialState')) {
      shieldedInstanceInitialState = InitialStateConfig.fromJson(
          _json['shieldedInstanceInitialState']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskEncryptionKey')) {
      sourceDiskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceDiskEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('sourceImage')) {
      sourceImage = _json['sourceImage'] as core.String;
    }
    if (_json.containsKey('sourceImageEncryptionKey')) {
      sourceImageEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceImageEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceImageId')) {
      sourceImageId = _json['sourceImageId'] as core.String;
    }
    if (_json.containsKey('sourceSnapshot')) {
      sourceSnapshot = _json['sourceSnapshot'] as core.String;
    }
    if (_json.containsKey('sourceSnapshotEncryptionKey')) {
      sourceSnapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceSnapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceSnapshotId')) {
      sourceSnapshotId = _json['sourceSnapshotId'] as core.String;
    }
    if (_json.containsKey('sourceType')) {
      sourceType = _json['sourceType'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (archiveSizeBytes != null) 'archiveSizeBytes': archiveSizeBytes!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (family != null) 'family': family!,
        if (guestOsFeatures != null)
          'guestOsFeatures':
              guestOsFeatures!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (imageEncryptionKey != null)
          'imageEncryptionKey': imageEncryptionKey!.toJson(),
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (name != null) 'name': name!,
        if (rawDisk != null) 'rawDisk': rawDisk!.toJson(),
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (shieldedInstanceInitialState != null)
          'shieldedInstanceInitialState':
              shieldedInstanceInitialState!.toJson(),
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskEncryptionKey != null)
          'sourceDiskEncryptionKey': sourceDiskEncryptionKey!.toJson(),
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (sourceImage != null) 'sourceImage': sourceImage!,
        if (sourceImageEncryptionKey != null)
          'sourceImageEncryptionKey': sourceImageEncryptionKey!.toJson(),
        if (sourceImageId != null) 'sourceImageId': sourceImageId!,
        if (sourceSnapshot != null) 'sourceSnapshot': sourceSnapshot!,
        if (sourceSnapshotEncryptionKey != null)
          'sourceSnapshotEncryptionKey': sourceSnapshotEncryptionKey!.toJson(),
        if (sourceSnapshotId != null) 'sourceSnapshotId': sourceSnapshotId!,
        if (sourceType != null) 'sourceType': sourceType!,
        if (status != null) 'status': status!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

class ImageListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ImageListWarningData();

  ImageListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ImageListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ImageListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ImageListWarning();

  ImageListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ImageListWarningData>((value) => ImageListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of images.
class ImageList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Image resources.
  core.List<Image>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ImageListWarning? warning;

  ImageList();

  ImageList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Image>((value) =>
              Image.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ImageListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Initial State for shielded instance, these are public keys which are safe to
/// store in public
class InitialStateConfig {
  /// The Key Database (db).
  core.List<FileContentBuffer>? dbs;

  /// The forbidden key database (dbx).
  core.List<FileContentBuffer>? dbxs;

  /// The Key Exchange Key (KEK).
  core.List<FileContentBuffer>? keks;

  /// The Platform Key (PK).
  FileContentBuffer? pk;

  InitialStateConfig();

  InitialStateConfig.fromJson(core.Map _json) {
    if (_json.containsKey('dbs')) {
      dbs = (_json['dbs'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('dbxs')) {
      dbxs = (_json['dbxs'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('keks')) {
      keks = (_json['keks'] as core.List)
          .map<FileContentBuffer>((value) => FileContentBuffer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('pk')) {
      pk = FileContentBuffer.fromJson(
          _json['pk'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (dbs != null) 'dbs': dbs!.map((value) => value.toJson()).toList(),
        if (dbxs != null) 'dbxs': dbxs!.map((value) => value.toJson()).toList(),
        if (keks != null) 'keks': keks!.map((value) => value.toJson()).toList(),
        if (pk != null) 'pk': pk!.toJson(),
      };
}

/// Represents an Instance resource.
///
/// An instance is a virtual machine that is hosted on Google Cloud Platform.
///
/// For more information, read Virtual Machine Instances. (== resource_for
/// {$api_version}.instances ==)
class Instance {
  /// Controls for advanced machine-related behavior features.
  AdvancedMachineFeatures? advancedMachineFeatures;

  /// Allows this instance to send and receive packets with non-matching
  /// destination or source IPs.
  ///
  /// This is required if you plan to use this instance to forward routes. For
  /// more information, see Enabling IP Forwarding.
  core.bool? canIpForward;
  ConfidentialInstanceConfig? confidentialInstanceConfig;

  /// The CPU platform used by this instance.
  ///
  /// Output only.
  core.String? cpuPlatform;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Whether the resource should be protected against deletion.
  core.bool? deletionProtection;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Array of disks associated with this instance.
  ///
  /// Persistent disks must be created before you can assign them.
  core.List<AttachedDisk>? disks;

  /// Enables display device for the instance.
  DisplayDevice? displayDevice;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the instance's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update the instance. You must always provide an
  /// up-to-date fingerprint hash in order to update the instance.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Specifies the hostname of the instance.
  ///
  /// The specified hostname must be RFC1035 compliant. If hostname is not
  /// specified, the default hostname is
  /// \[INSTANCE_NAME\].c.\[PROJECT_ID\].internal when using the global DNS, and
  /// \[INSTANCE_NAME\].\[ZONE\].c.\[PROJECT_ID\].internal when using zonal DNS.
  core.String? hostname;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#instance for instances.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for this request, which is essentially a hash of the label's
  /// contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this instance.
  ///
  /// These can be later modified by the setLabels method.
  core.Map<core.String, core.String>? labels;

  /// Last start timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStartTimestamp;

  /// Last stop timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastStopTimestamp;

  /// Last suspended timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? lastSuspendedTimestamp;

  /// Full or partial URL of the machine type resource to use for this instance,
  /// in the format: zones/zone/machineTypes/machine-type.
  ///
  /// This is provided by the client when the instance is created. For example,
  /// the following is a valid partial url to a predefined machine type:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  ///
  ///
  /// To create a custom machine type, provide a URL to a machine type in the
  /// following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ...
  /// 24, etc), and MEMORY is the total memory for this instance. Memory must be
  /// a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is
  /// 5120 MB):
  /// zones/zone/machineTypes/custom-CPUS-MEMORY
  ///
  ///
  /// For example: zones/us-central1-f/machineTypes/custom-4-5120
  ///
  /// For a full list of restrictions, read the Specifications for custom
  /// machine types.
  core.String? machineType;

  /// The metadata key/value pairs assigned to this instance.
  ///
  /// This includes custom metadata and predefined keys.
  Metadata? metadata;

  /// Specifies a minimum CPU platform for the VM instance.
  ///
  /// Applicable values are the friendly names of CPU platforms, such as
  /// minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  core.String? minCpuPlatform;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// An array of network configurations for this instance.
  ///
  /// These specify how interfaces are configured to interact with other network
  /// services, such as connecting to the internet. Multiple interfaces are
  /// supported per instance.
  core.List<NetworkInterface>? networkInterfaces;

  /// The private IPv6 google access type for the VM.
  ///
  /// If not specified, use  INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  /// - "INHERIT_FROM_SUBNETWORK"
  core.String? privateIpv6GoogleAccess;

  /// Specifies the reservations that this instance can consume from.
  ReservationAffinity? reservationAffinity;

  /// Resource policies applied to this instance.
  core.List<core.String>? resourcePolicies;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Sets the scheduling options for this instance.
  Scheduling? scheduling;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A list of service accounts, with their specified scopes, authorized for
  /// this instance.
  ///
  /// Only one service account per VM instance is supported.
  ///
  /// Service accounts generate access tokens that can be accessed through the
  /// metadata server and used to authenticate applications on the instance. See
  /// Service Accounts for more information.
  core.List<ServiceAccount>? serviceAccounts;
  ShieldedInstanceConfig? shieldedInstanceConfig;
  ShieldedInstanceIntegrityPolicy? shieldedInstanceIntegrityPolicy;

  /// Whether a VM has been restricted for start because Compute Engine has
  /// detected suspicious activity.
  ///
  /// Output only.
  core.bool? startRestricted;

  /// The status of the instance.
  ///
  /// One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING,
  /// SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information
  /// about the status of the instance, see Instance life cycle.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  /// Tags to apply to this instance.
  ///
  /// Tags are used to identify valid sources or targets for network firewalls
  /// and are specified by the client during instance creation. The tags can be
  /// later modified by the setTags method. Each tag within the list must comply
  /// with RFC1035. Multiple tags can be specified via the 'tags.items' field.
  Tags? tags;

  /// URL of the zone where the instance resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  Instance();

  Instance.fromJson(core.Map _json) {
    if (_json.containsKey('advancedMachineFeatures')) {
      advancedMachineFeatures = AdvancedMachineFeatures.fromJson(
          _json['advancedMachineFeatures']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('canIpForward')) {
      canIpForward = _json['canIpForward'] as core.bool;
    }
    if (_json.containsKey('confidentialInstanceConfig')) {
      confidentialInstanceConfig = ConfidentialInstanceConfig.fromJson(
          _json['confidentialInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cpuPlatform')) {
      cpuPlatform = _json['cpuPlatform'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deletionProtection')) {
      deletionProtection = _json['deletionProtection'] as core.bool;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<AttachedDisk>((value) => AttachedDisk.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('displayDevice')) {
      displayDevice = DisplayDevice.fromJson(
          _json['displayDevice'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('hostname')) {
      hostname = _json['hostname'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('lastStartTimestamp')) {
      lastStartTimestamp = _json['lastStartTimestamp'] as core.String;
    }
    if (_json.containsKey('lastStopTimestamp')) {
      lastStopTimestamp = _json['lastStopTimestamp'] as core.String;
    }
    if (_json.containsKey('lastSuspendedTimestamp')) {
      lastSuspendedTimestamp = _json['lastSuspendedTimestamp'] as core.String;
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('metadata')) {
      metadata = Metadata.fromJson(
          _json['metadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkInterfaces')) {
      networkInterfaces = (_json['networkInterfaces'] as core.List)
          .map<NetworkInterface>((value) => NetworkInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('reservationAffinity')) {
      reservationAffinity = ReservationAffinity.fromJson(
          _json['reservationAffinity'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('scheduling')) {
      scheduling = Scheduling.fromJson(
          _json['scheduling'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serviceAccounts')) {
      serviceAccounts = (_json['serviceAccounts'] as core.List)
          .map<ServiceAccount>((value) => ServiceAccount.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('shieldedInstanceConfig')) {
      shieldedInstanceConfig = ShieldedInstanceConfig.fromJson(
          _json['shieldedInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('shieldedInstanceIntegrityPolicy')) {
      shieldedInstanceIntegrityPolicy =
          ShieldedInstanceIntegrityPolicy.fromJson(
              _json['shieldedInstanceIntegrityPolicy']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('startRestricted')) {
      startRestricted = _json['startRestricted'] as core.bool;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
    if (_json.containsKey('tags')) {
      tags =
          Tags.fromJson(_json['tags'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (advancedMachineFeatures != null)
          'advancedMachineFeatures': advancedMachineFeatures!.toJson(),
        if (canIpForward != null) 'canIpForward': canIpForward!,
        if (confidentialInstanceConfig != null)
          'confidentialInstanceConfig': confidentialInstanceConfig!.toJson(),
        if (cpuPlatform != null) 'cpuPlatform': cpuPlatform!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deletionProtection != null)
          'deletionProtection': deletionProtection!,
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (displayDevice != null) 'displayDevice': displayDevice!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (hostname != null) 'hostname': hostname!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (lastStartTimestamp != null)
          'lastStartTimestamp': lastStartTimestamp!,
        if (lastStopTimestamp != null) 'lastStopTimestamp': lastStopTimestamp!,
        if (lastSuspendedTimestamp != null)
          'lastSuspendedTimestamp': lastSuspendedTimestamp!,
        if (machineType != null) 'machineType': machineType!,
        if (metadata != null) 'metadata': metadata!.toJson(),
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
        if (name != null) 'name': name!,
        if (networkInterfaces != null)
          'networkInterfaces':
              networkInterfaces!.map((value) => value.toJson()).toList(),
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (reservationAffinity != null)
          'reservationAffinity': reservationAffinity!.toJson(),
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (scheduling != null) 'scheduling': scheduling!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (serviceAccounts != null)
          'serviceAccounts':
              serviceAccounts!.map((value) => value.toJson()).toList(),
        if (shieldedInstanceConfig != null)
          'shieldedInstanceConfig': shieldedInstanceConfig!.toJson(),
        if (shieldedInstanceIntegrityPolicy != null)
          'shieldedInstanceIntegrityPolicy':
              shieldedInstanceIntegrityPolicy!.toJson(),
        if (startRestricted != null) 'startRestricted': startRestricted!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
        if (tags != null) 'tags': tags!.toJson(),
        if (zone != null) 'zone': zone!,
      };
}

class InstanceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceAggregatedListWarningData();

  InstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceAggregatedListWarning();

  InstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceAggregatedListWarningData>((value) =>
              InstanceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// An object that contains a list of instances scoped by zone.
  core.Map<core.String, InstancesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceAggregatedList for aggregated lists of Instance
  /// resources.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceAggregatedListWarning? warning;

  InstanceAggregatedList();

  InstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          InstancesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents an Instance Group resource.
///
/// Instance Groups can be used to configure a target for load balancing.
///
/// Instance groups can either be managed or unmanaged.
///
/// To create managed instance groups, use the instanceGroupManager or
/// regionInstanceGroupManager resource instead.
///
/// Use zonal unmanaged instance groups if you need to apply load balancing to
/// groups of heterogeneous instances or if you need to manage the instances
/// yourself.
///
/// You cannot create regional unmanaged instance groups.
///
/// For more information, read Instance groups.
///
/// (== resource_for {$api_version}.instanceGroups ==) (== resource_for
/// {$api_version}.regionInstanceGroups ==)
class InstanceGroup {
  /// The creation timestamp for this instance group in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The fingerprint of the named ports.
  ///
  /// The system uses this fingerprint to detect conflicts when multiple users
  /// change the named ports concurrently.
  ///
  /// Output only.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A unique identifier for this instance group, generated by the server.
  ///
  /// Output only.
  core.String? id;

  /// The resource type, which is always compute#instanceGroup for instance
  /// groups.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the instance group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// Assigns a name to a port number.
  ///
  /// For example: {name: "http", port: 80}
  ///
  /// This allows the system to reference ports by the assigned name instead of
  /// a port number. Named ports can also contain multiple ports. For example:
  /// \[{name: "http", port: 80},{name: "http", port: 8080}\]
  ///
  /// Named ports apply to all instances in this instance group.
  core.List<NamedPort>? namedPorts;

  /// The URL of the network to which all instances in the instance group
  /// belong.
  ///
  /// If your instance has multiple network interfaces, then the network and
  /// subnetwork fields only refer to the network and subnet used by your
  /// primary interface (nic0).
  ///
  /// Output only.
  core.String? network;

  /// The URL of the region where the instance group is located (for regional
  /// resources).
  ///
  /// Output only.
  core.String? region;

  /// The URL for this instance group.
  ///
  /// The server generates this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// The total number of instances in the instance group.
  ///
  /// Output only.
  core.int? size;

  /// The URL of the subnetwork to which all instances in the instance group
  /// belong.
  ///
  /// If your instance has multiple network interfaces, then the network and
  /// subnetwork fields only refer to the network and subnet used by your
  /// primary interface (nic0).
  ///
  /// Output only.
  core.String? subnetwork;

  /// The URL of the zone where the instance group is located (for zonal
  /// resources).
  ///
  /// Output only.
  core.String? zone;

  InstanceGroup();

  InstanceGroup.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (zone != null) 'zone': zone!,
      };
}

class InstanceGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupAggregatedListWarningData();

  InstanceGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupAggregatedListWarning();

  InstanceGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupAggregatedListWarningData>((value) =>
              InstanceGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupsScopedList resources.
  core.Map<core.String, InstanceGroupsScopedList>? items;

  /// The resource type, which is always compute#instanceGroupAggregatedList for
  /// aggregated lists of instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupAggregatedListWarning? warning;

  InstanceGroupAggregatedList();

  InstanceGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          InstanceGroupsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupListWarningData();

  InstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupListWarning();

  InstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupListWarningData>((value) =>
              InstanceGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of InstanceGroup resources.
class InstanceGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup>? items;

  /// The resource type, which is always compute#instanceGroupList for instance
  /// group lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupListWarning? warning;

  InstanceGroupList();

  InstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Managed Instance Group resource.
///
/// An instance group is a collection of VM instances that you can manage as a
/// single entity.
///
/// For more information, read Instance groups.
///
/// For zonal Managed Instance Group, use the instanceGroupManagers resource.
///
/// For regional Managed Instance Group, use the regionInstanceGroupManagers
/// resource. (== resource_for {$api_version}.instanceGroupManagers ==) (==
/// resource_for {$api_version}.regionInstanceGroupManagers ==)
class InstanceGroupManager {
  /// The autohealing policy for this managed instance group.
  ///
  /// You can specify only one value.
  core.List<InstanceGroupManagerAutoHealingPolicy>? autoHealingPolicies;

  /// The base instance name to use for instances in this group.
  ///
  /// The value must be 1-58 characters long. Instances are named by appending a
  /// hyphen and a random four-character string to the base instance name. The
  /// base instance name must comply with RFC1035.
  core.String? baseInstanceName;

  /// The creation timestamp for this managed instance group in RFC3339 text
  /// format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The list of instance actions and the number of instances in this managed
  /// instance group that are scheduled for each of those actions.
  ///
  /// Output only.
  InstanceGroupManagerActionsSummary? currentActions;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Policy specifying the intended distribution of managed instances across
  /// zones in a regional managed instance group.
  DistributionPolicy? distributionPolicy;

  /// Fingerprint of this resource.
  ///
  /// This field may be used in optimistic locking. It will be ignored when
  /// inserting an InstanceGroupManager. An up-to-date fingerprint must be
  /// provided in order to update the InstanceGroupManager, otherwise the
  /// request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// InstanceGroupManager.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A unique identifier for this resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The URL of the Instance Group resource.
  ///
  /// Output only.
  core.String? instanceGroup;

  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create all new instances in the managed
  /// instance group. The templates for existing instances in the group do not
  /// change unless you run recreateInstances, run applyUpdatesToInstances, or
  /// set the group's updatePolicy.type to PROACTIVE.
  core.String? instanceTemplate;

  /// The resource type, which is always compute#instanceGroupManager for
  /// managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the managed instance group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// Named ports configured for the Instance Groups complementary to this
  /// Instance Group Manager.
  core.List<NamedPort>? namedPorts;

  /// The URL of the region where the managed instance group resides (for
  /// regional resources).
  ///
  /// Output only.
  core.String? region;

  /// The URL for this managed instance group.
  ///
  /// The server defines this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// Stateful configuration for this Instanced Group Manager
  StatefulPolicy? statefulPolicy;

  /// The status of this managed instance group.
  ///
  /// Output only.
  InstanceGroupManagerStatus? status;

  /// The URLs for all TargetPool resources to which instances in the
  /// instanceGroup field are added.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group.
  core.List<core.String>? targetPools;

  /// The target number of running instances for this managed instance group.
  ///
  /// You can reduce this number by using the instanceGroupManager
  /// deleteInstances or abandonInstances methods. Resizing the group also
  /// changes this number.
  core.int? targetSize;

  /// The update policy for this managed instance group.
  InstanceGroupManagerUpdatePolicy? updatePolicy;

  /// Specifies the instance templates used by this managed instance group to
  /// create instances.
  ///
  /// Each version is defined by an instanceTemplate and a name.
  ///
  /// Every version can appear at most once per instance group. This field
  /// overrides the top-level instanceTemplate field. Read more about the
  /// relationships between these fields. Exactly one version must leave the
  /// targetSize field unset. That version will be applied to all remaining
  /// instances. For more information, read about canary updates.
  core.List<InstanceGroupManagerVersion>? versions;

  /// The URL of a zone where the managed instance group is located (for zonal
  /// resources).
  ///
  /// Output only.
  core.String? zone;

  InstanceGroupManager();

  InstanceGroupManager.fromJson(core.Map _json) {
    if (_json.containsKey('autoHealingPolicies')) {
      autoHealingPolicies = (_json['autoHealingPolicies'] as core.List)
          .map<InstanceGroupManagerAutoHealingPolicy>((value) =>
              InstanceGroupManagerAutoHealingPolicy.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('baseInstanceName')) {
      baseInstanceName = _json['baseInstanceName'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('currentActions')) {
      currentActions = InstanceGroupManagerActionsSummary.fromJson(
          _json['currentActions'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('distributionPolicy')) {
      distributionPolicy = DistributionPolicy.fromJson(
          _json['distributionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instanceGroup')) {
      instanceGroup = _json['instanceGroup'] as core.String;
    }
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('statefulPolicy')) {
      statefulPolicy = StatefulPolicy.fromJson(
          _json['statefulPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = InstanceGroupManagerStatus.fromJson(
          _json['status'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('targetSize')) {
      targetSize = _json['targetSize'] as core.int;
    }
    if (_json.containsKey('updatePolicy')) {
      updatePolicy = InstanceGroupManagerUpdatePolicy.fromJson(
          _json['updatePolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versions')) {
      versions = (_json['versions'] as core.List)
          .map<InstanceGroupManagerVersion>((value) =>
              InstanceGroupManagerVersion.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoHealingPolicies != null)
          'autoHealingPolicies':
              autoHealingPolicies!.map((value) => value.toJson()).toList(),
        if (baseInstanceName != null) 'baseInstanceName': baseInstanceName!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (currentActions != null) 'currentActions': currentActions!.toJson(),
        if (description != null) 'description': description!,
        if (distributionPolicy != null)
          'distributionPolicy': distributionPolicy!.toJson(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (instanceGroup != null) 'instanceGroup': instanceGroup!,
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (statefulPolicy != null) 'statefulPolicy': statefulPolicy!.toJson(),
        if (status != null) 'status': status!.toJson(),
        if (targetPools != null) 'targetPools': targetPools!,
        if (targetSize != null) 'targetSize': targetSize!,
        if (updatePolicy != null) 'updatePolicy': updatePolicy!.toJson(),
        if (versions != null)
          'versions': versions!.map((value) => value.toJson()).toList(),
        if (zone != null) 'zone': zone!,
      };
}

class InstanceGroupManagerActionsSummary {
  /// The total number of instances in the managed instance group that are
  /// scheduled to be abandoned.
  ///
  /// Abandoning an instance removes it from the managed instance group without
  /// deleting it.
  ///
  /// Output only.
  core.int? abandoning;

  /// The number of instances in the managed instance group that are scheduled
  /// to be created or are currently being created.
  ///
  /// If the group fails to create any of these instances, it tries again until
  /// it creates the instance successfully.
  ///
  /// If you have disabled creation retries, this field will not be populated;
  /// instead, the creatingWithoutRetries field will be populated.
  ///
  /// Output only.
  core.int? creating;

  /// The number of instances that the managed instance group will attempt to
  /// create.
  ///
  /// The group attempts to create each instance only once. If the group fails
  /// to create any of these instances, it decreases the group's targetSize
  /// value accordingly.
  ///
  /// Output only.
  core.int? creatingWithoutRetries;

  /// The number of instances in the managed instance group that are scheduled
  /// to be deleted or are currently being deleted.
  ///
  /// Output only.
  core.int? deleting;

  /// The number of instances in the managed instance group that are running and
  /// have no scheduled actions.
  ///
  /// Output only.
  core.int? none;

  /// The number of instances in the managed instance group that are scheduled
  /// to be recreated or are currently being being recreated.
  ///
  /// Recreating an instance deletes the existing root persistent disk and
  /// creates a new disk from the image that is defined in the instance
  /// template.
  ///
  /// Output only.
  core.int? recreating;

  /// The number of instances in the managed instance group that are being
  /// reconfigured with properties that do not require a restart or a recreate
  /// action.
  ///
  /// For example, setting or removing target pools for the instance.
  ///
  /// Output only.
  core.int? refreshing;

  /// The number of instances in the managed instance group that are scheduled
  /// to be restarted or are currently being restarted.
  ///
  /// Output only.
  core.int? restarting;

  /// The number of instances in the managed instance group that are being
  /// verified.
  ///
  /// See the managedInstances\[\].currentAction property in the
  /// listManagedInstances method documentation.
  ///
  /// Output only.
  core.int? verifying;

  InstanceGroupManagerActionsSummary();

  InstanceGroupManagerActionsSummary.fromJson(core.Map _json) {
    if (_json.containsKey('abandoning')) {
      abandoning = _json['abandoning'] as core.int;
    }
    if (_json.containsKey('creating')) {
      creating = _json['creating'] as core.int;
    }
    if (_json.containsKey('creatingWithoutRetries')) {
      creatingWithoutRetries = _json['creatingWithoutRetries'] as core.int;
    }
    if (_json.containsKey('deleting')) {
      deleting = _json['deleting'] as core.int;
    }
    if (_json.containsKey('none')) {
      none = _json['none'] as core.int;
    }
    if (_json.containsKey('recreating')) {
      recreating = _json['recreating'] as core.int;
    }
    if (_json.containsKey('refreshing')) {
      refreshing = _json['refreshing'] as core.int;
    }
    if (_json.containsKey('restarting')) {
      restarting = _json['restarting'] as core.int;
    }
    if (_json.containsKey('verifying')) {
      verifying = _json['verifying'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (abandoning != null) 'abandoning': abandoning!,
        if (creating != null) 'creating': creating!,
        if (creatingWithoutRetries != null)
          'creatingWithoutRetries': creatingWithoutRetries!,
        if (deleting != null) 'deleting': deleting!,
        if (none != null) 'none': none!,
        if (recreating != null) 'recreating': recreating!,
        if (refreshing != null) 'refreshing': refreshing!,
        if (restarting != null) 'restarting': restarting!,
        if (verifying != null) 'verifying': verifying!,
      };
}

class InstanceGroupManagerAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagerAggregatedListWarningData();

  InstanceGroupManagerAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagerAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagerAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagerAggregatedListWarning();

  InstanceGroupManagerAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagerAggregatedListWarningData>((value) =>
              InstanceGroupManagerAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagerAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManagersScopedList resources.
  core.Map<core.String, InstanceGroupManagersScopedList>? items;

  /// The resource type, which is always
  /// compute#instanceGroupManagerAggregatedList for an aggregated list of
  /// managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagerAggregatedListWarning? warning;

  InstanceGroupManagerAggregatedList();

  InstanceGroupManagerAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          InstanceGroupManagersScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagerAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagerAutoHealingPolicy {
  /// The URL for the health check that signals autohealing.
  core.String? healthCheck;

  /// The number of seconds that the managed instance group waits before it
  /// applies autohealing policies to new instances or recently recreated
  /// instances.
  ///
  /// This initial delay allows instances to initialize and run their startup
  /// scripts before the instance group determines that they are UNHEALTHY. This
  /// prevents the managed instance group from recreating its instances
  /// prematurely. This value must be from range \[0, 3600\].
  core.int? initialDelaySec;

  InstanceGroupManagerAutoHealingPolicy();

  InstanceGroupManagerAutoHealingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
    if (_json.containsKey('initialDelaySec')) {
      initialDelaySec = _json['initialDelaySec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthCheck != null) 'healthCheck': healthCheck!,
        if (initialDelaySec != null) 'initialDelaySec': initialDelaySec!,
      };
}

class InstanceGroupManagerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagerListWarningData();

  InstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagerListWarning();

  InstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagerListWarningData>((value) =>
              InstanceGroupManagerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of managed instance groups.
///
/// Output only.
class InstanceGroupManagerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager>? items;

  /// The resource type, which is always compute#instanceGroupManagerList for a
  /// list of managed instance groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagerListWarning? warning;

  InstanceGroupManagerList();

  InstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagerStatus {
  /// The URL of the Autoscaler that targets this instance group manager.
  ///
  /// Output only.
  core.String? autoscaler;

  /// A bit indicating whether the managed instance group is in a stable state.
  ///
  /// A stable state means that: none of the instances in the managed instance
  /// group is currently undergoing any type of change (for example, creation,
  /// restart, or deletion); no future changes are scheduled for instances in
  /// the managed instance group; and the managed instance group itself is not
  /// being modified.
  ///
  /// Output only.
  core.bool? isStable;

  /// Stateful status of the given Instance Group Manager.
  ///
  /// Output only.
  InstanceGroupManagerStatusStateful? stateful;

  /// A status of consistency of Instances' versions with their target version
  /// specified by version field on Instance Group Manager.
  ///
  /// Output only.
  InstanceGroupManagerStatusVersionTarget? versionTarget;

  InstanceGroupManagerStatus();

  InstanceGroupManagerStatus.fromJson(core.Map _json) {
    if (_json.containsKey('autoscaler')) {
      autoscaler = _json['autoscaler'] as core.String;
    }
    if (_json.containsKey('isStable')) {
      isStable = _json['isStable'] as core.bool;
    }
    if (_json.containsKey('stateful')) {
      stateful = InstanceGroupManagerStatusStateful.fromJson(
          _json['stateful'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versionTarget')) {
      versionTarget = InstanceGroupManagerStatusVersionTarget.fromJson(
          _json['versionTarget'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscaler != null) 'autoscaler': autoscaler!,
        if (isStable != null) 'isStable': isStable!,
        if (stateful != null) 'stateful': stateful!.toJson(),
        if (versionTarget != null) 'versionTarget': versionTarget!.toJson(),
      };
}

class InstanceGroupManagerStatusStateful {
  /// A bit indicating whether the managed instance group has stateful
  /// configuration, that is, if you have configured any items in a stateful
  /// policy or in per-instance configs.
  ///
  /// The group might report that it has no stateful config even when there is
  /// still some preserved state on a managed instance, for example, if you have
  /// deleted all PICs but not yet applied those deletions.
  ///
  /// Output only.
  core.bool? hasStatefulConfig;

  /// Status of per-instance configs on the instance.
  ///
  /// Output only.
  InstanceGroupManagerStatusStatefulPerInstanceConfigs? perInstanceConfigs;

  InstanceGroupManagerStatusStateful();

  InstanceGroupManagerStatusStateful.fromJson(core.Map _json) {
    if (_json.containsKey('hasStatefulConfig')) {
      hasStatefulConfig = _json['hasStatefulConfig'] as core.bool;
    }
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs =
          InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(
              _json['perInstanceConfigs']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (hasStatefulConfig != null) 'hasStatefulConfig': hasStatefulConfig!,
        if (perInstanceConfigs != null)
          'perInstanceConfigs': perInstanceConfigs!.toJson(),
      };
}

class InstanceGroupManagerStatusStatefulPerInstanceConfigs {
  /// A bit indicating if all of the group's per-instance configs (listed in the
  /// output of a listPerInstanceConfigs API call) have status EFFECTIVE or
  /// there are no per-instance-configs.
  core.bool? allEffective;

  InstanceGroupManagerStatusStatefulPerInstanceConfigs();

  InstanceGroupManagerStatusStatefulPerInstanceConfigs.fromJson(
      core.Map _json) {
    if (_json.containsKey('allEffective')) {
      allEffective = _json['allEffective'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (allEffective != null) 'allEffective': allEffective!,
      };
}

class InstanceGroupManagerStatusVersionTarget {
  /// A bit indicating whether version target has been reached in this managed
  /// instance group, i.e. all instances are in their target version.
  ///
  /// Instances' target version are specified by version field on Instance Group
  /// Manager.
  ///
  /// Output only.
  core.bool? isReached;

  InstanceGroupManagerStatusVersionTarget();

  InstanceGroupManagerStatusVersionTarget.fromJson(core.Map _json) {
    if (_json.containsKey('isReached')) {
      isReached = _json['isReached'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (isReached != null) 'isReached': isReached!,
      };
}

class InstanceGroupManagerUpdatePolicy {
  /// The  instance redistribution policy for regional managed instance groups.
  ///
  /// Valid values are:
  /// - PROACTIVE (default): The group attempts to maintain an even distribution
  /// of VM instances across zones in the region.
  /// - NONE: For non-autoscaled groups, proactive redistribution is disabled.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROACTIVE"
  core.String? instanceRedistributionType;

  /// The maximum number of instances that can be created above the specified
  /// targetSize during the update process.
  ///
  /// This value can be either a fixed number or, if the group has 10 or more
  /// instances, a percentage. If you set a percentage, the number of instances
  /// is rounded up if necessary. The default value for maxSurge is a fixed
  /// value equal to the number of zones in which the managed instance group
  /// operates.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxSurge.
  FixedOrPercent? maxSurge;

  /// The maximum number of instances that can be unavailable during the update
  /// process.
  ///
  /// An instance is considered available if all of the following conditions are
  /// satisfied:
  ///
  ///
  /// - The instance's status is RUNNING.
  /// - If there is a health check on the instance group, the instance's health
  /// check status must be HEALTHY at least once. If there is no health check on
  /// the group, then the instance only needs to have a status of RUNNING to be
  /// considered available. This value can be either a fixed number or, if the
  /// group has 10 or more instances, a percentage. If you set a percentage, the
  /// number of instances is rounded up if necessary. The default value for
  /// maxUnavailable is a fixed value equal to the number of zones in which the
  /// managed instance group operates.
  ///
  /// At least one of either maxSurge or maxUnavailable must be greater than 0.
  /// Learn more about maxUnavailable.
  FixedOrPercent? maxUnavailable;

  /// Minimal action to be taken on an instance.
  ///
  /// You can specify either RESTART to restart existing instances or REPLACE to
  /// delete and create new instances from the target template. If you specify a
  /// RESTART, the Updater will attempt to perform that action only. However, if
  /// the Updater determines that the minimal action you specify is not enough
  /// to perform the update, it might perform a more disruptive action.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String? minimalAction;

  /// What action should be used to replace instances.
  ///
  /// See minimal_action.REPLACE
  /// Possible string values are:
  /// - "RECREATE"
  /// - "SUBSTITUTE"
  core.String? replacementMethod;

  /// The type of update process.
  ///
  /// You can specify either PROACTIVE so that the instance group manager
  /// proactively executes actions in order to bring instances to their target
  /// versions or OPPORTUNISTIC so that no action is proactively executed but
  /// the update will be performed as part of other actions (for example,
  /// resizes or recreateInstances calls).
  /// Possible string values are:
  /// - "OPPORTUNISTIC"
  /// - "PROACTIVE"
  core.String? type;

  InstanceGroupManagerUpdatePolicy();

  InstanceGroupManagerUpdatePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('instanceRedistributionType')) {
      instanceRedistributionType =
          _json['instanceRedistributionType'] as core.String;
    }
    if (_json.containsKey('maxSurge')) {
      maxSurge = FixedOrPercent.fromJson(
          _json['maxSurge'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxUnavailable')) {
      maxUnavailable = FixedOrPercent.fromJson(
          _json['maxUnavailable'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('replacementMethod')) {
      replacementMethod = _json['replacementMethod'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceRedistributionType != null)
          'instanceRedistributionType': instanceRedistributionType!,
        if (maxSurge != null) 'maxSurge': maxSurge!.toJson(),
        if (maxUnavailable != null) 'maxUnavailable': maxUnavailable!.toJson(),
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (replacementMethod != null) 'replacementMethod': replacementMethod!,
        if (type != null) 'type': type!,
      };
}

class InstanceGroupManagerVersion {
  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create new instances in the managed
  /// instance group until the `targetSize` for this version is reached. The
  /// templates for existing instances in the group do not change unless you run
  /// recreateInstances, run applyUpdatesToInstances, or set the group's
  /// updatePolicy.type to PROACTIVE; in those cases, existing instances are
  /// updated until the `targetSize` for this version is reached.
  core.String? instanceTemplate;

  /// Name of the version.
  ///
  /// Unique among all versions in the scope of this managed instance group.
  core.String? name;

  /// Specifies the intended number of instances to be created from the
  /// instanceTemplate.
  ///
  /// The final number of instances created from the template will be equal to:
  /// - If expressed as a fixed number, the minimum of either targetSize.fixed
  /// or instanceGroupManager.targetSize is used.
  /// - if expressed as a percent, the targetSize would be
  /// (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a
  /// remainder, the number is rounded up. If unset, this version will update
  /// any remaining instances not updated by another version. Read Starting a
  /// canary update for more information.
  FixedOrPercent? targetSize;

  InstanceGroupManagerVersion();

  InstanceGroupManagerVersion.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('targetSize')) {
      targetSize = FixedOrPercent.fromJson(
          _json['targetSize'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (name != null) 'name': name!,
        if (targetSize != null) 'targetSize': targetSize!.toJson(),
      };
}

class InstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  InstanceGroupManagersAbandonInstancesRequest();

  InstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

/// InstanceGroupManagers.applyUpdatesToInstances
class InstanceGroupManagersApplyUpdatesRequest {
  /// Flag to update all instances instead of specified list of ?instances?.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  ///
  ///
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all. By default, the minimum action
  /// is NONE. If your update requires a more disruptive action than you set
  /// with this flag, the necessary action is performed to execute the update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  ///
  ///
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all. By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String? mostDisruptiveAllowedAction;

  InstanceGroupManagersApplyUpdatesRequest();

  InstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('allInstances')) {
      allInstances = _json['allInstances'] as core.bool;
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('mostDisruptiveAllowedAction')) {
      mostDisruptiveAllowedAction =
          _json['mostDisruptiveAllowedAction'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (allInstances != null) 'allInstances': allInstances!,
        if (instances != null) 'instances': instances!,
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (mostDisruptiveAllowedAction != null)
          'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
      };
}

/// InstanceGroupManagers.createInstances
class InstanceGroupManagersCreateInstancesRequest {
  /// List of specifications of per-instance configs.
  ///
  /// Required.
  core.List<PerInstanceConfig>? instances;

  InstanceGroupManagersCreateInstancesRequest();

  InstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  InstanceGroupManagersDeleteInstancesRequest();

  InstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

/// InstanceGroupManagers.deletePerInstanceConfigs
class InstanceGroupManagersDeletePerInstanceConfigsReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String>? names;

  InstanceGroupManagersDeletePerInstanceConfigsReq();

  InstanceGroupManagersDeletePerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('names')) {
      names = (_json['names'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

class InstanceGroupManagersListErrorsResponse {
  /// The list of errors of the managed instance group.
  ///
  /// Output only.
  core.List<InstanceManagedByIgmError>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  InstanceGroupManagersListErrorsResponse();

  InstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceManagedByIgmError>((value) =>
              InstanceManagedByIgmError.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class InstanceGroupManagersListManagedInstancesResponse {
  /// The list of instances in the managed instance group.
  ///
  /// Output only.
  core.List<ManagedInstance>? managedInstances;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  InstanceGroupManagersListManagedInstancesResponse();

  InstanceGroupManagersListManagedInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('managedInstances')) {
      managedInstances = (_json['managedInstances'] as core.List)
          .map<ManagedInstance>((value) => ManagedInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (managedInstances != null)
          'managedInstances':
              managedInstances!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class InstanceGroupManagersListPerInstanceConfigsRespWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagersListPerInstanceConfigsRespWarningData();

  InstanceGroupManagersListPerInstanceConfigsRespWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupManagersListPerInstanceConfigsRespWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagersListPerInstanceConfigsRespWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagersListPerInstanceConfigsRespWarning();

  InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
      core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagersListPerInstanceConfigsRespWarningData>(
              (value) =>
                  InstanceGroupManagersListPerInstanceConfigsRespWarningData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagersListPerInstanceConfigsResp {
  /// The list of PerInstanceConfig.
  ///
  /// Output only.
  core.List<PerInstanceConfig>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupManagersListPerInstanceConfigsRespWarning? warning;

  InstanceGroupManagersListPerInstanceConfigsResp();

  InstanceGroupManagersListPerInstanceConfigsResp.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagersListPerInstanceConfigsRespWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// InstanceGroupManagers.patchPerInstanceConfigs
class InstanceGroupManagersPatchPerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  InstanceGroupManagersPatchPerInstanceConfigsReq();

  InstanceGroupManagersPatchPerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupManagersRecreateInstancesRequest {
  /// The URLs of one or more instances to recreate.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  InstanceGroupManagersRecreateInstancesRequest();

  InstanceGroupManagersRecreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

class InstanceGroupManagersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupManagersScopedListWarningData();

  InstanceGroupManagersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// The warning that replaces the list of managed instance groups when the list
/// is empty.
///
/// Output only.
class InstanceGroupManagersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupManagersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupManagersScopedListWarning();

  InstanceGroupManagersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupManagersScopedListWarningData>((value) =>
              InstanceGroupManagersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupManagersScopedList {
  /// The list of managed instance groups that are contained in the specified
  /// project and zone.
  ///
  /// Output only.
  core.List<InstanceGroupManager>? instanceGroupManagers;

  /// The warning that replaces the list of managed instance groups when the
  /// list is empty.
  ///
  /// Output only.
  InstanceGroupManagersScopedListWarning? warning;

  InstanceGroupManagersScopedList();

  InstanceGroupManagersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instanceGroupManagers')) {
      instanceGroupManagers = (_json['instanceGroupManagers'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupManagersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceGroupManagers != null)
          'instanceGroupManagers':
              instanceGroupManagers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupManagersSetInstanceTemplateRequest {
  /// The URL of the instance template that is specified for this managed
  /// instance group.
  ///
  /// The group uses this template to create all new instances in the managed
  /// instance group. The templates for existing instances in the group do not
  /// change unless you run recreateInstances, run applyUpdatesToInstances, or
  /// set the group's updatePolicy.type to PROACTIVE.
  core.String? instanceTemplate;

  InstanceGroupManagersSetInstanceTemplateRequest();

  InstanceGroupManagersSetInstanceTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
      };
}

class InstanceGroupManagersSetTargetPoolsRequest {
  /// The fingerprint of the target pools information.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the target pools settings concurrently. Obtain the fingerprint with the
  /// instanceGroupManagers.get method. Then, include the fingerprint in your
  /// request to ensure that you do not overwrite changes that were applied from
  /// another concurrent request.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of target pool URLs that instances in this managed instance group
  /// belong to.
  ///
  /// The managed instance group applies these target pools to all of the
  /// instances in the group. Existing instances and new instances in the group
  /// all receive these target pool settings.
  core.List<core.String>? targetPools;

  InstanceGroupManagersSetTargetPoolsRequest();

  InstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (targetPools != null) 'targetPools': targetPools!,
      };
}

/// InstanceGroupManagers.updatePerInstanceConfigs
class InstanceGroupManagersUpdatePerInstanceConfigsReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  InstanceGroupManagersUpdatePerInstanceConfigsReq();

  InstanceGroupManagersUpdatePerInstanceConfigsReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsAddInstancesRequest {
  /// The list of instances to add to the instance group.
  core.List<InstanceReference>? instances;

  InstanceGroupsAddInstancesRequest();

  InstanceGroupsAddInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsListInstancesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupsListInstancesWarningData();

  InstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceGroupsListInstancesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupsListInstancesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupsListInstancesWarning();

  InstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupsListInstancesWarningData>((value) =>
              InstanceGroupsListInstancesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupsListInstances {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts>? items;

  /// The resource type, which is always compute#instanceGroupsListInstances for
  /// the list of instances in the specified instance group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceGroupsListInstancesWarning? warning;

  InstanceGroupsListInstances();

  InstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceWithNamedPorts>((value) =>
              InstanceWithNamedPorts.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupsListInstancesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupsListInstancesRequest {
  /// A filter for the state of the instances in the instance group.
  ///
  /// Valid options are ALL or RUNNING. If you do not specify this parameter the
  /// list includes all instances regardless of their state.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String? instanceState;

  InstanceGroupsListInstancesRequest();

  InstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceState')) {
      instanceState = _json['instanceState'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceState != null) 'instanceState': instanceState!,
      };
}

class InstanceGroupsRemoveInstancesRequest {
  /// The list of instances to remove from the instance group.
  core.List<InstanceReference>? instances;

  InstanceGroupsRemoveInstancesRequest();

  InstanceGroupsRemoveInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class InstanceGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceGroupsScopedListWarningData();

  InstanceGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that replaces the list of instance groups when the
/// list is empty.
///
/// Output only.
class InstanceGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceGroupsScopedListWarning();

  InstanceGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceGroupsScopedListWarningData>((value) =>
              InstanceGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstanceGroupsScopedList {
  /// The list of instance groups that are contained in this scope.
  ///
  /// Output only.
  core.List<InstanceGroup>? instanceGroups;

  /// An informational warning that replaces the list of instance groups when
  /// the list is empty.
  ///
  /// Output only.
  InstanceGroupsScopedListWarning? warning;

  InstanceGroupsScopedList();

  InstanceGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instanceGroups')) {
      instanceGroups = (_json['instanceGroups'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstanceGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceGroups != null)
          'instanceGroups':
              instanceGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request. A request with an incorrect fingerprint will fail with
  /// error 412 conditionNotMet.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort>? namedPorts;

  InstanceGroupsSetNamedPortsRequest();

  InstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
      };
}

class InstanceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceListWarningData();

  InstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceListWarning();

  InstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceListWarningData>((value) =>
              InstanceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of instances.
class InstanceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Instance resources.
  core.List<Instance>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceList for lists of Instance resources.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceListWarning? warning;

  InstanceList();

  InstanceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Instance>((value) =>
              Instance.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceListReferrersWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceListReferrersWarningData();

  InstanceListReferrersWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceListReferrersWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceListReferrersWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceListReferrersWarning();

  InstanceListReferrersWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceListReferrersWarningData>((value) =>
              InstanceListReferrersWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of instance referrers.
class InstanceListReferrers {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Reference resources.
  core.List<Reference>? items;

  /// Type of resource.
  ///
  /// Always compute#instanceListReferrers for lists of Instance referrers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceListReferrersWarning? warning;

  InstanceListReferrers();

  InstanceListReferrers.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Reference>((value) =>
              Reference.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceListReferrersWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceManagedByIgmError {
  /// Contents of the error.
  ///
  /// Output only.
  InstanceManagedByIgmErrorManagedInstanceError? error;

  /// Details of the instance action that triggered this error.
  ///
  /// May be null, if the error was not caused by an action on an instance. This
  /// field is optional.
  ///
  /// Output only.
  InstanceManagedByIgmErrorInstanceActionDetails? instanceActionDetails;

  /// The time that this error occurred.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? timestamp;

  InstanceManagedByIgmError();

  InstanceManagedByIgmError.fromJson(core.Map _json) {
    if (_json.containsKey('error')) {
      error = InstanceManagedByIgmErrorManagedInstanceError.fromJson(
          _json['error'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('instanceActionDetails')) {
      instanceActionDetails =
          InstanceManagedByIgmErrorInstanceActionDetails.fromJson(
              _json['instanceActionDetails']
                  as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('timestamp')) {
      timestamp = _json['timestamp'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (error != null) 'error': error!.toJson(),
        if (instanceActionDetails != null)
          'instanceActionDetails': instanceActionDetails!.toJson(),
        if (timestamp != null) 'timestamp': timestamp!,
      };
}

class InstanceManagedByIgmErrorInstanceActionDetails {
  /// Action that managed instance group was executing on the instance when the
  /// error occurred.
  ///
  /// Possible values:
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String? action;

  /// The URL of the instance.
  ///
  /// The URL can be set even if the instance has not yet been created.
  ///
  /// Output only.
  core.String? instance;

  /// Version this instance was created from, or was being created from, but the
  /// creation failed.
  ///
  /// Corresponds to one of the versions that were set on the Instance Group
  /// Manager resource at the time this instance was being created.
  ///
  /// Output only.
  ManagedInstanceVersion? version;

  InstanceManagedByIgmErrorInstanceActionDetails();

  InstanceManagedByIgmErrorInstanceActionDetails.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('version')) {
      version = ManagedInstanceVersion.fromJson(
          _json['version'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (instance != null) 'instance': instance!,
        if (version != null) 'version': version!.toJson(),
      };
}

class InstanceManagedByIgmErrorManagedInstanceError {
  /// Error code.
  ///
  /// Output only.
  core.String? code;

  /// Error message.
  ///
  /// Output only.
  core.String? message;

  InstanceManagedByIgmErrorManagedInstanceError();

  InstanceManagedByIgmErrorManagedInstanceError.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (message != null) 'message': message!,
      };
}

class InstanceMoveRequest {
  /// The URL of the destination zone to move the instance.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to a zone:
  /// - https://www.googleapis.com/compute/v1/projects/project/zones/zone
  /// - projects/project/zones/zone
  /// - zones/zone
  core.String? destinationZone;

  /// The URL of the target instance to move.
  ///
  /// This can be a full or partial URL. For example, the following are all
  /// valid URLs to an instance:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String? targetInstance;

  InstanceMoveRequest();

  InstanceMoveRequest.fromJson(core.Map _json) {
    if (_json.containsKey('destinationZone')) {
      destinationZone = _json['destinationZone'] as core.String;
    }
    if (_json.containsKey('targetInstance')) {
      targetInstance = _json['targetInstance'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationZone != null) 'destinationZone': destinationZone!,
        if (targetInstance != null) 'targetInstance': targetInstance!,
      };
}

class InstanceProperties {
  /// Controls for advanced machine-related behavior features.
  AdvancedMachineFeatures? advancedMachineFeatures;

  /// Enables instances created based on these properties to send packets with
  /// source IP addresses other than their own and receive packets with
  /// destination IP addresses other than their own.
  ///
  /// If these instances will be used as an IP gateway or it will be set as the
  /// next-hop in a Route resource, specify true. If unsure, leave this set to
  /// false. See the Enable IP forwarding documentation for more information.
  core.bool? canIpForward;

  /// Specifies the Confidential Instance options.
  ConfidentialInstanceConfig? confidentialInstanceConfig;

  /// An optional text description for the instances that are created from these
  /// properties.
  core.String? description;

  /// An array of disks that are associated with the instances that are created
  /// from these properties.
  core.List<AttachedDisk>? disks;

  /// A list of guest accelerator cards' type and count to use for instances
  /// created from these properties.
  core.List<AcceleratorConfig>? guestAccelerators;

  /// Labels to apply to instances that are created from these properties.
  core.Map<core.String, core.String>? labels;

  /// The machine type to use for instances that are created from these
  /// properties.
  core.String? machineType;

  /// The metadata key/value pairs to assign to instances that are created from
  /// these properties.
  ///
  /// These pairs can consist of custom metadata or predefined keys. See Project
  /// and instance metadata for more information.
  Metadata? metadata;

  /// Minimum cpu/platform to be used by instances.
  ///
  /// The instance may be scheduled on the specified or newer cpu/platform.
  /// Applicable values are the friendly names of CPU platforms, such as
  /// minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
  /// For more information, read Specifying a Minimum CPU Platform.
  core.String? minCpuPlatform;

  /// An array of network access configurations for this interface.
  core.List<NetworkInterface>? networkInterfaces;

  /// The private IPv6 google access type for VMs.
  ///
  /// If not specified, use  INHERIT_FROM_SUBNETWORK as default.
  /// Possible string values are:
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  /// - "INHERIT_FROM_SUBNETWORK"
  core.String? privateIpv6GoogleAccess;

  /// Specifies the reservations that instances can consume from.
  ReservationAffinity? reservationAffinity;

  /// Resource policies (names, not ULRs) applied to instances created from
  /// these properties.
  core.List<core.String>? resourcePolicies;

  /// Specifies the scheduling options for the instances that are created from
  /// these properties.
  Scheduling? scheduling;

  /// A list of service accounts with specified scopes.
  ///
  /// Access tokens for these service accounts are available to the instances
  /// that are created from these properties. Use metadata queries to obtain the
  /// access tokens for these instances.
  core.List<ServiceAccount>? serviceAccounts;
  ShieldedInstanceConfig? shieldedInstanceConfig;

  /// A list of tags to apply to the instances that are created from these
  /// properties.
  ///
  /// The tags identify valid sources or targets for network firewalls. The
  /// setTags method can modify this list of tags. Each tag within the list must
  /// comply with RFC1035.
  Tags? tags;

  InstanceProperties();

  InstanceProperties.fromJson(core.Map _json) {
    if (_json.containsKey('advancedMachineFeatures')) {
      advancedMachineFeatures = AdvancedMachineFeatures.fromJson(
          _json['advancedMachineFeatures']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('canIpForward')) {
      canIpForward = _json['canIpForward'] as core.bool;
    }
    if (_json.containsKey('confidentialInstanceConfig')) {
      confidentialInstanceConfig = ConfidentialInstanceConfig.fromJson(
          _json['confidentialInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<AttachedDisk>((value) => AttachedDisk.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
    if (_json.containsKey('metadata')) {
      metadata = Metadata.fromJson(
          _json['metadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
    if (_json.containsKey('networkInterfaces')) {
      networkInterfaces = (_json['networkInterfaces'] as core.List)
          .map<NetworkInterface>((value) => NetworkInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('reservationAffinity')) {
      reservationAffinity = ReservationAffinity.fromJson(
          _json['reservationAffinity'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('scheduling')) {
      scheduling = Scheduling.fromJson(
          _json['scheduling'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('serviceAccounts')) {
      serviceAccounts = (_json['serviceAccounts'] as core.List)
          .map<ServiceAccount>((value) => ServiceAccount.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('shieldedInstanceConfig')) {
      shieldedInstanceConfig = ShieldedInstanceConfig.fromJson(
          _json['shieldedInstanceConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tags')) {
      tags =
          Tags.fromJson(_json['tags'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (advancedMachineFeatures != null)
          'advancedMachineFeatures': advancedMachineFeatures!.toJson(),
        if (canIpForward != null) 'canIpForward': canIpForward!,
        if (confidentialInstanceConfig != null)
          'confidentialInstanceConfig': confidentialInstanceConfig!.toJson(),
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
        if (labels != null) 'labels': labels!,
        if (machineType != null) 'machineType': machineType!,
        if (metadata != null) 'metadata': metadata!.toJson(),
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
        if (networkInterfaces != null)
          'networkInterfaces':
              networkInterfaces!.map((value) => value.toJson()).toList(),
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (reservationAffinity != null)
          'reservationAffinity': reservationAffinity!.toJson(),
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
        if (scheduling != null) 'scheduling': scheduling!.toJson(),
        if (serviceAccounts != null)
          'serviceAccounts':
              serviceAccounts!.map((value) => value.toJson()).toList(),
        if (shieldedInstanceConfig != null)
          'shieldedInstanceConfig': shieldedInstanceConfig!.toJson(),
        if (tags != null) 'tags': tags!.toJson(),
      };
}

class InstanceReference {
  /// The URL for a specific instance.
  core.String? instance;

  InstanceReference();

  InstanceReference.fromJson(core.Map _json) {
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
      };
}

/// Represents an Instance Template resource.
///
/// You can use instance templates to create VM instances and managed instance
/// groups.
///
/// For more information, read Instance Templates. (== resource_for
/// {$api_version}.instanceTemplates ==)
class InstanceTemplate {
  /// The creation timestamp for this instance template in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A unique identifier for this instance template.
  ///
  /// The server defines this identifier.
  ///
  /// Output only.
  core.String? id;

  /// The resource type, which is always compute#instanceTemplate for instance
  /// templates.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The instance properties for this instance template.
  InstanceProperties? properties;

  /// The URL for this instance template.
  ///
  /// The server defines this URL.
  ///
  /// Output only.
  core.String? selfLink;

  /// The source instance used to create the template.
  ///
  /// You can provide this as a partial or full URL to the resource. For
  /// example, the following are valid values:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  core.String? sourceInstance;

  /// The source instance params to use to create this instance template.
  SourceInstanceParams? sourceInstanceParams;

  InstanceTemplate();

  InstanceTemplate.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('properties')) {
      properties = InstanceProperties.fromJson(
          _json['properties'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sourceInstance')) {
      sourceInstance = _json['sourceInstance'] as core.String;
    }
    if (_json.containsKey('sourceInstanceParams')) {
      sourceInstanceParams = SourceInstanceParams.fromJson(
          _json['sourceInstanceParams'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (properties != null) 'properties': properties!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (sourceInstance != null) 'sourceInstance': sourceInstance!,
        if (sourceInstanceParams != null)
          'sourceInstanceParams': sourceInstanceParams!.toJson(),
      };
}

class InstanceTemplateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstanceTemplateListWarningData();

  InstanceTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InstanceTemplateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstanceTemplateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstanceTemplateListWarning();

  InstanceTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstanceTemplateListWarningData>((value) =>
              InstanceTemplateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of instance templates.
class InstanceTemplateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceTemplate resources.
  core.List<InstanceTemplate>? items;

  /// The resource type, which is always compute#instanceTemplatesListResponse
  /// for instance template lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InstanceTemplateListWarning? warning;

  InstanceTemplateList();

  InstanceTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceTemplate>((value) => InstanceTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InstanceTemplateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstanceWithNamedPorts {
  /// The URL of the instance.
  ///
  /// Output only.
  core.String? instance;

  /// The named ports that belong to this instance group.
  ///
  /// Output only.
  core.List<NamedPort>? namedPorts;

  /// The status of the instance.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String? status;

  InstanceWithNamedPorts();

  InstanceWithNamedPorts.fromJson(core.Map _json) {
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
        if (status != null) 'status': status!,
      };
}

class InstancesAddResourcePoliciesRequest {
  /// Resource policies to be added to this instance.
  core.List<core.String>? resourcePolicies;

  InstancesAddResourcePoliciesRequest();

  InstancesAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class InstancesGetEffectiveFirewallsResponse {
  /// Effective firewalls from firewall policies.
  core.List<InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>?
      firewallPolicys;

  /// Effective firewalls on the instance.
  core.List<Firewall>? firewalls;

  InstancesGetEffectiveFirewallsResponse();

  InstancesGetEffectiveFirewallsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('firewallPolicys')) {
      firewallPolicys = (_json['firewallPolicys'] as core.List)
          .map<InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>(
              (value) =>
                  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('firewalls')) {
      firewalls = (_json['firewalls'] as core.List)
          .map<Firewall>((value) =>
              Firewall.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (firewallPolicys != null)
          'firewallPolicys':
              firewallPolicys!.map((value) => value.toJson()).toList(),
        if (firewalls != null)
          'firewalls': firewalls!.map((value) => value.toJson()).toList(),
      };
}

class InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /// The display name of the firewall policy.
  ///
  /// Output only.
  core.String? displayName;

  /// The name of the firewall policy.
  ///
  /// Output only.
  core.String? name;

  /// The rules that apply to the network.
  core.List<FirewallPolicyRule>? rules;

  /// The type of the firewall policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HIERARCHY"
  /// - "UNSPECIFIED"
  core.String? type;

  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy();

  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.fromJson(
      core.Map _json) {
    if (_json.containsKey('displayName')) {
      displayName = _json['displayName'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<FirewallPolicyRule>((value) => FirewallPolicyRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (type != null) 'type': type!,
      };
}

class InstancesRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this instance.
  core.List<core.String>? resourcePolicies;

  InstancesRemoveResourcePoliciesRequest();

  InstancesRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class InstancesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InstancesScopedListWarningData();

  InstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of instances when the list is
/// empty.
///
/// Output only.
class InstancesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InstancesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InstancesScopedListWarning();

  InstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InstancesScopedListWarningData>((value) =>
              InstancesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InstancesScopedList {
  /// A list of instances contained in this scope.
  ///
  /// Output only.
  core.List<Instance>? instances;

  /// Informational warning which replaces the list of instances when the list
  /// is empty.
  ///
  /// Output only.
  InstancesScopedListWarning? warning;

  InstancesScopedList();

  InstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<Instance>((value) =>
              Instance.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InstancesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InstancesSetLabelsRequest {
  /// Fingerprint of the previous set of labels for this resource, used to
  /// prevent conflicts.
  ///
  /// Provide the latest fingerprint value when making a request to add or
  /// change labels.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  core.Map<core.String, core.String>? labels;

  InstancesSetLabelsRequest();

  InstancesSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class InstancesSetMachineResourcesRequest {
  /// A list of the type and count of accelerator cards attached to the
  /// instance.
  core.List<AcceleratorConfig>? guestAccelerators;

  InstancesSetMachineResourcesRequest();

  InstancesSetMachineResourcesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('guestAccelerators')) {
      guestAccelerators = (_json['guestAccelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAccelerators != null)
          'guestAccelerators':
              guestAccelerators!.map((value) => value.toJson()).toList(),
      };
}

class InstancesSetMachineTypeRequest {
  /// Full or partial URL of the machine type resource.
  ///
  /// See Machine Types for a full list of machine types. For example:
  /// zones/us-central1-f/machineTypes/n1-standard-1
  core.String? machineType;

  InstancesSetMachineTypeRequest();

  InstancesSetMachineTypeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('machineType')) {
      machineType = _json['machineType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineType != null) 'machineType': machineType!,
      };
}

class InstancesSetMinCpuPlatformRequest {
  /// Minimum cpu/platform this instance should be started at.
  core.String? minCpuPlatform;

  InstancesSetMinCpuPlatformRequest();

  InstancesSetMinCpuPlatformRequest.fromJson(core.Map _json) {
    if (_json.containsKey('minCpuPlatform')) {
      minCpuPlatform = _json['minCpuPlatform'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (minCpuPlatform != null) 'minCpuPlatform': minCpuPlatform!,
      };
}

class InstancesSetServiceAccountRequest {
  /// Email address of the service account.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String>? scopes;

  InstancesSetServiceAccountRequest();

  InstancesSetServiceAccountRequest.fromJson(core.Map _json) {
    if (_json.containsKey('email')) {
      email = _json['email'] as core.String;
    }
    if (_json.containsKey('scopes')) {
      scopes = (_json['scopes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (email != null) 'email': email!,
        if (scopes != null) 'scopes': scopes!,
      };
}

class InstancesStartWithEncryptionKeyRequest {
  /// Array of disks associated with this instance that are protected with a
  /// customer-supplied encryption key.
  ///
  /// In order to start the instance, the disk url and its corresponding key
  /// must be provided.
  ///
  /// If the disk is not protected with a customer-supplied encryption key it
  /// should not be specified.
  core.List<CustomerEncryptionKeyProtectedDisk>? disks;

  InstancesStartWithEncryptionKeyRequest();

  InstancesStartWithEncryptionKeyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<CustomerEncryptionKeyProtectedDisk>((value) =>
              CustomerEncryptionKeyProtectedDisk.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
      };
}

/// HttpRouteRuleMatch criteria for field values that must stay within the
/// specified integer range.
class Int64RangeMatch {
  /// The end of the range (exclusive) in signed long integer format.
  core.String? rangeEnd;

  /// The start of the range (inclusive) in signed long integer format.
  core.String? rangeStart;

  Int64RangeMatch();

  Int64RangeMatch.fromJson(core.Map _json) {
    if (_json.containsKey('rangeEnd')) {
      rangeEnd = _json['rangeEnd'] as core.String;
    }
    if (_json.containsKey('rangeStart')) {
      rangeStart = _json['rangeStart'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (rangeEnd != null) 'rangeEnd': rangeEnd!,
        if (rangeStart != null) 'rangeStart': rangeStart!,
      };
}

/// Represents an Interconnect resource.
///
/// An Interconnect resource is a dedicated connection between the GCP network
/// and your on-premises network.
///
/// For more information, read the Dedicated Interconnect Overview. (==
/// resource_for {$api_version}.interconnects ==)
class Interconnect {
  /// Administrative status of the interconnect.
  ///
  /// When this is set to true, the Interconnect is functional and can carry
  /// traffic. When set to false, no packets can be carried over the
  /// interconnect and no BGP routes are exchanged over it. By default, the
  /// status is set to true.
  core.bool? adminEnabled;

  /// A list of CircuitInfo objects, that describe the individual circuits in
  /// this LAG.
  ///
  /// Output only.
  core.List<InterconnectCircuitInfo>? circuitInfos;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Customer name, to put in the Letter of Authorization as the party
  /// authorized to request a crossconnect.
  core.String? customerName;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A list of outages expected for this Interconnect.
  ///
  /// Output only.
  core.List<InterconnectOutageNotification>? expectedOutages;

  /// IP address configured on the Google side of the Interconnect link.
  ///
  /// This can be used only for ping tests.
  ///
  /// Output only.
  core.String? googleIpAddress;

  /// Google reference ID to be used when raising support tickets with Google or
  /// otherwise to debug backend connectivity issues.
  ///
  /// Output only.
  core.String? googleReferenceId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of the URLs of all InterconnectAttachments configured to use this
  /// Interconnect.
  ///
  /// Output only.
  core.List<core.String>? interconnectAttachments;

  /// Type of interconnect, which can take one of the following values:
  /// - PARTNER: A partner-managed interconnection shared between customers
  /// though a partner.
  ///
  ///
  /// - DEDICATED: A dedicated physical interconnection with the customer. Note
  /// that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "IT_PRIVATE"
  /// - "PARTNER"
  core.String? interconnectType;

  /// Type of the resource.
  ///
  /// Always compute#interconnect for interconnects.
  ///
  /// Output only.
  core.String? kind;

  /// Type of link requested, which can take one of the following values:
  /// - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics
  /// - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics.
  ///
  /// Note that this field indicates the speed of each of the links in the
  /// bundle, not the speed of the entire bundle.
  /// Possible string values are:
  /// - "LINK_TYPE_ETHERNET_100G_LR"
  /// - "LINK_TYPE_ETHERNET_10G_LR"
  core.String? linkType;

  /// URL of the InterconnectLocation object that represents where this
  /// connection is to be provisioned.
  core.String? location;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Email address to contact the customer NOC for operations and maintenance
  /// notifications regarding this Interconnect.
  ///
  /// If specified, this will be used for notifications in addition to all other
  /// forms described, such as Stackdriver logs alerting and Cloud
  /// Notifications.
  core.String? nocContactEmail;

  /// The current status of this Interconnect's functionality, which can take
  /// one of the following values:
  /// - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use.
  ///
  /// Attachments may be provisioned on this Interconnect.
  /// - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No
  /// attachments may be provisioned on this Interconnect.
  /// - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal
  /// maintenance. No attachments may be provisioned or updated on this
  /// Interconnect.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String? operationalStatus;

  /// IP address configured on the customer side of the Interconnect link.
  ///
  /// The customer should configure this IP address during turnup when prompted
  /// by Google NOC. This can be used only for ping tests.
  ///
  /// Output only.
  core.String? peerIpAddress;

  /// Number of links actually provisioned in this interconnect.
  ///
  /// Output only.
  core.int? provisionedLinkCount;

  /// Target number of physical links in the link bundle, as requested by the
  /// customer.
  core.int? requestedLinkCount;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The current state of Interconnect functionality, which can take one of the
  /// following values:
  /// - ACTIVE: The Interconnect is valid, turned up and ready to use.
  ///
  /// Attachments may be provisioned on this Interconnect.
  /// - UNPROVISIONED: The Interconnect has not completed turnup. No attachments
  /// may be provisioned on this Interconnect.
  /// - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance.
  /// No attachments may be provisioned or updated on this Interconnect.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "UNPROVISIONED"
  core.String? state;

  Interconnect();

  Interconnect.fromJson(core.Map _json) {
    if (_json.containsKey('adminEnabled')) {
      adminEnabled = _json['adminEnabled'] as core.bool;
    }
    if (_json.containsKey('circuitInfos')) {
      circuitInfos = (_json['circuitInfos'] as core.List)
          .map<InterconnectCircuitInfo>((value) =>
              InterconnectCircuitInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customerName')) {
      customerName = _json['customerName'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expectedOutages')) {
      expectedOutages = (_json['expectedOutages'] as core.List)
          .map<InterconnectOutageNotification>((value) =>
              InterconnectOutageNotification.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('googleIpAddress')) {
      googleIpAddress = _json['googleIpAddress'] as core.String;
    }
    if (_json.containsKey('googleReferenceId')) {
      googleReferenceId = _json['googleReferenceId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interconnectAttachments')) {
      interconnectAttachments = (_json['interconnectAttachments'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('interconnectType')) {
      interconnectType = _json['interconnectType'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('linkType')) {
      linkType = _json['linkType'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nocContactEmail')) {
      nocContactEmail = _json['nocContactEmail'] as core.String;
    }
    if (_json.containsKey('operationalStatus')) {
      operationalStatus = _json['operationalStatus'] as core.String;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
    if (_json.containsKey('provisionedLinkCount')) {
      provisionedLinkCount = _json['provisionedLinkCount'] as core.int;
    }
    if (_json.containsKey('requestedLinkCount')) {
      requestedLinkCount = _json['requestedLinkCount'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (adminEnabled != null) 'adminEnabled': adminEnabled!,
        if (circuitInfos != null)
          'circuitInfos': circuitInfos!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customerName != null) 'customerName': customerName!,
        if (description != null) 'description': description!,
        if (expectedOutages != null)
          'expectedOutages':
              expectedOutages!.map((value) => value.toJson()).toList(),
        if (googleIpAddress != null) 'googleIpAddress': googleIpAddress!,
        if (googleReferenceId != null) 'googleReferenceId': googleReferenceId!,
        if (id != null) 'id': id!,
        if (interconnectAttachments != null)
          'interconnectAttachments': interconnectAttachments!,
        if (interconnectType != null) 'interconnectType': interconnectType!,
        if (kind != null) 'kind': kind!,
        if (linkType != null) 'linkType': linkType!,
        if (location != null) 'location': location!,
        if (name != null) 'name': name!,
        if (nocContactEmail != null) 'nocContactEmail': nocContactEmail!,
        if (operationalStatus != null) 'operationalStatus': operationalStatus!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
        if (provisionedLinkCount != null)
          'provisionedLinkCount': provisionedLinkCount!,
        if (requestedLinkCount != null)
          'requestedLinkCount': requestedLinkCount!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
      };
}

/// Represents an Interconnect Attachment (VLAN) resource.
///
/// You can use Interconnect attachments (VLANS) to connect your Virtual Private
/// Cloud networks to your on-premises networks through an Interconnect.
///
/// For more information, read Creating VLAN Attachments. (== resource_for
/// {$api_version}.interconnectAttachments ==)
class InterconnectAttachment {
  /// Determines whether this Attachment will carry packets.
  ///
  /// Not present for PARTNER_PROVIDER.
  core.bool? adminEnabled;

  /// Provisioned bandwidth capacity for the interconnect attachment.
  ///
  /// For attachments of type DEDICATED, the user can set the bandwidth. For
  /// attachments of type PARTNER, the Google Partner that is operating the
  /// interconnect must set the bandwidth. Output only for PARTNER type, mutable
  /// for PARTNER_PROVIDER and DEDICATED, and can take one of the following
  /// values:
  /// - BPS_50M: 50 Mbit/s
  /// - BPS_100M: 100 Mbit/s
  /// - BPS_200M: 200 Mbit/s
  /// - BPS_300M: 300 Mbit/s
  /// - BPS_400M: 400 Mbit/s
  /// - BPS_500M: 500 Mbit/s
  /// - BPS_1G: 1 Gbit/s
  /// - BPS_2G: 2 Gbit/s
  /// - BPS_5G: 5 Gbit/s
  /// - BPS_10G: 10 Gbit/s
  /// - BPS_20G: 20 Gbit/s
  /// - BPS_50G: 50 Gbit/s
  /// Possible string values are:
  /// - "BPS_100M"
  /// - "BPS_10G"
  /// - "BPS_1G"
  /// - "BPS_200M"
  /// - "BPS_20G"
  /// - "BPS_2G"
  /// - "BPS_300M"
  /// - "BPS_400M"
  /// - "BPS_500M"
  /// - "BPS_50G"
  /// - "BPS_50M"
  /// - "BPS_5G"
  core.String? bandwidth;

  /// Up to 16 candidate prefixes that can be used to restrict the allocation of
  /// cloudRouterIpAddress and customerRouterIpAddress for this attachment.
  ///
  /// All prefixes must be within link-local address space (169.254.0.0/16) and
  /// must be /29 or shorter (/28, /27, etc). Google will attempt to select an
  /// unused /29 from the supplied candidate prefix(es). The request will fail
  /// if all possible /29s are in use on Google's edge. If not supplied, Google
  /// will randomly select an unused /29 from all of link-local space.
  core.List<core.String>? candidateSubnets;

  /// IPv4 address + prefix length to be configured on Cloud Router Interface
  /// for this interconnect attachment.
  ///
  /// Output only.
  core.String? cloudRouterIpAddress;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// IPv4 address + prefix length to be configured on the customer router
  /// subinterface for this interconnect attachment.
  ///
  /// Output only.
  core.String? customerRouterIpAddress;

  /// Dataplane version for this InterconnectAttachment.
  ///
  /// Output only.
  core.int? dataplaneVersion;

  /// An optional description of this resource.
  core.String? description;

  /// Desired availability domain for the attachment.
  ///
  /// Only available for type PARTNER, at creation time, and can take one of the
  /// following values:
  /// - AVAILABILITY_DOMAIN_ANY
  /// - AVAILABILITY_DOMAIN_1
  /// - AVAILABILITY_DOMAIN_2 For improved reliability, customers should
  /// configure a pair of attachments, one per availability domain. The selected
  /// availability domain will be provided to the Partner via the pairing key,
  /// so that the provisioned circuit will lie in the specified domain. If not
  /// specified, the value will default to AVAILABILITY_DOMAIN_ANY.
  /// Possible string values are:
  /// - "AVAILABILITY_DOMAIN_1"
  /// - "AVAILABILITY_DOMAIN_2"
  /// - "AVAILABILITY_DOMAIN_ANY"
  core.String? edgeAvailabilityDomain;

  /// Google reference ID, to be used when raising support tickets with Google
  /// or otherwise to debug backend connectivity issues.
  ///
  /// \[Deprecated\] This field is not used.
  ///
  /// Output only.
  core.String? googleReferenceId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// URL of the underlying Interconnect object that this attachment's traffic
  /// will traverse through.
  core.String? interconnect;

  /// Type of the resource.
  ///
  /// Always compute#interconnectAttachment for interconnect attachments.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum Transmission Unit (MTU), in bytes, of packets passing through this
  /// interconnect attachment.
  ///
  /// Only 1440 and 1500 are allowed. If not specified, the value will default
  /// to 1440.
  core.int? mtu;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The current status of whether or not this interconnect attachment is
  /// functional, which can take one of the following values:
  /// - OS_ACTIVE: The attachment has been turned up and is ready to use.
  ///
  ///
  /// - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup
  /// is not complete.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OS_ACTIVE"
  /// - "OS_UNPROVISIONED"
  core.String? operationalStatus;

  /// \[Output only for type PARTNER.
  ///
  /// Input only for PARTNER_PROVIDER. Not present for DEDICATED\]. The opaque
  /// identifier of an PARTNER attachment used to initiate provisioning with a
  /// selected partner. Of the form "XXXXX/region/domain"
  core.String? pairingKey;

  /// Optional BGP ASN for the router supplied by a Layer 3 Partner if they
  /// configured BGP on behalf of the customer.
  ///
  /// Output only for PARTNER type, input only for PARTNER_PROVIDER, not
  /// available for DEDICATED.
  core.String? partnerAsn;

  /// Informational metadata about Partner attachments from Partners to display
  /// to customers.
  ///
  /// Output only for for PARTNER type, mutable for PARTNER_PROVIDER, not
  /// available for DEDICATED.
  InterconnectAttachmentPartnerMetadata? partnerMetadata;

  /// Information specific to an InterconnectAttachment.
  ///
  /// This property is populated if the interconnect that this is attached to is
  /// of type DEDICATED.
  ///
  /// Output only.
  InterconnectAttachmentPrivateInfo? privateInterconnectInfo;

  /// URL of the region where the regional interconnect attachment resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// URL of the Cloud Router to be used for dynamic routing.
  ///
  /// This router must be in the same region as this InterconnectAttachment. The
  /// InterconnectAttachment will automatically connect the Interconnect to the
  /// network & region within which the Cloud Router is configured.
  core.String? router;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The current state of this attachment's functionality.
  ///
  /// Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE,
  /// PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values
  /// PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used
  /// for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state
  /// can take one of the following values:
  /// - ACTIVE: The attachment has been turned up and is ready to use.
  /// - UNPROVISIONED: The attachment is not ready to use yet, because turnup is
  /// not complete.
  /// - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet
  /// been configured on the Partner side.
  /// - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of
  /// provisioning after a PARTNER_PROVIDER attachment was created that
  /// references it.
  /// - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is
  /// waiting for a customer to activate it.
  /// - DEFUNCT: The attachment was deleted externally and is no longer
  /// functional. This could be because the associated Interconnect was removed,
  /// or because the other side of a Partner attachment was deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DEFUNCT"
  /// - "PARTNER_REQUEST_RECEIVED"
  /// - "PENDING_CUSTOMER"
  /// - "PENDING_PARTNER"
  /// - "STATE_UNSPECIFIED"
  /// - "UNPROVISIONED"
  core.String? state;

  /// The type of interconnect attachment this is, which can take one of the
  /// following values:
  /// - DEDICATED: an attachment to a Dedicated Interconnect.
  ///
  ///
  /// - PARTNER: an attachment to a Partner Interconnect, created by the
  /// customer.
  /// - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by
  /// the partner.
  /// Possible string values are:
  /// - "DEDICATED"
  /// - "PARTNER"
  /// - "PARTNER_PROVIDER"
  core.String? type;

  /// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094.
  ///
  /// Only specified at creation time.
  core.int? vlanTag8021q;

  InterconnectAttachment();

  InterconnectAttachment.fromJson(core.Map _json) {
    if (_json.containsKey('adminEnabled')) {
      adminEnabled = _json['adminEnabled'] as core.bool;
    }
    if (_json.containsKey('bandwidth')) {
      bandwidth = _json['bandwidth'] as core.String;
    }
    if (_json.containsKey('candidateSubnets')) {
      candidateSubnets = (_json['candidateSubnets'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('cloudRouterIpAddress')) {
      cloudRouterIpAddress = _json['cloudRouterIpAddress'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customerRouterIpAddress')) {
      customerRouterIpAddress = _json['customerRouterIpAddress'] as core.String;
    }
    if (_json.containsKey('dataplaneVersion')) {
      dataplaneVersion = _json['dataplaneVersion'] as core.int;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('edgeAvailabilityDomain')) {
      edgeAvailabilityDomain = _json['edgeAvailabilityDomain'] as core.String;
    }
    if (_json.containsKey('googleReferenceId')) {
      googleReferenceId = _json['googleReferenceId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interconnect')) {
      interconnect = _json['interconnect'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('mtu')) {
      mtu = _json['mtu'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('operationalStatus')) {
      operationalStatus = _json['operationalStatus'] as core.String;
    }
    if (_json.containsKey('pairingKey')) {
      pairingKey = _json['pairingKey'] as core.String;
    }
    if (_json.containsKey('partnerAsn')) {
      partnerAsn = _json['partnerAsn'] as core.String;
    }
    if (_json.containsKey('partnerMetadata')) {
      partnerMetadata = InterconnectAttachmentPartnerMetadata.fromJson(
          _json['partnerMetadata'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('privateInterconnectInfo')) {
      privateInterconnectInfo = InterconnectAttachmentPrivateInfo.fromJson(
          _json['privateInterconnectInfo']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('router')) {
      router = _json['router'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
    if (_json.containsKey('vlanTag8021q')) {
      vlanTag8021q = _json['vlanTag8021q'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (adminEnabled != null) 'adminEnabled': adminEnabled!,
        if (bandwidth != null) 'bandwidth': bandwidth!,
        if (candidateSubnets != null) 'candidateSubnets': candidateSubnets!,
        if (cloudRouterIpAddress != null)
          'cloudRouterIpAddress': cloudRouterIpAddress!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customerRouterIpAddress != null)
          'customerRouterIpAddress': customerRouterIpAddress!,
        if (dataplaneVersion != null) 'dataplaneVersion': dataplaneVersion!,
        if (description != null) 'description': description!,
        if (edgeAvailabilityDomain != null)
          'edgeAvailabilityDomain': edgeAvailabilityDomain!,
        if (googleReferenceId != null) 'googleReferenceId': googleReferenceId!,
        if (id != null) 'id': id!,
        if (interconnect != null) 'interconnect': interconnect!,
        if (kind != null) 'kind': kind!,
        if (mtu != null) 'mtu': mtu!,
        if (name != null) 'name': name!,
        if (operationalStatus != null) 'operationalStatus': operationalStatus!,
        if (pairingKey != null) 'pairingKey': pairingKey!,
        if (partnerAsn != null) 'partnerAsn': partnerAsn!,
        if (partnerMetadata != null)
          'partnerMetadata': partnerMetadata!.toJson(),
        if (privateInterconnectInfo != null)
          'privateInterconnectInfo': privateInterconnectInfo!.toJson(),
        if (region != null) 'region': region!,
        if (router != null) 'router': router!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
        if (type != null) 'type': type!,
        if (vlanTag8021q != null) 'vlanTag8021q': vlanTag8021q!,
      };
}

class InterconnectAttachmentAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentAggregatedListWarningData();

  InterconnectAttachmentAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectAttachmentAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentAggregatedListWarning();

  InterconnectAttachmentAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentAggregatedListWarningData>((value) =>
              InterconnectAttachmentAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InterconnectAttachmentAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectAttachmentsScopedList resources.
  core.Map<core.String, InterconnectAttachmentsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectAttachmentAggregatedList for aggregated lists
  /// of interconnect attachments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectAttachmentAggregatedListWarning? warning;

  InterconnectAttachmentAggregatedList();

  InterconnectAttachmentAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          InterconnectAttachmentsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class InterconnectAttachmentListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentListWarningData();

  InterconnectAttachmentListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectAttachmentListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentListWarning();

  InterconnectAttachmentListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentListWarningData>((value) =>
              InterconnectAttachmentListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnect
/// attachments.
class InterconnectAttachmentList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectAttachment resources.
  core.List<InterconnectAttachment>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectAttachmentList for lists of interconnect
  /// attachments.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectAttachmentListWarning? warning;

  InterconnectAttachmentList();

  InterconnectAttachmentList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InterconnectAttachment>((value) =>
              InterconnectAttachment.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Informational metadata about Partner attachments from Partners to display to
/// customers.
///
/// These fields are propagated from PARTNER_PROVIDER attachments to their
/// corresponding PARTNER attachments.
class InterconnectAttachmentPartnerMetadata {
  /// Plain text name of the Interconnect this attachment is connected to, as
  /// displayed in the Partner's portal.
  ///
  /// For instance "Chicago 1". This value may be validated to match approved
  /// Partner values.
  core.String? interconnectName;

  /// Plain text name of the Partner providing this attachment.
  ///
  /// This value may be validated to match approved Partner values.
  core.String? partnerName;

  /// URL of the Partner's portal for this Attachment.
  ///
  /// Partners may customise this to be a deep link to the specific resource on
  /// the Partner portal. This value may be validated to match approved Partner
  /// values.
  core.String? portalUrl;

  InterconnectAttachmentPartnerMetadata();

  InterconnectAttachmentPartnerMetadata.fromJson(core.Map _json) {
    if (_json.containsKey('interconnectName')) {
      interconnectName = _json['interconnectName'] as core.String;
    }
    if (_json.containsKey('partnerName')) {
      partnerName = _json['partnerName'] as core.String;
    }
    if (_json.containsKey('portalUrl')) {
      portalUrl = _json['portalUrl'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (interconnectName != null) 'interconnectName': interconnectName!,
        if (partnerName != null) 'partnerName': partnerName!,
        if (portalUrl != null) 'portalUrl': portalUrl!,
      };
}

/// Information for an interconnect attachment when this belongs to an
/// interconnect of type DEDICATED.
class InterconnectAttachmentPrivateInfo {
  /// 802.1q encapsulation tag to be used for traffic between Google and the
  /// customer, going to and from this network and region.
  ///
  /// Output only.
  core.int? tag8021q;

  InterconnectAttachmentPrivateInfo();

  InterconnectAttachmentPrivateInfo.fromJson(core.Map _json) {
    if (_json.containsKey('tag8021q')) {
      tag8021q = _json['tag8021q'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (tag8021q != null) 'tag8021q': tag8021q!,
      };
}

class InterconnectAttachmentsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectAttachmentsScopedListWarningData();

  InterconnectAttachmentsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class InterconnectAttachmentsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectAttachmentsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectAttachmentsScopedListWarning();

  InterconnectAttachmentsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectAttachmentsScopedListWarningData>((value) =>
              InterconnectAttachmentsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class InterconnectAttachmentsScopedList {
  /// A list of interconnect attachments contained in this scope.
  core.List<InterconnectAttachment>? interconnectAttachments;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  InterconnectAttachmentsScopedListWarning? warning;

  InterconnectAttachmentsScopedList();

  InterconnectAttachmentsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('interconnectAttachments')) {
      interconnectAttachments = (_json['interconnectAttachments'] as core.List)
          .map<InterconnectAttachment>((value) =>
              InterconnectAttachment.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectAttachmentsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (interconnectAttachments != null)
          'interconnectAttachments':
              interconnectAttachments!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Describes a single physical circuit between the Customer and Google.
///
/// CircuitInfo objects are created by Google, so all fields are output only.
class InterconnectCircuitInfo {
  /// Customer-side demarc ID for this circuit.
  core.String? customerDemarcId;

  /// Google-assigned unique ID for this circuit.
  ///
  /// Assigned at circuit turn-up.
  core.String? googleCircuitId;

  /// Google-side demarc ID for this circuit.
  ///
  /// Assigned at circuit turn-up and provided by Google to the customer in the
  /// LOA.
  core.String? googleDemarcId;

  InterconnectCircuitInfo();

  InterconnectCircuitInfo.fromJson(core.Map _json) {
    if (_json.containsKey('customerDemarcId')) {
      customerDemarcId = _json['customerDemarcId'] as core.String;
    }
    if (_json.containsKey('googleCircuitId')) {
      googleCircuitId = _json['googleCircuitId'] as core.String;
    }
    if (_json.containsKey('googleDemarcId')) {
      googleDemarcId = _json['googleDemarcId'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (customerDemarcId != null) 'customerDemarcId': customerDemarcId!,
        if (googleCircuitId != null) 'googleCircuitId': googleCircuitId!,
        if (googleDemarcId != null) 'googleDemarcId': googleDemarcId!,
      };
}

/// Diagnostics information about interconnect, contains detailed and current
/// technical information about Google's side of the connection.
class InterconnectDiagnostics {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing individual
  /// neighbors currently seen by the Google router in the ARP cache for the
  /// Interconnect.
  ///
  /// This will be empty when the Interconnect is not bundled.
  core.List<InterconnectDiagnosticsARPEntry>? arpCaches;

  /// A list of InterconnectDiagnostics.LinkStatus objects, describing the
  /// status for each link on the Interconnect.
  core.List<InterconnectDiagnosticsLinkStatus>? links;

  /// The MAC address of the Interconnect's bundle interface.
  core.String? macAddress;

  InterconnectDiagnostics();

  InterconnectDiagnostics.fromJson(core.Map _json) {
    if (_json.containsKey('arpCaches')) {
      arpCaches = (_json['arpCaches'] as core.List)
          .map<InterconnectDiagnosticsARPEntry>((value) =>
              InterconnectDiagnosticsARPEntry.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('links')) {
      links = (_json['links'] as core.List)
          .map<InterconnectDiagnosticsLinkStatus>((value) =>
              InterconnectDiagnosticsLinkStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('macAddress')) {
      macAddress = _json['macAddress'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (arpCaches != null)
          'arpCaches': arpCaches!.map((value) => value.toJson()).toList(),
        if (links != null)
          'links': links!.map((value) => value.toJson()).toList(),
        if (macAddress != null) 'macAddress': macAddress!,
      };
}

/// Describing the ARP neighbor entries seen on this link
class InterconnectDiagnosticsARPEntry {
  /// The IP address of this ARP neighbor.
  core.String? ipAddress;

  /// The MAC address of this ARP neighbor.
  core.String? macAddress;

  InterconnectDiagnosticsARPEntry();

  InterconnectDiagnosticsARPEntry.fromJson(core.Map _json) {
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('macAddress')) {
      macAddress = _json['macAddress'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (macAddress != null) 'macAddress': macAddress!,
      };
}

class InterconnectDiagnosticsLinkLACPStatus {
  /// System ID of the port on Google's side of the LACP exchange.
  core.String? googleSystemId;

  /// System ID of the port on the neighbor's side of the LACP exchange.
  core.String? neighborSystemId;

  /// The state of a LACP link, which can take one of the following values:
  /// - ACTIVE: The link is configured and active within the bundle.
  ///
  ///
  /// - DETACHED: The link is not configured within the bundle. This means that
  /// the rest of the object should be empty.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "DETACHED"
  core.String? state;

  InterconnectDiagnosticsLinkLACPStatus();

  InterconnectDiagnosticsLinkLACPStatus.fromJson(core.Map _json) {
    if (_json.containsKey('googleSystemId')) {
      googleSystemId = _json['googleSystemId'] as core.String;
    }
    if (_json.containsKey('neighborSystemId')) {
      neighborSystemId = _json['neighborSystemId'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (googleSystemId != null) 'googleSystemId': googleSystemId!,
        if (neighborSystemId != null) 'neighborSystemId': neighborSystemId!,
        if (state != null) 'state': state!,
      };
}

class InterconnectDiagnosticsLinkOpticalPower {
  /// The status of the current value when compared to the warning and alarm
  /// levels for the receiving or transmitting transceiver.
  ///
  /// Possible states include:
  /// - OK: The value has not crossed a warning threshold.
  /// - LOW_WARNING: The value has crossed below the low warning threshold.
  /// - HIGH_WARNING: The value has crossed above the high warning threshold.
  /// - LOW_ALARM: The value has crossed below the low alarm threshold.
  /// - HIGH_ALARM: The value has crossed above the high alarm threshold.
  /// Possible string values are:
  /// - "HIGH_ALARM"
  /// - "HIGH_WARNING"
  /// - "LOW_ALARM"
  /// - "LOW_WARNING"
  /// - "OK"
  core.String? state;

  /// Value of the current receiving or transmitting optical power, read in dBm.
  ///
  /// Take a known good optical value, give it a 10% margin and trigger warnings
  /// relative to that value. In general, a -7dBm warning and a -11dBm alarm are
  /// good optical value estimates for most links.
  core.double? value;

  InterconnectDiagnosticsLinkOpticalPower();

  InterconnectDiagnosticsLinkOpticalPower.fromJson(core.Map _json) {
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = (_json['value'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (state != null) 'state': state!,
        if (value != null) 'value': value!,
      };
}

class InterconnectDiagnosticsLinkStatus {
  /// A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
  /// neighbor entries seen on this link.
  ///
  /// This will be empty if the link is bundled
  core.List<InterconnectDiagnosticsARPEntry>? arpCaches;

  /// The unique ID for this link assigned during turn up by Google.
  core.String? circuitId;

  /// The Demarc address assigned by Google and provided in the LoA.
  core.String? googleDemarc;
  InterconnectDiagnosticsLinkLACPStatus? lacpStatus;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the received light level.
  InterconnectDiagnosticsLinkOpticalPower? receivingOpticalPower;

  /// An InterconnectDiagnostics.LinkOpticalPower object, describing the current
  /// value and status of the transmitted light level.
  InterconnectDiagnosticsLinkOpticalPower? transmittingOpticalPower;

  InterconnectDiagnosticsLinkStatus();

  InterconnectDiagnosticsLinkStatus.fromJson(core.Map _json) {
    if (_json.containsKey('arpCaches')) {
      arpCaches = (_json['arpCaches'] as core.List)
          .map<InterconnectDiagnosticsARPEntry>((value) =>
              InterconnectDiagnosticsARPEntry.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('circuitId')) {
      circuitId = _json['circuitId'] as core.String;
    }
    if (_json.containsKey('googleDemarc')) {
      googleDemarc = _json['googleDemarc'] as core.String;
    }
    if (_json.containsKey('lacpStatus')) {
      lacpStatus = InterconnectDiagnosticsLinkLACPStatus.fromJson(
          _json['lacpStatus'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('receivingOpticalPower')) {
      receivingOpticalPower = InterconnectDiagnosticsLinkOpticalPower.fromJson(
          _json['receivingOpticalPower']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('transmittingOpticalPower')) {
      transmittingOpticalPower =
          InterconnectDiagnosticsLinkOpticalPower.fromJson(
              _json['transmittingOpticalPower']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (arpCaches != null)
          'arpCaches': arpCaches!.map((value) => value.toJson()).toList(),
        if (circuitId != null) 'circuitId': circuitId!,
        if (googleDemarc != null) 'googleDemarc': googleDemarc!,
        if (lacpStatus != null) 'lacpStatus': lacpStatus!.toJson(),
        if (receivingOpticalPower != null)
          'receivingOpticalPower': receivingOpticalPower!.toJson(),
        if (transmittingOpticalPower != null)
          'transmittingOpticalPower': transmittingOpticalPower!.toJson(),
      };
}

class InterconnectListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectListWarningData();

  InterconnectListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectListWarning();

  InterconnectListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectListWarningData>((value) =>
              InterconnectListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnects.
class InterconnectList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Interconnect resources.
  core.List<Interconnect>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectList for lists of interconnects.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectListWarning? warning;

  InterconnectList();

  InterconnectList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Interconnect>((value) => Interconnect.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents an Interconnect Attachment (VLAN) Location resource.
///
/// You can use this resource to find location details about an Interconnect
/// attachment (VLAN).
///
/// For more information about interconnect attachments, read Creating VLAN
/// Attachments.
class InterconnectLocation {
  /// The postal address of the Point of Presence, each line in the address is
  /// separated by a newline character.
  ///
  /// Output only.
  core.String? address;

  /// Availability zone for this InterconnectLocation.
  ///
  /// Within a metropolitan area (metro), maintenance will not be simultaneously
  /// scheduled in more than one availability zone. Example: "zone1" or "zone2".
  ///
  /// Output only.
  core.String? availabilityZone;

  /// Metropolitan area designator that indicates which city an interconnect is
  /// located.
  ///
  /// For example: "Chicago, IL", "Amsterdam, Netherlands".
  ///
  /// Output only.
  core.String? city;

  /// Continent for this location, which can take one of the following values:
  /// - AFRICA
  /// - ASIA_PAC
  /// - EUROPE
  /// - NORTH_AMERICA
  /// - SOUTH_AMERICA
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AFRICA"
  /// - "ASIA_PAC"
  /// - "C_AFRICA"
  /// - "C_ASIA_PAC"
  /// - "C_EUROPE"
  /// - "C_NORTH_AMERICA"
  /// - "C_SOUTH_AMERICA"
  /// - "EUROPE"
  /// - "NORTH_AMERICA"
  /// - "SOUTH_AMERICA"
  core.String? continent;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The name of the provider for this facility (e.g., EQUINIX).
  ///
  /// Output only.
  core.String? facilityProvider;

  /// A provider-assigned Identifier for this facility (e.g., Ashburn-DC1).
  ///
  /// Output only.
  core.String? facilityProviderFacilityId;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#interconnectLocation for interconnect locations.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// The peeringdb identifier for this facility (corresponding with a netfac
  /// type in peeringdb).
  ///
  /// Output only.
  core.String? peeringdbFacilityId;

  /// A list of InterconnectLocation.RegionInfo objects, that describe
  /// parameters pertaining to the relation between this InterconnectLocation
  /// and various Google Cloud regions.
  ///
  /// Output only.
  core.List<InterconnectLocationRegionInfo>? regionInfos;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of this InterconnectLocation, which can take one of the
  /// following values:
  /// - CLOSED: The InterconnectLocation is closed and is unavailable for
  /// provisioning new Interconnects.
  ///
  ///
  /// - AVAILABLE: The InterconnectLocation is available for provisioning new
  /// Interconnects.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "AVAILABLE"
  /// - "CLOSED"
  core.String? status;

  InterconnectLocation();

  InterconnectLocation.fromJson(core.Map _json) {
    if (_json.containsKey('address')) {
      address = _json['address'] as core.String;
    }
    if (_json.containsKey('availabilityZone')) {
      availabilityZone = _json['availabilityZone'] as core.String;
    }
    if (_json.containsKey('city')) {
      city = _json['city'] as core.String;
    }
    if (_json.containsKey('continent')) {
      continent = _json['continent'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('facilityProvider')) {
      facilityProvider = _json['facilityProvider'] as core.String;
    }
    if (_json.containsKey('facilityProviderFacilityId')) {
      facilityProviderFacilityId =
          _json['facilityProviderFacilityId'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peeringdbFacilityId')) {
      peeringdbFacilityId = _json['peeringdbFacilityId'] as core.String;
    }
    if (_json.containsKey('regionInfos')) {
      regionInfos = (_json['regionInfos'] as core.List)
          .map<InterconnectLocationRegionInfo>((value) =>
              InterconnectLocationRegionInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (address != null) 'address': address!,
        if (availabilityZone != null) 'availabilityZone': availabilityZone!,
        if (city != null) 'city': city!,
        if (continent != null) 'continent': continent!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (facilityProvider != null) 'facilityProvider': facilityProvider!,
        if (facilityProviderFacilityId != null)
          'facilityProviderFacilityId': facilityProviderFacilityId!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (peeringdbFacilityId != null)
          'peeringdbFacilityId': peeringdbFacilityId!,
        if (regionInfos != null)
          'regionInfos': regionInfos!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
      };
}

class InterconnectLocationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  InterconnectLocationListWarningData();

  InterconnectLocationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class InterconnectLocationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<InterconnectLocationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  InterconnectLocationListWarning();

  InterconnectLocationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<InterconnectLocationListWarningData>((value) =>
              InterconnectLocationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Response to the list request, and contains a list of interconnect locations.
class InterconnectLocationList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InterconnectLocation resources.
  core.List<InterconnectLocation>? items;

  /// Type of resource.
  ///
  /// Always compute#interconnectLocationList for lists of interconnect
  /// locations.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  InterconnectLocationListWarning? warning;

  InterconnectLocationList();

  InterconnectLocationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InterconnectLocation>((value) => InterconnectLocation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = InterconnectLocationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Information about any potential InterconnectAttachments between an
/// Interconnect at a specific InterconnectLocation, and a specific Cloud
/// Region.
class InterconnectLocationRegionInfo {
  /// Expected round-trip time in milliseconds, from this InterconnectLocation
  /// to a VM in this region.
  core.String? expectedRttMs;

  /// Identifies the network presence of this location.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "LOCAL_REGION"
  /// - "LP_GLOBAL"
  /// - "LP_LOCAL_REGION"
  core.String? locationPresence;

  /// URL for the region of this location.
  core.String? region;

  InterconnectLocationRegionInfo();

  InterconnectLocationRegionInfo.fromJson(core.Map _json) {
    if (_json.containsKey('expectedRttMs')) {
      expectedRttMs = _json['expectedRttMs'] as core.String;
    }
    if (_json.containsKey('locationPresence')) {
      locationPresence = _json['locationPresence'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (expectedRttMs != null) 'expectedRttMs': expectedRttMs!,
        if (locationPresence != null) 'locationPresence': locationPresence!,
        if (region != null) 'region': region!,
      };
}

/// Description of a planned outage on this Interconnect.
class InterconnectOutageNotification {
  /// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs
  /// that will be affected.
  core.List<core.String>? affectedCircuits;

  /// A description about the purpose of the outage.
  core.String? description;

  /// Scheduled end time for the outage (milliseconds since Unix epoch).
  core.String? endTime;

  /// Form this outage is expected to take, which can take one of the following
  /// values:
  /// - OUTAGE: The Interconnect may be completely out of service for some or
  /// all of the specified window.
  ///
  ///
  /// - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole
  /// should remain up, but with reduced bandwidth. Note that the versions of
  /// this enum prefixed with "IT_" have been deprecated in favor of the
  /// unprefixed values.
  /// Possible string values are:
  /// - "IT_OUTAGE"
  /// - "IT_PARTIAL_OUTAGE"
  /// - "OUTAGE"
  /// - "PARTIAL_OUTAGE"
  core.String? issueType;

  /// Unique identifier for this outage notification.
  core.String? name;

  /// The party that generated this notification, which can take the following
  /// value:
  /// - GOOGLE: this notification as generated by Google.
  ///
  /// Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
  /// Possible string values are:
  /// - "GOOGLE"
  /// - "NSRC_GOOGLE"
  core.String? source;

  /// Scheduled start time for the outage (milliseconds since Unix epoch).
  core.String? startTime;

  /// State of this notification, which can take one of the following values:
  /// - ACTIVE: This outage notification is active.
  ///
  /// The event could be in the past, present, or future. See start_time and
  /// end_time for scheduling.
  /// - CANCELLED: The outage associated with this notification was cancelled
  /// before the outage was due to start. Note that the versions of this enum
  /// prefixed with "NS_" have been deprecated in favor of the unprefixed
  /// values.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "CANCELLED"
  /// - "COMPLETED"
  /// - "NS_ACTIVE"
  /// - "NS_CANCELED"
  core.String? state;

  InterconnectOutageNotification();

  InterconnectOutageNotification.fromJson(core.Map _json) {
    if (_json.containsKey('affectedCircuits')) {
      affectedCircuits = (_json['affectedCircuits'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTime')) {
      endTime = _json['endTime'] as core.String;
    }
    if (_json.containsKey('issueType')) {
      issueType = _json['issueType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (affectedCircuits != null) 'affectedCircuits': affectedCircuits!,
        if (description != null) 'description': description!,
        if (endTime != null) 'endTime': endTime!,
        if (issueType != null) 'issueType': issueType!,
        if (name != null) 'name': name!,
        if (source != null) 'source': source!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
      };
}

/// Response for the InterconnectsGetDiagnosticsRequest.
class InterconnectsGetDiagnosticsResponse {
  InterconnectDiagnostics? result;

  InterconnectsGetDiagnosticsResponse();

  InterconnectsGetDiagnosticsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = InterconnectDiagnostics.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

/// Represents a License resource.
///
/// A License represents billing and aggregate usage data for public and
/// marketplace images.
///
/// Caution This resource is intended for use only by third-party partners who
/// are creating Cloud Marketplace images. (== resource_for
/// {$api_version}.licenses ==)
class License {
  /// This field no longer reflects whether a license charges a usage fee.
  ///
  /// Output only. Deprecated.
  core.bool? chargesUseFee;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional textual description of the resource; provided by the client
  /// when the resource is created.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#license for licenses.
  ///
  /// Output only.
  core.String? kind;

  /// The unique code used to attach this license to images, snapshots, and
  /// disks.
  ///
  /// Output only.
  core.String? licenseCode;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long and comply with RFC1035.
  core.String? name;
  LicenseResourceRequirements? resourceRequirements;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If false, licenses will not be copied from the source resource when
  /// creating an image from a disk, disk from snapshot, or snapshot from disk.
  core.bool? transferable;

  License();

  License.fromJson(core.Map _json) {
    if (_json.containsKey('chargesUseFee')) {
      chargesUseFee = _json['chargesUseFee'] as core.bool;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseCode')) {
      licenseCode = _json['licenseCode'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('resourceRequirements')) {
      resourceRequirements = LicenseResourceRequirements.fromJson(
          _json['resourceRequirements'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('transferable')) {
      transferable = _json['transferable'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (chargesUseFee != null) 'chargesUseFee': chargesUseFee!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseCode != null) 'licenseCode': licenseCode!,
        if (name != null) 'name': name!,
        if (resourceRequirements != null)
          'resourceRequirements': resourceRequirements!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (transferable != null) 'transferable': transferable!,
      };
}

/// Represents a License Code resource.
///
/// A License Code is a unique identifier used to represent a license resource.
///
/// Caution This resource is intended for use only by third-party partners who
/// are creating Cloud Marketplace images. (== resource_for
/// {$api_version}.licenseCodes ==)
class LicenseCode {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// Description of this License Code.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#licenseCode for licenses.
  ///
  /// Output only.
  core.String? kind;

  /// URL and description aliases of Licenses with the same License Code.
  ///
  /// Output only.
  core.List<LicenseCodeLicenseAlias>? licenseAlias;

  /// Name of the resource.
  ///
  /// The name is 1-20 characters long and must be a valid 64 bit integer.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Current state of this License Code.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DISABLED"
  /// - "ENABLED"
  /// - "RESTRICTED"
  /// - "STATE_UNSPECIFIED"
  /// - "TERMINATED"
  core.String? state;

  /// If true, the license will remain attached when creating images or
  /// snapshots from disks.
  ///
  /// Otherwise, the license is not transferred.
  ///
  /// Output only.
  core.bool? transferable;

  LicenseCode();

  LicenseCode.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('licenseAlias')) {
      licenseAlias = (_json['licenseAlias'] as core.List)
          .map<LicenseCodeLicenseAlias>((value) =>
              LicenseCodeLicenseAlias.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('transferable')) {
      transferable = _json['transferable'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (licenseAlias != null)
          'licenseAlias': licenseAlias!.map((value) => value.toJson()).toList(),
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
        if (transferable != null) 'transferable': transferable!,
      };
}

class LicenseCodeLicenseAlias {
  /// Description of this License Code.
  ///
  /// Output only.
  core.String? description;

  /// URL of license corresponding to this License Code.
  ///
  /// Output only.
  core.String? selfLink;

  LicenseCodeLicenseAlias();

  LicenseCodeLicenseAlias.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Commitment for a particular license resource.
class LicenseResourceCommitment {
  /// The number of licenses purchased.
  core.String? amount;

  /// Specifies the core range of the instance for which this license applies.
  core.String? coresPerLicense;

  /// Any applicable license URI.
  core.String? license;

  LicenseResourceCommitment();

  LicenseResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey('amount')) {
      amount = _json['amount'] as core.String;
    }
    if (_json.containsKey('coresPerLicense')) {
      coresPerLicense = _json['coresPerLicense'] as core.String;
    }
    if (_json.containsKey('license')) {
      license = _json['license'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (amount != null) 'amount': amount!,
        if (coresPerLicense != null) 'coresPerLicense': coresPerLicense!,
        if (license != null) 'license': license!,
      };
}

class LicenseResourceRequirements {
  /// Minimum number of guest cpus required to use the Instance.
  ///
  /// Enforced at Instance creation and Instance start.
  core.int? minGuestCpuCount;

  /// Minimum memory required to use the Instance.
  ///
  /// Enforced at Instance creation and Instance start.
  core.int? minMemoryMb;

  LicenseResourceRequirements();

  LicenseResourceRequirements.fromJson(core.Map _json) {
    if (_json.containsKey('minGuestCpuCount')) {
      minGuestCpuCount = _json['minGuestCpuCount'] as core.int;
    }
    if (_json.containsKey('minMemoryMb')) {
      minMemoryMb = _json['minMemoryMb'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (minGuestCpuCount != null) 'minGuestCpuCount': minGuestCpuCount!,
        if (minMemoryMb != null) 'minMemoryMb': minMemoryMb!,
      };
}

class LicensesListResponseWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  LicensesListResponseWarningData();

  LicensesListResponseWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class LicensesListResponseWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<LicensesListResponseWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  LicensesListResponseWarning();

  LicensesListResponseWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<LicensesListResponseWarningData>((value) =>
              LicensesListResponseWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class LicensesListResponse {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of License resources.
  core.List<License>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  LicensesListResponseWarning? warning;

  LicensesListResponse();

  LicensesListResponse.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<License>((value) =>
              License.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = LicensesListResponseWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class LocalDisk {
  /// Specifies the number of such disks.
  core.int? diskCount;

  /// Specifies the size of the disk in base-2 GB.
  core.int? diskSizeGb;

  /// Specifies the desired disk type on the node.
  ///
  /// This disk type must be a local storage type (e.g.: local-ssd). Note that
  /// for nodeTemplates, this should be the name of the disk type and not its
  /// URL.
  core.String? diskType;

  LocalDisk();

  LocalDisk.fromJson(core.Map _json) {
    if (_json.containsKey('diskCount')) {
      diskCount = _json['diskCount'] as core.int;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.int;
    }
    if (_json.containsKey('diskType')) {
      diskType = _json['diskType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskCount != null) 'diskCount': diskCount!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
      };
}

/// Configuration for location policy among multiple possible locations (e.g.
/// preferences for zone selection among zones in a single region).
class LocationPolicy {
  /// Location configurations mapped by location name.
  ///
  /// Currently only zone names are supported and must be represented as valid
  /// internal URLs, like: zones/us-central1-a.
  core.Map<core.String, LocationPolicyLocation>? locations;

  LocationPolicy();

  LocationPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('locations')) {
      locations =
          (_json['locations'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          LocationPolicyLocation.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (locations != null)
          'locations':
              locations!.map((key, item) => core.MapEntry(key, item.toJson())),
      };
}

class LocationPolicyLocation {
  ///
  /// Possible string values are:
  /// - "ALLOW"
  /// - "DENY"
  /// - "PREFERENCE_UNSPECIFIED"
  core.String? preference;

  LocationPolicyLocation();

  LocationPolicyLocation.fromJson(core.Map _json) {
    if (_json.containsKey('preference')) {
      preference = _json['preference'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (preference != null) 'preference': preference!,
      };
}

/// Specifies what kind of log the caller must write
class LogConfig {
  /// Cloud audit options.
  LogConfigCloudAuditOptions? cloudAudit;

  /// Counter options.
  LogConfigCounterOptions? counter;

  /// Data access options.
  LogConfigDataAccessOptions? dataAccess;

  LogConfig();

  LogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('cloudAudit')) {
      cloudAudit = LogConfigCloudAuditOptions.fromJson(
          _json['cloudAudit'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('counter')) {
      counter = LogConfigCounterOptions.fromJson(
          _json['counter'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('dataAccess')) {
      dataAccess = LogConfigDataAccessOptions.fromJson(
          _json['dataAccess'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (cloudAudit != null) 'cloudAudit': cloudAudit!.toJson(),
        if (counter != null) 'counter': counter!.toJson(),
        if (dataAccess != null) 'dataAccess': dataAccess!.toJson(),
      };
}

/// Write a Cloud Audit log
class LogConfigCloudAuditOptions {
  /// Information used by the Cloud Audit Logging pipeline.
  AuthorizationLoggingOptions? authorizationLoggingOptions;

  /// The log_name to populate in the Cloud Audit Record.
  /// Possible string values are:
  /// - "ADMIN_ACTIVITY"
  /// - "DATA_ACCESS"
  /// - "UNSPECIFIED_LOG_NAME"
  core.String? logName;

  LogConfigCloudAuditOptions();

  LogConfigCloudAuditOptions.fromJson(core.Map _json) {
    if (_json.containsKey('authorizationLoggingOptions')) {
      authorizationLoggingOptions = AuthorizationLoggingOptions.fromJson(
          _json['authorizationLoggingOptions']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('logName')) {
      logName = _json['logName'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (authorizationLoggingOptions != null)
          'authorizationLoggingOptions': authorizationLoggingOptions!.toJson(),
        if (logName != null) 'logName': logName!,
      };
}

/// Increment a streamz counter with the specified metric and field names.
///
/// Metric names should start with a '/', generally be lowercase-only, and end
/// in "_count".
///
/// Field names should not contain an initial slash. The actual exported metric
/// names will have "/iam/policy" prepended.
///
/// Field names correspond to IAM request parameters and field values are their
/// respective values.
///
/// Supported field names: - "authority", which is "\[token\]" if
/// IAMContext.token is present, otherwise the value of
/// IAMContext.authority_selector if present, and otherwise a representation of
/// IAMContext.principal; or - "iam_principal", a representation of
/// IAMContext.principal even if a token or authority selector is present; or -
/// "" (empty string), resulting in a counter with no fields.
///
/// Examples: counter { metric: "/debug_access_count" field: "iam_principal" }
/// ==> increment counter /iam/policy/debug_access_count {iam_principal=\[value
/// of IAMContext.principal\]}
class LogConfigCounterOptions {
  /// Custom fields.
  core.List<LogConfigCounterOptionsCustomField>? customFields;

  /// The field value to attribute.
  core.String? field;

  /// The metric to update.
  core.String? metric;

  LogConfigCounterOptions();

  LogConfigCounterOptions.fromJson(core.Map _json) {
    if (_json.containsKey('customFields')) {
      customFields = (_json['customFields'] as core.List)
          .map<LogConfigCounterOptionsCustomField>((value) =>
              LogConfigCounterOptionsCustomField.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('field')) {
      field = _json['field'] as core.String;
    }
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (customFields != null)
          'customFields': customFields!.map((value) => value.toJson()).toList(),
        if (field != null) 'field': field!,
        if (metric != null) 'metric': metric!,
      };
}

/// Custom fields.
///
/// These can be used to create a counter with arbitrary field/value pairs. See:
/// go/rpcsp-custom-fields.
class LogConfigCounterOptionsCustomField {
  /// Name is the field name.
  core.String? name;

  /// Value is the field value.
  ///
  /// It is important that in contrast to the CounterOptions.field, the value
  /// here is a constant that is not derived from the IAMContext.
  core.String? value;

  LogConfigCounterOptionsCustomField();

  LogConfigCounterOptionsCustomField.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Write a Data Access (Gin) log
class LogConfigDataAccessOptions {
  ///
  /// Possible string values are:
  /// - "LOG_FAIL_CLOSED"
  /// - "LOG_MODE_UNSPECIFIED"
  core.String? logMode;

  LogConfigDataAccessOptions();

  LogConfigDataAccessOptions.fromJson(core.Map _json) {
    if (_json.containsKey('logMode')) {
      logMode = _json['logMode'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (logMode != null) 'logMode': logMode!,
      };
}

class MachineTypeAccelerators {
  /// Number of accelerator cards exposed to the guest.
  core.int? guestAcceleratorCount;

  /// The accelerator type resource name, not a full URL, e.g.
  /// 'nvidia-tesla-k80'.
  core.String? guestAcceleratorType;

  MachineTypeAccelerators();

  MachineTypeAccelerators.fromJson(core.Map _json) {
    if (_json.containsKey('guestAcceleratorCount')) {
      guestAcceleratorCount = _json['guestAcceleratorCount'] as core.int;
    }
    if (_json.containsKey('guestAcceleratorType')) {
      guestAcceleratorType = _json['guestAcceleratorType'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (guestAcceleratorCount != null)
          'guestAcceleratorCount': guestAcceleratorCount!,
        if (guestAcceleratorType != null)
          'guestAcceleratorType': guestAcceleratorType!,
      };
}

class MachineTypeScratchDisks {
  /// Size of the scratch disk, defined in GB.
  core.int? diskGb;

  MachineTypeScratchDisks();

  MachineTypeScratchDisks.fromJson(core.Map _json) {
    if (_json.containsKey('diskGb')) {
      diskGb = _json['diskGb'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskGb != null) 'diskGb': diskGb!,
      };
}

/// Represents a Machine Type resource.
///
/// You can use specific machine types for your VM instances based on
/// performance and pricing requirements.
///
/// For more information, read Machine Types. (== resource_for
/// {$api_version}.machineTypes ==)
class MachineType {
  /// A list of accelerator configurations assigned to this machine type.
  ///
  /// Output only.
  core.List<MachineTypeAccelerators>? accelerators;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this machine type.
  ///
  /// Only applicable if the machine type is unavailable.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The number of virtual CPUs that are available to the instance.
  ///
  /// Output only.
  core.int? guestCpus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// This property is deprecated and will never be populated with any relevant
  /// values.
  ///
  /// Deprecated.
  core.int? imageSpaceGb;

  /// Whether this machine type has a shared CPU.
  ///
  /// See Shared-core machine types for more information.
  ///
  /// Output only.
  core.bool? isSharedCpu;

  /// The type of the resource.
  ///
  /// Always compute#machineType for machine types.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum persistent disks allowed.
  ///
  /// Output only.
  core.int? maximumPersistentDisks;

  /// Maximum total persistent disks size (GB) allowed.
  ///
  /// Output only.
  core.String? maximumPersistentDisksSizeGb;

  /// The amount of physical memory available to the instance, defined in MB.
  ///
  /// Output only.
  core.int? memoryMb;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// A list of extended scratch disks assigned to the instance.
  ///
  /// Output only.
  core.List<MachineTypeScratchDisks>? scratchDisks;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the machine type resides, such as
  /// us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  MachineType();

  MachineType.fromJson(core.Map _json) {
    if (_json.containsKey('accelerators')) {
      accelerators = (_json['accelerators'] as core.List)
          .map<MachineTypeAccelerators>((value) =>
              MachineTypeAccelerators.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('guestCpus')) {
      guestCpus = _json['guestCpus'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('imageSpaceGb')) {
      imageSpaceGb = _json['imageSpaceGb'] as core.int;
    }
    if (_json.containsKey('isSharedCpu')) {
      isSharedCpu = _json['isSharedCpu'] as core.bool;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('maximumPersistentDisks')) {
      maximumPersistentDisks = _json['maximumPersistentDisks'] as core.int;
    }
    if (_json.containsKey('maximumPersistentDisksSizeGb')) {
      maximumPersistentDisksSizeGb =
          _json['maximumPersistentDisksSizeGb'] as core.String;
    }
    if (_json.containsKey('memoryMb')) {
      memoryMb = _json['memoryMb'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('scratchDisks')) {
      scratchDisks = (_json['scratchDisks'] as core.List)
          .map<MachineTypeScratchDisks>((value) =>
              MachineTypeScratchDisks.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (guestCpus != null) 'guestCpus': guestCpus!,
        if (id != null) 'id': id!,
        if (imageSpaceGb != null) 'imageSpaceGb': imageSpaceGb!,
        if (isSharedCpu != null) 'isSharedCpu': isSharedCpu!,
        if (kind != null) 'kind': kind!,
        if (maximumPersistentDisks != null)
          'maximumPersistentDisks': maximumPersistentDisks!,
        if (maximumPersistentDisksSizeGb != null)
          'maximumPersistentDisksSizeGb': maximumPersistentDisksSizeGb!,
        if (memoryMb != null) 'memoryMb': memoryMb!,
        if (name != null) 'name': name!,
        if (scratchDisks != null)
          'scratchDisks': scratchDisks!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class MachineTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypeAggregatedListWarningData();

  MachineTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class MachineTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypeAggregatedListWarning();

  MachineTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypeAggregatedListWarningData>((value) =>
              MachineTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class MachineTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of MachineTypesScopedList resources.
  core.Map<core.String, MachineTypesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#machineTypeAggregatedList for aggregated lists of machine
  /// types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  MachineTypeAggregatedListWarning? warning;

  MachineTypeAggregatedList();

  MachineTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          MachineTypesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class MachineTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypeListWarningData();

  MachineTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class MachineTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypeListWarning();

  MachineTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypeListWarningData>((value) =>
              MachineTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of machine types.
class MachineTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of MachineType resources.
  core.List<MachineType>? items;

  /// Type of resource.
  ///
  /// Always compute#machineTypeList for lists of machine types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  MachineTypeListWarning? warning;

  MachineTypeList();

  MachineTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<MachineType>((value) => MachineType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class MachineTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  MachineTypesScopedListWarningData();

  MachineTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the machine types list is empty.
///
/// Output only.
class MachineTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<MachineTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  MachineTypesScopedListWarning();

  MachineTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<MachineTypesScopedListWarningData>((value) =>
              MachineTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class MachineTypesScopedList {
  /// A list of machine types contained in this scope.
  ///
  /// Output only.
  core.List<MachineType>? machineTypes;

  /// An informational warning that appears when the machine types list is
  /// empty.
  ///
  /// Output only.
  MachineTypesScopedListWarning? warning;

  MachineTypesScopedList();

  MachineTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('machineTypes')) {
      machineTypes = (_json['machineTypes'] as core.List)
          .map<MachineType>((value) => MachineType.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = MachineTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineTypes != null)
          'machineTypes': machineTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A Managed Instance resource.
class ManagedInstance {
  /// The current action that the managed instance group has scheduled for the
  /// instance.
  ///
  /// Possible values:
  /// - NONE The instance is running, and the managed instance group does not
  /// have any scheduled actions for this instance.
  /// - CREATING The managed instance group is creating this instance. If the
  /// group fails to create this instance, it will try again until it is
  /// successful.
  /// - CREATING_WITHOUT_RETRIES The managed instance group is attempting to
  /// create this instance only once. If the group fails to create this
  /// instance, it does not try again and the group's targetSize value is
  /// decreased instead.
  /// - RECREATING The managed instance group is recreating this instance.
  /// - DELETING The managed instance group is permanently deleting this
  /// instance.
  /// - ABANDONING The managed instance group is abandoning this instance. The
  /// instance will be removed from the instance group and from any target pools
  /// that are associated with this group.
  /// - RESTARTING The managed instance group is restarting the instance.
  /// - REFRESHING The managed instance group is applying configuration changes
  /// to the instance without stopping it. For example, the group can update the
  /// target pool list for an instance without stopping that instance.
  /// - VERIFYING The managed instance group has created the instance and it is
  /// in the process of being verified.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ABANDONING"
  /// - "CREATING"
  /// - "CREATING_WITHOUT_RETRIES"
  /// - "DELETING"
  /// - "NONE"
  /// - "RECREATING"
  /// - "REFRESHING"
  /// - "RESTARTING"
  /// - "VERIFYING"
  core.String? currentAction;

  /// The unique identifier for this resource.
  ///
  /// This field is empty when instance does not exist.
  ///
  /// Output only.
  core.String? id;

  /// The URL of the instance.
  ///
  /// The URL can exist even if the instance has not yet been created.
  ///
  /// Output only.
  core.String? instance;

  /// Health state of the instance per health-check.
  ///
  /// Output only.
  core.List<ManagedInstanceInstanceHealth>? instanceHealth;

  /// The status of the instance.
  ///
  /// This field is empty when the instance does not exist.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DEPROVISIONING"
  /// - "PROVISIONING"
  /// - "REPAIRING"
  /// - "RUNNING"
  /// - "STAGING"
  /// - "STOPPED"
  /// - "STOPPING"
  /// - "SUSPENDED"
  /// - "SUSPENDING"
  /// - "TERMINATED"
  core.String? instanceStatus;

  /// Information about the last attempt to create or delete the instance.
  ///
  /// Output only.
  ManagedInstanceLastAttempt? lastAttempt;

  /// Preserved state applied from per-instance config for this instance.
  ///
  /// Output only.
  PreservedState? preservedStateFromConfig;

  /// Preserved state generated based on stateful policy for this instance.
  ///
  /// Output only.
  PreservedState? preservedStateFromPolicy;

  /// Intended version of this instance.
  ///
  /// Output only.
  ManagedInstanceVersion? version;

  ManagedInstance();

  ManagedInstance.fromJson(core.Map _json) {
    if (_json.containsKey('currentAction')) {
      currentAction = _json['currentAction'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('instanceHealth')) {
      instanceHealth = (_json['instanceHealth'] as core.List)
          .map<ManagedInstanceInstanceHealth>((value) =>
              ManagedInstanceInstanceHealth.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('instanceStatus')) {
      instanceStatus = _json['instanceStatus'] as core.String;
    }
    if (_json.containsKey('lastAttempt')) {
      lastAttempt = ManagedInstanceLastAttempt.fromJson(
          _json['lastAttempt'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preservedStateFromConfig')) {
      preservedStateFromConfig = PreservedState.fromJson(
          _json['preservedStateFromConfig']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preservedStateFromPolicy')) {
      preservedStateFromPolicy = PreservedState.fromJson(
          _json['preservedStateFromPolicy']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('version')) {
      version = ManagedInstanceVersion.fromJson(
          _json['version'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (currentAction != null) 'currentAction': currentAction!,
        if (id != null) 'id': id!,
        if (instance != null) 'instance': instance!,
        if (instanceHealth != null)
          'instanceHealth':
              instanceHealth!.map((value) => value.toJson()).toList(),
        if (instanceStatus != null) 'instanceStatus': instanceStatus!,
        if (lastAttempt != null) 'lastAttempt': lastAttempt!.toJson(),
        if (preservedStateFromConfig != null)
          'preservedStateFromConfig': preservedStateFromConfig!.toJson(),
        if (preservedStateFromPolicy != null)
          'preservedStateFromPolicy': preservedStateFromPolicy!.toJson(),
        if (version != null) 'version': version!.toJson(),
      };
}

class ManagedInstanceInstanceHealth {
  /// The current detailed instance health state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "HEALTHY"
  /// - "TIMEOUT"
  /// - "UNHEALTHY"
  /// - "UNKNOWN"
  core.String? detailedHealthState;

  /// The URL for the health check that verifies whether the instance is
  /// healthy.
  ///
  /// Output only.
  core.String? healthCheck;

  ManagedInstanceInstanceHealth();

  ManagedInstanceInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey('detailedHealthState')) {
      detailedHealthState = _json['detailedHealthState'] as core.String;
    }
    if (_json.containsKey('healthCheck')) {
      healthCheck = _json['healthCheck'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (detailedHealthState != null)
          'detailedHealthState': detailedHealthState!,
        if (healthCheck != null) 'healthCheck': healthCheck!,
      };
}

class ManagedInstanceLastAttemptErrorsErrors {
  /// The error type identifier for this error.
  ///
  /// Output only.
  core.String? code;

  /// Indicates the field in the request that caused the error.
  ///
  /// This property is optional.
  ///
  /// Output only.
  core.String? location;

  /// An optional, human-readable error message.
  ///
  /// Output only.
  core.String? message;

  ManagedInstanceLastAttemptErrorsErrors();

  ManagedInstanceLastAttemptErrorsErrors.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (location != null) 'location': location!,
        if (message != null) 'message': message!,
      };
}

/// Encountered errors during the last attempt to create or delete the instance.
///
/// Output only.
class ManagedInstanceLastAttemptErrors {
  /// The array of errors encountered while processing this operation.
  ///
  /// Output only.
  core.List<ManagedInstanceLastAttemptErrorsErrors>? errors;

  ManagedInstanceLastAttemptErrors();

  ManagedInstanceLastAttemptErrors.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = (_json['errors'] as core.List)
          .map<ManagedInstanceLastAttemptErrorsErrors>((value) =>
              ManagedInstanceLastAttemptErrorsErrors.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null)
          'errors': errors!.map((value) => value.toJson()).toList(),
      };
}

class ManagedInstanceLastAttempt {
  /// Encountered errors during the last attempt to create or delete the
  /// instance.
  ///
  /// Output only.
  ManagedInstanceLastAttemptErrors? errors;

  ManagedInstanceLastAttempt();

  ManagedInstanceLastAttempt.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = ManagedInstanceLastAttemptErrors.fromJson(
          _json['errors'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null) 'errors': errors!.toJson(),
      };
}

class ManagedInstanceVersion {
  /// The intended template of the instance.
  ///
  /// This field is empty when current_action is one of { DELETING, ABANDONING
  /// }.
  ///
  /// Output only.
  core.String? instanceTemplate;

  /// Name of the version.
  ///
  /// Output only.
  core.String? name;

  ManagedInstanceVersion();

  ManagedInstanceVersion.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
        if (name != null) 'name': name!,
      };
}

class MetadataItems {
  /// Key for the metadata entry.
  ///
  /// Keys must conform to the following regexp: \[a-zA-Z0-9-_\]+, and be less
  /// than 128 bytes in length. This is reflected as part of a URL in the
  /// metadata server. Additionally, to avoid ambiguity, keys must not conflict
  /// with any other metadata keys for the project.
  core.String? key;

  /// Value for the metadata entry.
  ///
  /// These are free-form strings, and only have meaning as interpreted by the
  /// image running in the instance. The only restriction placed on values is
  /// that their size must be less than or equal to 262144 bytes (256 KiB).
  core.String? value;

  MetadataItems();

  MetadataItems.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// A metadata key/value entry.
class Metadata {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve the
  /// resource.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Array of key/value pairs.
  ///
  /// The total size of all keys and values must be less than 512 KB.
  core.List<MetadataItems>? items;

  /// Type of the resource.
  ///
  /// Always compute#metadata for metadata.
  ///
  /// Output only.
  core.String? kind;

  Metadata();

  Metadata.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<MetadataItems>((value) => MetadataItems.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

/// Opaque filter criteria used by loadbalancers to restrict routing
/// configuration to a limited set of loadbalancing proxies.
///
/// Proxies and sidecars involved in loadbalancing would typically present
/// metadata to the loadbalancers which need to match criteria specified here.
/// If a match takes place, the relevant configuration is made available to
/// those proxies.
/// For each metadataFilter in this list, if its filterMatchCriteria is set to
/// MATCH_ANY, at least one of the filterLabels must match the corresponding
/// label provided in the metadata. If its filterMatchCriteria is set to
/// MATCH_ALL, then all of its filterLabels must match with corresponding labels
/// provided in the metadata.
/// An example for using metadataFilters would be: if loadbalancing involves
/// Envoys, they will only receive routing configuration when values in
/// metadataFilters match values supplied in <a
/// href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/base.proto#envoy-api-msg-core-node"
/// Node metadata of their XDS requests to loadbalancers.
class MetadataFilter {
  /// The list of label value pairs that must match labels in the provided
  /// metadata based on filterMatchCriteria
  /// This list must not be empty and can have at the most 64 entries.
  core.List<MetadataFilterLabelMatch>? filterLabels;

  /// Specifies how individual filterLabel matches within the list of
  /// filterLabels contribute towards the overall metadataFilter match.
  /// Supported values are:
  /// - MATCH_ANY: At least one of the filterLabels must have a matching label
  /// in the provided metadata.
  ///
  ///
  /// - MATCH_ALL: All filterLabels must have matching labels in the provided
  /// metadata.
  /// Possible string values are:
  /// - "MATCH_ALL"
  /// - "MATCH_ANY"
  /// - "NOT_SET"
  core.String? filterMatchCriteria;

  MetadataFilter();

  MetadataFilter.fromJson(core.Map _json) {
    if (_json.containsKey('filterLabels')) {
      filterLabels = (_json['filterLabels'] as core.List)
          .map<MetadataFilterLabelMatch>((value) =>
              MetadataFilterLabelMatch.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('filterMatchCriteria')) {
      filterMatchCriteria = _json['filterMatchCriteria'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (filterLabels != null)
          'filterLabels': filterLabels!.map((value) => value.toJson()).toList(),
        if (filterMatchCriteria != null)
          'filterMatchCriteria': filterMatchCriteria!,
      };
}

/// MetadataFilter label name value pairs that are expected to match
/// corresponding labels presented as metadata to the loadbalancer.
class MetadataFilterLabelMatch {
  /// Name of metadata label.
  /// The name can have a maximum length of 1024 characters and must be at least
  /// 1 character long.
  core.String? name;

  /// The value of the label must match the specified value.
  /// value can have a maximum length of 1024 characters.
  core.String? value;

  MetadataFilterLabelMatch();

  MetadataFilterLabelMatch.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// The named port.
///
/// For example: .
class NamedPort {
  /// The name for this named port.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? name;

  /// The port number, which can be a value between 1 and 65535.
  core.int? port;

  NamedPort();

  NamedPort.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (port != null) 'port': port!,
      };
}

/// Represents a VPC Network resource.
///
/// Networks connect resources to each other and to the internet.
///
/// For more information, read Virtual Private Cloud (VPC) Network. (==
/// resource_for {$api_version}.networks ==)
class Network {
  /// Deprecated in favor of subnet mode networks.
  ///
  /// The range of internal addresses that are legal on this network. This range
  /// is a CIDR specification, for example: 192.168.0.0/16. Provided by the
  /// client when the network is created.
  core.String? IPv4Range;

  /// Must be set to create a VPC network.
  ///
  /// If not set, a legacy network is created.
  ///
  /// When set to true, the VPC network is created in auto mode. When set to
  /// false, the VPC network is created in custom mode.
  ///
  /// An auto mode VPC network starts with one subnet per region. Each subnet
  /// has a predetermined range as described in Auto mode VPC network IP ranges.
  ///
  /// For custom mode VPC networks, you can add subnets using the subnetworks
  /// insert method.
  core.bool? autoCreateSubnetworks;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The gateway address for default routing out of the network, selected by
  /// GCP.
  ///
  /// Output only.
  core.String? gatewayIPv4;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#network for networks.
  ///
  /// Output only.
  core.String? kind;

  /// Maximum Transmission Unit in bytes.
  ///
  /// The minimum value for this field is 1460 and the maximum value is 1500
  /// bytes.
  core.int? mtu;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// A list of network peerings for the resource.
  ///
  /// Output only.
  core.List<NetworkPeering>? peerings;

  /// The network-level routing configuration for this network.
  ///
  /// Used by Cloud Router to determine what type of network-wide routing
  /// behavior to enforce.
  NetworkRoutingConfig? routingConfig;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined fully-qualified URLs for all subnetworks in this VPC
  /// network.
  ///
  /// Output only.
  core.List<core.String>? subnetworks;

  Network();

  Network.fromJson(core.Map _json) {
    if (_json.containsKey('IPv4Range')) {
      IPv4Range = _json['IPv4Range'] as core.String;
    }
    if (_json.containsKey('autoCreateSubnetworks')) {
      autoCreateSubnetworks = _json['autoCreateSubnetworks'] as core.bool;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('gatewayIPv4')) {
      gatewayIPv4 = _json['gatewayIPv4'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('mtu')) {
      mtu = _json['mtu'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerings')) {
      peerings = (_json['peerings'] as core.List)
          .map<NetworkPeering>((value) => NetworkPeering.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('routingConfig')) {
      routingConfig = NetworkRoutingConfig.fromJson(
          _json['routingConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPv4Range != null) 'IPv4Range': IPv4Range!,
        if (autoCreateSubnetworks != null)
          'autoCreateSubnetworks': autoCreateSubnetworks!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (gatewayIPv4 != null) 'gatewayIPv4': gatewayIPv4!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (mtu != null) 'mtu': mtu!,
        if (name != null) 'name': name!,
        if (peerings != null)
          'peerings': peerings!.map((value) => value.toJson()).toList(),
        if (routingConfig != null) 'routingConfig': routingConfig!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (subnetworks != null) 'subnetworks': subnetworks!,
      };
}

/// The network endpoint.
class NetworkEndpoint {
  /// Metadata defined as annotations on the network endpoint.
  core.Map<core.String, core.String>? annotations;

  /// Optional fully qualified domain name of network endpoint.
  ///
  /// This can only be specified when NetworkEndpointGroup.network_endpoint_type
  /// is NON_GCP_FQDN_PORT.
  core.String? fqdn;

  /// The name for a specific VM instance that the IP address belongs to.
  ///
  /// This is required for network endpoints of type GCE_VM_IP_PORT. The
  /// instance must be in the same zone of network endpoint group.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  core.String? instance;

  /// Optional IPv4 address of network endpoint.
  ///
  /// The IP address must belong to a VM in Compute Engine (either the primary
  /// IP or as part of an aliased IP range). If the IP address is not specified,
  /// then the primary IP address for the VM instance in the network that the
  /// network endpoint group belongs to will be used.
  core.String? ipAddress;

  /// Optional port number of network endpoint.
  ///
  /// If not specified, the defaultPort for the network endpoint group will be
  /// used.
  core.int? port;

  NetworkEndpoint();

  NetworkEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations =
          (_json['annotations'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('fqdn')) {
      fqdn = _json['fqdn'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (fqdn != null) 'fqdn': fqdn!,
        if (instance != null) 'instance': instance!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (port != null) 'port': port!,
      };
}

/// Represents a collection of network endpoints.
///
/// A network endpoint group (NEG) defines how a set of endpoints should be
/// reached, whether they are reachable, and where they are located.
///
/// For more information about using NEGs, see Setting up external HTTP(S) Load
/// Balancing with internet NEGs, Setting up zonal NEGs, or Setting up external
/// HTTP(S) Load Balancing with serverless NEGs. (== resource_for
/// {$api_version}.networkEndpointGroups ==) (== resource_for
/// {$api_version}.globalNetworkEndpointGroups ==) (== resource_for
/// {$api_version}.regionNetworkEndpointGroups ==)
class NetworkEndpointGroup {
  /// Metadata defined as annotations on the network endpoint group.
  core.Map<core.String, core.String>? annotations;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupAppEngine? appEngine;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudFunction? cloudFunction;

  /// Only valid when networkEndpointType is "SERVERLESS".
  ///
  /// Only one of cloudRun, appEngine or cloudFunction may be set.
  NetworkEndpointGroupCloudRun? cloudRun;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The default port used if the port number is not specified in the network
  /// endpoint.
  core.int? defaultPort;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#networkEndpointGroup for network endpoint group.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The URL of the network to which all network endpoints in the NEG belong.
  ///
  /// Uses "default" project network if unspecified.
  core.String? network;

  /// Type of network endpoints in this network endpoint group.
  ///
  /// Can be one of GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
  /// INTERNET_IP_PORT, or SERVERLESS.
  /// Possible string values are:
  /// - "GCE_VM_IP"
  /// - "GCE_VM_IP_PORT"
  /// - "INTERNET_FQDN_PORT"
  /// - "INTERNET_IP_PORT"
  /// - "NON_GCP_PRIVATE_IP_PORT"
  /// - "SERVERLESS"
  core.String? networkEndpointType;

  /// The URL of the region where the network endpoint group is located.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Number of network endpoints in the network endpoint group.
  ///
  /// Output only.
  core.int? size;

  /// Optional URL of the subnetwork to which all network endpoints in the NEG
  /// belong.
  core.String? subnetwork;

  /// The URL of the zone where the network endpoint group is located.
  ///
  /// Output only.
  core.String? zone;

  NetworkEndpointGroup();

  NetworkEndpointGroup.fromJson(core.Map _json) {
    if (_json.containsKey('annotations')) {
      annotations =
          (_json['annotations'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('appEngine')) {
      appEngine = NetworkEndpointGroupAppEngine.fromJson(
          _json['appEngine'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cloudFunction')) {
      cloudFunction = NetworkEndpointGroupCloudFunction.fromJson(
          _json['cloudFunction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('cloudRun')) {
      cloudRun = NetworkEndpointGroupCloudRun.fromJson(
          _json['cloudRun'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultPort')) {
      defaultPort = _json['defaultPort'] as core.int;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkEndpointType')) {
      networkEndpointType = _json['networkEndpointType'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (appEngine != null) 'appEngine': appEngine!.toJson(),
        if (cloudFunction != null) 'cloudFunction': cloudFunction!.toJson(),
        if (cloudRun != null) 'cloudRun': cloudRun!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultPort != null) 'defaultPort': defaultPort!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkEndpointType != null)
          'networkEndpointType': networkEndpointType!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
        if (zone != null) 'zone': zone!,
      };
}

class NetworkEndpointGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupAggregatedListWarningData();

  NetworkEndpointGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupAggregatedListWarning();

  NetworkEndpointGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupAggregatedListWarningData>((value) =>
              NetworkEndpointGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointGroupsScopedList resources.
  core.Map<core.String, NetworkEndpointGroupsScopedList>? items;

  /// The resource type, which is always
  /// compute#networkEndpointGroupAggregatedList for aggregated lists of network
  /// endpoint groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupAggregatedListWarning? warning;

  NetworkEndpointGroupAggregatedList();

  NetworkEndpointGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          NetworkEndpointGroupsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration for an App Engine network endpoint group (NEG).
///
/// The service is optional, may be provided explicitly or in the URL mask. The
/// version is optional and can only be provided explicitly or in the URL mask
/// when service is present.
///
/// Note: App Engine service must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupAppEngine {
  /// Optional serving service.
  ///
  /// The service name is case-sensitive and must be 1-63 characters long.
  ///
  /// Example value: "default", "my-service".
  core.String? service;

  /// A template to parse service and version fields from a request URL.
  ///
  /// URL mask allows for routing to multiple App Engine services without having
  /// to create multiple Network Endpoint Groups and backend services.
  ///
  /// For example, the request URLs "foo1-dot-appname.appspot.com/v1" and
  /// "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG
  /// with URL mask "-dot-appname.appspot.com/". The URL mask will parse them to
  /// { service = "foo1", version = "v1" } and { service = "foo1", version =
  /// "v2" } respectively.
  core.String? urlMask;

  /// Optional serving version.
  ///
  /// The version name is case-sensitive and must be 1-100 characters long.
  ///
  /// Example value: "v1", "v2".
  core.String? version;

  NetworkEndpointGroupAppEngine();

  NetworkEndpointGroupAppEngine.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
    if (_json.containsKey('version')) {
      version = _json['version'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
        if (urlMask != null) 'urlMask': urlMask!,
        if (version != null) 'version': version!,
      };
}

/// Configuration for a Cloud Function network endpoint group (NEG).
///
/// The function must be provided explicitly or in the URL mask.
///
/// Note: Cloud Function must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupCloudFunction {
  /// A user-defined name of the Cloud Function.
  ///
  /// The function name is case-sensitive and must be 1-63 characters long.
  ///
  /// Example value: "func1".
  core.String? function;

  /// A template to parse function field from a request URL.
  ///
  /// URL mask allows for routing to multiple Cloud Functions without having to
  /// create multiple Network Endpoint Groups and backend services.
  ///
  /// For example, request URLs "mydomain.com/function1" and
  /// "mydomain.com/function2" can be backed by the same Serverless NEG with URL
  /// mask "/". The URL mask will parse them to { function = "function1" } and {
  /// function = "function2" } respectively.
  core.String? urlMask;

  NetworkEndpointGroupCloudFunction();

  NetworkEndpointGroupCloudFunction.fromJson(core.Map _json) {
    if (_json.containsKey('function')) {
      function = _json['function'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (function != null) 'function': function!,
        if (urlMask != null) 'urlMask': urlMask!,
      };
}

/// Configuration for a Cloud Run network endpoint group (NEG).
///
/// The service must be provided explicitly or in the URL mask. The tag is
/// optional, may be provided explicitly or in the URL mask.
///
/// Note: Cloud Run service must be in the same project and located in the same
/// region as the Serverless NEG.
class NetworkEndpointGroupCloudRun {
  /// Cloud Run service is the main resource of Cloud Run.
  ///
  /// The service must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "run-service".
  core.String? service;

  /// Optional Cloud Run tag represents the "named-revision" to provide
  /// additional fine-grained traffic routing information.
  ///
  /// The tag must be 1-63 characters long, and comply with RFC1035.
  ///
  /// Example value: "revision-0010".
  core.String? tag;

  /// A template to parse service and tag fields from a request URL.
  ///
  /// URL mask allows for routing to multiple Run services without having to
  /// create multiple network endpoint groups and backend services.
  ///
  /// For example, request URLs "foo1.domain.com/bar1" and
  /// "foo1.domain.com/bar2" can be backed by the same Serverless Network
  /// Endpoint Group (NEG) with URL mask ".domain.com/". The URL mask will parse
  /// them to { service="bar1", tag="foo1" } and { service="bar2", tag="foo2" }
  /// respectively.
  core.String? urlMask;

  NetworkEndpointGroupCloudRun();

  NetworkEndpointGroupCloudRun.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('tag')) {
      tag = _json['tag'] as core.String;
    }
    if (_json.containsKey('urlMask')) {
      urlMask = _json['urlMask'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
        if (tag != null) 'tag': tag!,
        if (urlMask != null) 'urlMask': urlMask!,
      };
}

class NetworkEndpointGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupListWarningData();

  NetworkEndpointGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupListWarning();

  NetworkEndpointGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupListWarningData>((value) =>
              NetworkEndpointGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointGroup resources.
  core.List<NetworkEndpointGroup>? items;

  /// The resource type, which is always compute#networkEndpointGroupList for
  /// network endpoint group lists.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupListWarning? warning;

  NetworkEndpointGroupList();

  NetworkEndpointGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NetworkEndpointGroup>((value) => NetworkEndpointGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointGroupsAttachEndpointsRequest {
  /// The list of network endpoints to be attached.
  core.List<NetworkEndpoint>? networkEndpoints;

  NetworkEndpointGroupsAttachEndpointsRequest();

  NetworkEndpointGroupsAttachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class NetworkEndpointGroupsDetachEndpointsRequest {
  /// The list of network endpoints to be detached.
  core.List<NetworkEndpoint>? networkEndpoints;

  NetworkEndpointGroupsDetachEndpointsRequest();

  NetworkEndpointGroupsDetachEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpoints')) {
      networkEndpoints = (_json['networkEndpoints'] as core.List)
          .map<NetworkEndpoint>((value) => NetworkEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpoints != null)
          'networkEndpoints':
              networkEndpoints!.map((value) => value.toJson()).toList(),
      };
}

class NetworkEndpointGroupsListEndpointsRequest {
  /// Optional query parameter for showing the health status of each network
  /// endpoint.
  ///
  /// Valid options are SKIP or SHOW. If you don't specify this parameter, the
  /// health status of network endpoints will not be provided.
  /// Possible string values are:
  /// - "SHOW"
  /// - "SKIP"
  core.String? healthStatus;

  NetworkEndpointGroupsListEndpointsRequest();

  NetworkEndpointGroupsListEndpointsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthStatus')) {
      healthStatus = _json['healthStatus'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthStatus != null) 'healthStatus': healthStatus!,
      };
}

class NetworkEndpointGroupsListNetworkEndpointsWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupsListNetworkEndpointsWarningData();

  NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkEndpointGroupsListNetworkEndpointsWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupsListNetworkEndpointsWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupsListNetworkEndpointsWarning();

  NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupsListNetworkEndpointsWarningData>((value) =>
              NetworkEndpointGroupsListNetworkEndpointsWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupsListNetworkEndpoints {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NetworkEndpointWithHealthStatus resources.
  core.List<NetworkEndpointWithHealthStatus>? items;

  /// The resource type, which is always
  /// compute#networkEndpointGroupsListNetworkEndpoints for the list of network
  /// endpoints in the specified network endpoint group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkEndpointGroupsListNetworkEndpointsWarning? warning;

  NetworkEndpointGroupsListNetworkEndpoints();

  NetworkEndpointGroupsListNetworkEndpoints.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NetworkEndpointWithHealthStatus>((value) =>
              NetworkEndpointWithHealthStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupsListNetworkEndpointsWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkEndpointGroupsScopedListWarningData();

  NetworkEndpointGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that replaces the list of network endpoint groups
/// when the list is empty.
///
/// Output only.
class NetworkEndpointGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkEndpointGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkEndpointGroupsScopedListWarning();

  NetworkEndpointGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkEndpointGroupsScopedListWarningData>((value) =>
              NetworkEndpointGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NetworkEndpointGroupsScopedList {
  /// The list of network endpoint groups that are contained in this scope.
  ///
  /// Output only.
  core.List<NetworkEndpointGroup>? networkEndpointGroups;

  /// An informational warning that replaces the list of network endpoint groups
  /// when the list is empty.
  ///
  /// Output only.
  NetworkEndpointGroupsScopedListWarning? warning;

  NetworkEndpointGroupsScopedList();

  NetworkEndpointGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('networkEndpointGroups')) {
      networkEndpointGroups = (_json['networkEndpointGroups'] as core.List)
          .map<NetworkEndpointGroup>((value) => NetworkEndpointGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NetworkEndpointGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkEndpointGroups != null)
          'networkEndpointGroups':
              networkEndpointGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NetworkEndpointWithHealthStatus {
  /// The health status of network endpoint;
  ///
  /// Output only.
  core.List<HealthStatusForNetworkEndpoint>? healths;

  /// The network endpoint;
  ///
  /// Output only.
  NetworkEndpoint? networkEndpoint;

  NetworkEndpointWithHealthStatus();

  NetworkEndpointWithHealthStatus.fromJson(core.Map _json) {
    if (_json.containsKey('healths')) {
      healths = (_json['healths'] as core.List)
          .map<HealthStatusForNetworkEndpoint>((value) =>
              HealthStatusForNetworkEndpoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('networkEndpoint')) {
      networkEndpoint = NetworkEndpoint.fromJson(
          _json['networkEndpoint'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healths != null)
          'healths': healths!.map((value) => value.toJson()).toList(),
        if (networkEndpoint != null)
          'networkEndpoint': networkEndpoint!.toJson(),
      };
}

/// A network interface resource attached to an instance.
class NetworkInterface {
  /// An array of configurations for this interface.
  ///
  /// Currently, only one access config, ONE_TO_ONE_NAT, is supported. If there
  /// are no accessConfigs specified, then this instance will have no external
  /// internet access.
  core.List<AccessConfig>? accessConfigs;

  /// An array of alias IP ranges for this network interface.
  ///
  /// You can only specify this field for network interfaces in VPC networks.
  core.List<AliasIpRange>? aliasIpRanges;

  /// Fingerprint hash of contents stored in this network interface.
  ///
  /// This field will be ignored when inserting an Instance or adding a
  /// NetworkInterface. An up-to-date fingerprint must be provided in order to
  /// update the NetworkInterface, otherwise the request will fail with error
  /// 412 conditionNotMet.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// An IPv6 internal network address for this network interface.
  ///
  /// Output only.
  core.String? ipv6Address;

  /// Type of the resource.
  ///
  /// Always compute#networkInterface for network interfaces.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the network interface, which is generated by the server.
  ///
  /// For network devices, these are eth0, eth1, etc.
  ///
  /// Output only.
  core.String? name;

  /// URL of the network resource for this instance.
  ///
  /// When creating an instance, if neither the network nor the subnetwork is
  /// specified, the default network global/networks/default is used; if the
  /// network is not specified but the subnetwork is specified, the network is
  /// inferred.
  ///
  /// If you specify this property, you can specify the network as a full or
  /// partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/networks/network
  /// - projects/project/global/networks/network
  /// - global/networks/default
  core.String? network;

  /// An IPv4 internal IP address to assign to the instance for this network
  /// interface.
  ///
  /// If not specified by the user, an unused internal IP is assigned by the
  /// system.
  core.String? networkIP;

  /// The type of vNIC to be used on this interface.
  ///
  /// This may be gVNIC or VirtioNet.
  /// Possible string values are:
  /// - "GVNIC"
  /// - "UNSPECIFIED_NIC_TYPE"
  /// - "VIRTIO_NET"
  core.String? nicType;

  /// The URL of the Subnetwork resource for this instance.
  ///
  /// If the network resource is in legacy mode, do not specify this field. If
  /// the network is in auto subnet mode, specifying the subnetwork is optional.
  /// If the network is in custom subnet mode, specifying the subnetwork is
  /// required. If you specify this field, you can specify the subnetwork as a
  /// full or partial URL. For example, the following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
  /// - regions/region/subnetworks/subnetwork
  core.String? subnetwork;

  NetworkInterface();

  NetworkInterface.fromJson(core.Map _json) {
    if (_json.containsKey('accessConfigs')) {
      accessConfigs = (_json['accessConfigs'] as core.List)
          .map<AccessConfig>((value) => AccessConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('aliasIpRanges')) {
      aliasIpRanges = (_json['aliasIpRanges'] as core.List)
          .map<AliasIpRange>((value) => AliasIpRange.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('ipv6Address')) {
      ipv6Address = _json['ipv6Address'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('networkIP')) {
      networkIP = _json['networkIP'] as core.String;
    }
    if (_json.containsKey('nicType')) {
      nicType = _json['nicType'] as core.String;
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (accessConfigs != null)
          'accessConfigs':
              accessConfigs!.map((value) => value.toJson()).toList(),
        if (aliasIpRanges != null)
          'aliasIpRanges':
              aliasIpRanges!.map((value) => value.toJson()).toList(),
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (ipv6Address != null) 'ipv6Address': ipv6Address!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (networkIP != null) 'networkIP': networkIP!,
        if (nicType != null) 'nicType': nicType!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

class NetworkListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NetworkListWarningData();

  NetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NetworkListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NetworkListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NetworkListWarning();

  NetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NetworkListWarningData>((value) =>
              NetworkListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of networks.
class NetworkList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Network resources.
  core.List<Network>? items;

  /// Type of resource.
  ///
  /// Always compute#networkList for lists of networks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NetworkListWarning? warning;

  NetworkList();

  NetworkList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Network>((value) =>
              Network.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NetworkListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A network peering attached to a network resource.
///
/// The message includes the peering name, peer network, peering state, and a
/// flag indicating whether Google Compute Engine should automatically create
/// routes for the peering.
class NetworkPeering {
  /// This field will be deprecated soon.
  ///
  /// Use the exchange_subnet_routes field instead. Indicates whether full mesh
  /// connectivity is created and managed automatically between peered networks.
  /// Currently this field should always be true since Google Compute Engine
  /// will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? autoCreateRoutes;

  /// Indicates whether full mesh connectivity is created and managed
  /// automatically between peered networks.
  ///
  /// Currently this field should always be true since Google Compute Engine
  /// will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? exchangeSubnetRoutes;

  /// Whether to export the custom routes to peer network.
  core.bool? exportCustomRoutes;

  /// Whether subnet routes with public IP range are exported.
  ///
  /// The default value is true, all subnet routes are exported. The IPv4
  /// special-use ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses)
  /// are always exported to peers and are not controlled by this field.
  core.bool? exportSubnetRoutesWithPublicIp;

  /// Whether to import the custom routes from peer network.
  core.bool? importCustomRoutes;

  /// Whether subnet routes with public IP range are imported.
  ///
  /// The default value is false. The IPv4 special-use ranges
  /// (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always imported
  /// from peers and are not controlled by this field.
  core.bool? importSubnetRoutesWithPublicIp;

  /// Name of this peering.
  ///
  /// Provided by the client when the peering is created. The name must comply
  /// with RFC1035. Specifically, the name must be 1-63 characters long and
  /// match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character
  /// must be a lowercase letter, and all the following characters must be a
  /// dash, lowercase letter, or digit, except the last character, which cannot
  /// be a dash.
  core.String? name;

  /// The URL of the peer network.
  ///
  /// It can be either full URL or partial URL. The peer network may belong to a
  /// different project. If the partial URL does not contain project, it is
  /// assumed that the peer network is in the same project as the current
  /// network.
  core.String? network;

  /// Maximum Transmission Unit in bytes.
  core.int? peerMtu;

  /// State for the peering, either `ACTIVE` or `INACTIVE`.
  ///
  /// The peering is `ACTIVE` when there's a matching configuration in the peer
  /// network.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "INACTIVE"
  core.String? state;

  /// Details about the current state of the peering.
  ///
  /// Output only.
  core.String? stateDetails;

  NetworkPeering();

  NetworkPeering.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreateRoutes')) {
      autoCreateRoutes = _json['autoCreateRoutes'] as core.bool;
    }
    if (_json.containsKey('exchangeSubnetRoutes')) {
      exchangeSubnetRoutes = _json['exchangeSubnetRoutes'] as core.bool;
    }
    if (_json.containsKey('exportCustomRoutes')) {
      exportCustomRoutes = _json['exportCustomRoutes'] as core.bool;
    }
    if (_json.containsKey('exportSubnetRoutesWithPublicIp')) {
      exportSubnetRoutesWithPublicIp =
          _json['exportSubnetRoutesWithPublicIp'] as core.bool;
    }
    if (_json.containsKey('importCustomRoutes')) {
      importCustomRoutes = _json['importCustomRoutes'] as core.bool;
    }
    if (_json.containsKey('importSubnetRoutesWithPublicIp')) {
      importSubnetRoutesWithPublicIp =
          _json['importSubnetRoutesWithPublicIp'] as core.bool;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('peerMtu')) {
      peerMtu = _json['peerMtu'] as core.int;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('stateDetails')) {
      stateDetails = _json['stateDetails'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreateRoutes != null) 'autoCreateRoutes': autoCreateRoutes!,
        if (exchangeSubnetRoutes != null)
          'exchangeSubnetRoutes': exchangeSubnetRoutes!,
        if (exportCustomRoutes != null)
          'exportCustomRoutes': exportCustomRoutes!,
        if (exportSubnetRoutesWithPublicIp != null)
          'exportSubnetRoutesWithPublicIp': exportSubnetRoutesWithPublicIp!,
        if (importCustomRoutes != null)
          'importCustomRoutes': importCustomRoutes!,
        if (importSubnetRoutesWithPublicIp != null)
          'importSubnetRoutesWithPublicIp': importSubnetRoutesWithPublicIp!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (peerMtu != null) 'peerMtu': peerMtu!,
        if (state != null) 'state': state!,
        if (stateDetails != null) 'stateDetails': stateDetails!,
      };
}

/// A routing configuration attached to a network resource.
///
/// The message includes the list of routers associated with the network, and a
/// flag indicating the type of routing behavior to enforce network-wide.
class NetworkRoutingConfig {
  /// The network-wide routing mode to use.
  ///
  /// If set to REGIONAL, this network's Cloud Routers will only advertise
  /// routes with subnets of this network in the same region as the router. If
  /// set to GLOBAL, this network's Cloud Routers will advertise routes with all
  /// subnets of this network, across regions.
  /// Possible string values are:
  /// - "GLOBAL"
  /// - "REGIONAL"
  core.String? routingMode;

  NetworkRoutingConfig();

  NetworkRoutingConfig.fromJson(core.Map _json) {
    if (_json.containsKey('routingMode')) {
      routingMode = _json['routingMode'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (routingMode != null) 'routingMode': routingMode!,
      };
}

class NetworksAddPeeringRequest {
  /// This field will be deprecated soon.
  ///
  /// Use exchange_subnet_routes in network_peering instead. Indicates whether
  /// full mesh connectivity is created and managed automatically between peered
  /// networks. Currently this field should always be true since Google Compute
  /// Engine will automatically create and manage subnetwork routes between two
  /// networks when peering state is ACTIVE.
  core.bool? autoCreateRoutes;

  /// Name of the peering, which should conform to RFC1035.
  core.String? name;

  /// Network peering parameters.
  ///
  /// In order to specify route policies for peering using import and export
  /// custom routes, you must specify all peering related parameters (name, peer
  /// network, exchange_subnet_routes) in the network_peering field. The
  /// corresponding fields in NetworksAddPeeringRequest will be deprecated soon.
  NetworkPeering? networkPeering;

  /// URL of the peer network.
  ///
  /// It can be either full URL or partial URL. The peer network may belong to a
  /// different project. If the partial URL does not contain project, it is
  /// assumed that the peer network is in the same project as the current
  /// network.
  core.String? peerNetwork;

  NetworksAddPeeringRequest();

  NetworksAddPeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreateRoutes')) {
      autoCreateRoutes = _json['autoCreateRoutes'] as core.bool;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('networkPeering')) {
      networkPeering = NetworkPeering.fromJson(
          _json['networkPeering'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('peerNetwork')) {
      peerNetwork = _json['peerNetwork'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreateRoutes != null) 'autoCreateRoutes': autoCreateRoutes!,
        if (name != null) 'name': name!,
        if (networkPeering != null) 'networkPeering': networkPeering!.toJson(),
        if (peerNetwork != null) 'peerNetwork': peerNetwork!,
      };
}

class NetworksGetEffectiveFirewallsResponse {
  /// Effective firewalls from firewall policy.
  core.List<NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy>?
      firewallPolicys;

  /// Effective firewalls on the network.
  core.List<Firewall>? firewalls;

  NetworksGetEffectiveFirewallsResponse();

  NetworksGetEffectiveFirewallsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('firewallPolicys')) {
      firewallPolicys = (_json['firewallPolicys'] as core.List)
          .map<NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy>(
              (value) =>
                  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('firewalls')) {
      firewalls = (_json['firewalls'] as core.List)
          .map<Firewall>((value) =>
              Firewall.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (firewallPolicys != null)
          'firewallPolicys':
              firewallPolicys!.map((value) => value.toJson()).toList(),
        if (firewalls != null)
          'firewalls': firewalls!.map((value) => value.toJson()).toList(),
      };
}

class NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
  /// The display name of the firewall policy.
  ///
  /// Output only.
  core.String? displayName;

  /// The name of the firewall policy.
  ///
  /// Output only.
  core.String? name;

  /// The rules that apply to the network.
  core.List<FirewallPolicyRule>? rules;

  /// The type of the firewall policy.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HIERARCHY"
  /// - "NETWORK"
  /// - "UNSPECIFIED"
  core.String? type;

  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy();

  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy.fromJson(
      core.Map _json) {
    if (_json.containsKey('displayName')) {
      displayName = _json['displayName'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<FirewallPolicyRule>((value) => FirewallPolicyRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (type != null) 'type': type!,
      };
}

class NetworksRemovePeeringRequest {
  /// Name of the peering, which should conform to RFC1035.
  core.String? name;

  NetworksRemovePeeringRequest();

  NetworksRemovePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

class NetworksUpdatePeeringRequest {
  NetworkPeering? networkPeering;

  NetworksUpdatePeeringRequest();

  NetworksUpdatePeeringRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkPeering')) {
      networkPeering = NetworkPeering.fromJson(
          _json['networkPeering'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkPeering != null) 'networkPeering': networkPeering!.toJson(),
      };
}

/// Represent a sole-tenant Node Group resource.
///
/// A sole-tenant node is a physical server that is dedicated to hosting VM
/// instances only for your specific project.
///
/// Use sole-tenant nodes to keep your instances physically separated from
/// instances in other projects, or to group your instances together on the same
/// host hardware. For more information, read Sole-tenant nodes. (==
/// resource_for {$api_version}.nodeGroups ==)
class NodeGroup {
  /// Specifies how autoscaling should behave.
  NodeGroupAutoscalingPolicy? autoscalingPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeGroup for node group.
  ///
  /// Output only.
  core.String? kind;

  /// An opaque location hint used to place the Node close to other resources.
  ///
  /// This field is for use by internal tools that use the public API. The
  /// location hint here on the NodeGroup overrides any location_hint present in
  /// the NodeTemplate.
  core.String? locationHint;

  /// Specifies how to handle instances when a node in the group undergoes
  /// maintenance.
  ///
  /// Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP.
  /// The default value is DEFAULT. For more information, see Maintenance
  /// policies.
  /// Possible string values are:
  /// - "DEFAULT"
  /// - "MAINTENANCE_POLICY_UNSPECIFIED"
  /// - "MIGRATE_WITHIN_NODE_GROUP"
  /// - "RESTART_IN_PLACE"
  core.String? maintenancePolicy;
  NodeGroupMaintenanceWindow? maintenanceWindow;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// URL of the node template to create the node group from.
  core.String? nodeTemplate;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The total number of nodes in the node group.
  ///
  /// Output only.
  core.int? size;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String? status;

  /// The name of the zone where the node group resides, such as us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  NodeGroup();

  NodeGroup.fromJson(core.Map _json) {
    if (_json.containsKey('autoscalingPolicy')) {
      autoscalingPolicy = NodeGroupAutoscalingPolicy.fromJson(
          _json['autoscalingPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('locationHint')) {
      locationHint = _json['locationHint'] as core.String;
    }
    if (_json.containsKey('maintenancePolicy')) {
      maintenancePolicy = _json['maintenancePolicy'] as core.String;
    }
    if (_json.containsKey('maintenanceWindow')) {
      maintenanceWindow = NodeGroupMaintenanceWindow.fromJson(
          _json['maintenanceWindow'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeTemplate')) {
      nodeTemplate = _json['nodeTemplate'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('size')) {
      size = _json['size'] as core.int;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingPolicy != null)
          'autoscalingPolicy': autoscalingPolicy!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (maintenancePolicy != null) 'maintenancePolicy': maintenancePolicy!,
        if (maintenanceWindow != null)
          'maintenanceWindow': maintenanceWindow!.toJson(),
        if (name != null) 'name': name!,
        if (nodeTemplate != null) 'nodeTemplate': nodeTemplate!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (size != null) 'size': size!,
        if (status != null) 'status': status!,
        if (zone != null) 'zone': zone!,
      };
}

class NodeGroupAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupAggregatedListWarningData();

  NodeGroupAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupAggregatedListWarning();

  NodeGroupAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupAggregatedListWarningData>((value) =>
              NodeGroupAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeGroupsScopedList resources.
  core.Map<core.String, NodeGroupsScopedList>? items;

  /// Type of resource.Always compute#nodeGroupAggregatedList for aggregated
  /// lists of node groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupAggregatedListWarning? warning;

  NodeGroupAggregatedList();

  NodeGroupAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          NodeGroupsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupAutoscalingPolicy {
  /// The maximum number of nodes that the group should have.
  ///
  /// Must be set if autoscaling is enabled. Maximum value allowed is 100.
  core.int? maxNodes;

  /// The minimum number of nodes that the group should have.
  core.int? minNodes;

  /// The autoscaling mode.
  ///
  /// Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see
  /// Autoscaler modes.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED"
  /// - "OFF"
  /// - "ON"
  /// - "ONLY_SCALE_OUT"
  core.String? mode;

  NodeGroupAutoscalingPolicy();

  NodeGroupAutoscalingPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('maxNodes')) {
      maxNodes = _json['maxNodes'] as core.int;
    }
    if (_json.containsKey('minNodes')) {
      minNodes = _json['minNodes'] as core.int;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxNodes != null) 'maxNodes': maxNodes!,
        if (minNodes != null) 'minNodes': minNodes!,
        if (mode != null) 'mode': mode!,
      };
}

class NodeGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupListWarningData();

  NodeGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupListWarning();

  NodeGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupListWarningData>((value) =>
              NodeGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of nodeGroups.
class NodeGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeGroup resources.
  core.List<NodeGroup>? items;

  /// Type of resource.Always compute#nodeGroupList for lists of node groups.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupListWarning? warning;

  NodeGroupList();

  NodeGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeGroup>((value) =>
              NodeGroup.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Time window specified for daily maintenance operations.
///
/// GCE's internal maintenance will be performed within this window.
class NodeGroupMaintenanceWindow {
  /// A predetermined duration for the window, automatically chosen to be the
  /// smallest possible in the given scenario.
  ///
  /// Output only.
  Duration? maintenanceDuration;

  /// Start time of the window.
  ///
  /// This must be in UTC format that resolves to one of 00:00, 04:00, 08:00,
  /// 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
  core.String? startTime;

  NodeGroupMaintenanceWindow();

  NodeGroupMaintenanceWindow.fromJson(core.Map _json) {
    if (_json.containsKey('maintenanceDuration')) {
      maintenanceDuration = Duration.fromJson(
          _json['maintenanceDuration'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (maintenanceDuration != null)
          'maintenanceDuration': maintenanceDuration!.toJson(),
        if (startTime != null) 'startTime': startTime!,
      };
}

class NodeGroupNode {
  /// Accelerators for this node.
  core.List<AcceleratorConfig>? accelerators;

  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String? cpuOvercommitType;

  /// Local disk configurations.
  core.List<LocalDisk>? disks;

  /// Instances scheduled on this node.
  core.List<core.String>? instances;

  /// The name of the node.
  core.String? name;

  /// The type of this node.
  core.String? nodeType;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Binding properties for the physical server.
  ServerBinding? serverBinding;

  /// Server ID associated with this node.
  core.String? serverId;

  ///
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "REPAIRING"
  core.String? status;

  NodeGroupNode();

  NodeGroupNode.fromJson(core.Map _json) {
    if (_json.containsKey('accelerators')) {
      accelerators = (_json['accelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('cpuOvercommitType')) {
      cpuOvercommitType = _json['cpuOvercommitType'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<LocalDisk>((value) =>
              LocalDisk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeType')) {
      nodeType = _json['nodeType'] as core.String;
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('serverBinding')) {
      serverBinding = ServerBinding.fromJson(
          _json['serverBinding'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('serverId')) {
      serverId = _json['serverId'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (cpuOvercommitType != null) 'cpuOvercommitType': cpuOvercommitType!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (instances != null) 'instances': instances!,
        if (name != null) 'name': name!,
        if (nodeType != null) 'nodeType': nodeType!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serverBinding != null) 'serverBinding': serverBinding!.toJson(),
        if (serverId != null) 'serverId': serverId!,
        if (status != null) 'status': status!,
      };
}

class NodeGroupsAddNodesRequest {
  /// Count of additional nodes to be added to the node group.
  core.int? additionalNodeCount;

  NodeGroupsAddNodesRequest();

  NodeGroupsAddNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('additionalNodeCount')) {
      additionalNodeCount = _json['additionalNodeCount'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (additionalNodeCount != null)
          'additionalNodeCount': additionalNodeCount!,
      };
}

class NodeGroupsDeleteNodesRequest {
  /// Names of the nodes to delete.
  core.List<core.String>? nodes;

  NodeGroupsDeleteNodesRequest();

  NodeGroupsDeleteNodesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('nodes')) {
      nodes = (_json['nodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodes != null) 'nodes': nodes!,
      };
}

class NodeGroupsListNodesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupsListNodesWarningData();

  NodeGroupsListNodesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeGroupsListNodesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupsListNodesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupsListNodesWarning();

  NodeGroupsListNodesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupsListNodesWarningData>((value) =>
              NodeGroupsListNodesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupsListNodes {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Node resources.
  core.List<NodeGroupNode>? items;

  /// The resource type, which is always compute.nodeGroupsListNodes for the
  /// list of nodes in the specified node group.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeGroupsListNodesWarning? warning;

  NodeGroupsListNodes();

  NodeGroupsListNodes.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeGroupNode>((value) => NodeGroupNode.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupsListNodesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeGroupsScopedListWarningData();

  NodeGroupsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the nodeGroup list is empty.
///
/// Output only.
class NodeGroupsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeGroupsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeGroupsScopedListWarning();

  NodeGroupsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeGroupsScopedListWarningData>((value) =>
              NodeGroupsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeGroupsScopedList {
  /// A list of node groups contained in this scope.
  ///
  /// Output only.
  core.List<NodeGroup>? nodeGroups;

  /// An informational warning that appears when the nodeGroup list is empty.
  ///
  /// Output only.
  NodeGroupsScopedListWarning? warning;

  NodeGroupsScopedList();

  NodeGroupsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeGroups')) {
      nodeGroups = (_json['nodeGroups'] as core.List)
          .map<NodeGroup>((value) =>
              NodeGroup.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeGroupsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeGroups != null)
          'nodeGroups': nodeGroups!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeGroupsSetNodeTemplateRequest {
  /// Full or partial URL of the node template resource to be updated for this
  /// node group.
  core.String? nodeTemplate;

  NodeGroupsSetNodeTemplateRequest();

  NodeGroupsSetNodeTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTemplate')) {
      nodeTemplate = _json['nodeTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTemplate != null) 'nodeTemplate': nodeTemplate!,
      };
}

/// Represent a sole-tenant Node Template resource.
///
/// You can use a template to define properties for nodes in a node group.
///
/// For more information, read Creating node groups and instances. (==
/// resource_for {$api_version}.nodeTemplates ==)
class NodeTemplate {
  core.List<AcceleratorConfig>? accelerators;

  /// CPU overcommit.
  /// Possible string values are:
  /// - "CPU_OVERCOMMIT_TYPE_UNSPECIFIED"
  /// - "ENABLED"
  /// - "NONE"
  core.String? cpuOvercommitType;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;
  core.List<LocalDisk>? disks;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeTemplate for node templates.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Labels to use for node affinity, which will be used in instance
  /// scheduling.
  core.Map<core.String, core.String>? nodeAffinityLabels;

  /// The node type to use for nodes group that are created from this template.
  core.String? nodeType;

  /// The flexible properties of the desired node type.
  ///
  /// Node groups that use this node template will create nodes of a type that
  /// matches these properties.
  ///
  /// This field is mutually exclusive with the node_type property; you can only
  /// define one or the other, but not both.
  NodeTemplateNodeTypeFlexibility? nodeTypeFlexibility;

  /// The name of the region where the node template resides, such as
  /// us-central1.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Sets the binding properties for the physical server.
  ///
  /// Valid values include:
  /// - \[Default\] RESTART_NODE_ON_ANY_SERVER: Restarts VMs on any available
  /// physical server
  /// - RESTART_NODE_ON_MINIMAL_SERVER: Restarts VMs on the same physical server
  /// whenever possible
  ///
  /// See Sole-tenant node options for more information.
  ServerBinding? serverBinding;

  /// The status of the node template.
  ///
  /// One of the following values: CREATING, READY, and DELETING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  core.String? status;

  /// An optional, human-readable explanation of the status.
  ///
  /// Output only.
  core.String? statusMessage;

  NodeTemplate();

  NodeTemplate.fromJson(core.Map _json) {
    if (_json.containsKey('accelerators')) {
      accelerators = (_json['accelerators'] as core.List)
          .map<AcceleratorConfig>((value) => AcceleratorConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('cpuOvercommitType')) {
      cpuOvercommitType = _json['cpuOvercommitType'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.List)
          .map<LocalDisk>((value) =>
              LocalDisk.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nodeAffinityLabels')) {
      nodeAffinityLabels =
          (_json['nodeAffinityLabels'] as core.Map<core.String, core.dynamic>)
              .map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('nodeType')) {
      nodeType = _json['nodeType'] as core.String;
    }
    if (_json.containsKey('nodeTypeFlexibility')) {
      nodeTypeFlexibility = NodeTemplateNodeTypeFlexibility.fromJson(
          _json['nodeTypeFlexibility'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serverBinding')) {
      serverBinding = ServerBinding.fromJson(
          _json['serverBinding'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (accelerators != null)
          'accelerators': accelerators!.map((value) => value.toJson()).toList(),
        if (cpuOvercommitType != null) 'cpuOvercommitType': cpuOvercommitType!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (disks != null)
          'disks': disks!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (nodeAffinityLabels != null)
          'nodeAffinityLabels': nodeAffinityLabels!,
        if (nodeType != null) 'nodeType': nodeType!,
        if (nodeTypeFlexibility != null)
          'nodeTypeFlexibility': nodeTypeFlexibility!.toJson(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serverBinding != null) 'serverBinding': serverBinding!.toJson(),
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
      };
}

class NodeTemplateAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplateAggregatedListWarningData();

  NodeTemplateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTemplateAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplateAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplateAggregatedListWarning();

  NodeTemplateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplateAggregatedListWarningData>((value) =>
              NodeTemplateAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTemplateAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTemplatesScopedList resources.
  core.Map<core.String, NodeTemplatesScopedList>? items;

  /// Type of resource.Always compute#nodeTemplateAggregatedList for aggregated
  /// lists of node templates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTemplateAggregatedListWarning? warning;

  NodeTemplateAggregatedList();

  NodeTemplateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          NodeTemplatesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplateAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTemplateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplateListWarningData();

  NodeTemplateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTemplateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplateListWarning();

  NodeTemplateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplateListWarningData>((value) =>
              NodeTemplateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of node templates.
class NodeTemplateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTemplate resources.
  core.List<NodeTemplate>? items;

  /// Type of resource.Always compute#nodeTemplateList for lists of node
  /// templates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTemplateListWarning? warning;

  NodeTemplateList();

  NodeTemplateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeTemplate>((value) => NodeTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTemplateNodeTypeFlexibility {
  core.String? cpus;
  core.String? localSsd;
  core.String? memory;

  NodeTemplateNodeTypeFlexibility();

  NodeTemplateNodeTypeFlexibility.fromJson(core.Map _json) {
    if (_json.containsKey('cpus')) {
      cpus = _json['cpus'] as core.String;
    }
    if (_json.containsKey('localSsd')) {
      localSsd = _json['localSsd'] as core.String;
    }
    if (_json.containsKey('memory')) {
      memory = _json['memory'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpus != null) 'cpus': cpus!,
        if (localSsd != null) 'localSsd': localSsd!,
        if (memory != null) 'memory': memory!,
      };
}

class NodeTemplatesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTemplatesScopedListWarningData();

  NodeTemplatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the node templates list is empty.
///
/// Output only.
class NodeTemplatesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTemplatesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTemplatesScopedListWarning();

  NodeTemplatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTemplatesScopedListWarningData>((value) =>
              NodeTemplatesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTemplatesScopedList {
  /// A list of node templates contained in this scope.
  ///
  /// Output only.
  core.List<NodeTemplate>? nodeTemplates;

  /// An informational warning that appears when the node templates list is
  /// empty.
  ///
  /// Output only.
  NodeTemplatesScopedListWarning? warning;

  NodeTemplatesScopedList();

  NodeTemplatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTemplates')) {
      nodeTemplates = (_json['nodeTemplates'] as core.List)
          .map<NodeTemplate>((value) => NodeTemplate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTemplatesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTemplates != null)
          'nodeTemplates':
              nodeTemplates!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represent a sole-tenant Node Type resource.
///
/// Each node within a node group must have a node type.
///
/// A node type specifies the total amount of cores and memory for that node.
/// Currently, the only available node type is n1-node-96-624 node type that has
/// 96 vCPUs and 624 GB of memory, available in multiple zones. For more
/// information read Node types. (== resource_for {$api_version}.nodeTypes ==)
class NodeType {
  /// The CPU platform used by this node type.
  ///
  /// Output only.
  core.String? cpuPlatform;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this node type.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// An optional textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The number of virtual CPUs that are available to the node type.
  ///
  /// Output only.
  core.int? guestCpus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The type of the resource.
  ///
  /// Always compute#nodeType for node types.
  ///
  /// Output only.
  core.String? kind;

  /// Local SSD available to the node type, defined in GB.
  ///
  /// Output only.
  core.int? localSsdGb;

  /// The amount of physical memory available to the node type, defined in MB.
  ///
  /// Output only.
  core.int? memoryMb;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The name of the zone where the node type resides, such as us-central1-a.
  ///
  /// Output only.
  core.String? zone;

  NodeType();

  NodeType.fromJson(core.Map _json) {
    if (_json.containsKey('cpuPlatform')) {
      cpuPlatform = _json['cpuPlatform'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('guestCpus')) {
      guestCpus = _json['guestCpus'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('localSsdGb')) {
      localSsdGb = _json['localSsdGb'] as core.int;
    }
    if (_json.containsKey('memoryMb')) {
      memoryMb = _json['memoryMb'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpuPlatform != null) 'cpuPlatform': cpuPlatform!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (guestCpus != null) 'guestCpus': guestCpus!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (localSsdGb != null) 'localSsdGb': localSsdGb!,
        if (memoryMb != null) 'memoryMb': memoryMb!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class NodeTypeAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypeAggregatedListWarningData();

  NodeTypeAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTypeAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypeAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypeAggregatedListWarning();

  NodeTypeAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypeAggregatedListWarningData>((value) =>
              NodeTypeAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTypeAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeTypesScopedList resources.
  core.Map<core.String, NodeTypesScopedList>? items;

  /// Type of resource.Always compute#nodeTypeAggregatedList for aggregated
  /// lists of node types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTypeAggregatedListWarning? warning;

  NodeTypeAggregatedList();

  NodeTypeAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          NodeTypesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypeAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypeListWarningData();

  NodeTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NodeTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypeListWarning();

  NodeTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypeListWarningData>((value) =>
              NodeTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of node types.
class NodeTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NodeType resources.
  core.List<NodeType>? items;

  /// Type of resource.Always compute#nodeTypeList for lists of node types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NodeTypeListWarning? warning;

  NodeTypeList();

  NodeTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NodeType>((value) =>
              NodeType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class NodeTypesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NodeTypesScopedListWarningData();

  NodeTypesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the node types list is empty.
///
/// Output only.
class NodeTypesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NodeTypesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NodeTypesScopedListWarning();

  NodeTypesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NodeTypesScopedListWarningData>((value) =>
              NodeTypesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NodeTypesScopedList {
  /// A list of node types contained in this scope.
  ///
  /// Output only.
  core.List<NodeType>? nodeTypes;

  /// An informational warning that appears when the node types list is empty.
  ///
  /// Output only.
  NodeTypesScopedListWarning? warning;

  NodeTypesScopedList();

  NodeTypesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('nodeTypes')) {
      nodeTypes = (_json['nodeTypes'] as core.List)
          .map<NodeType>((value) =>
              NodeType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = NodeTypesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (nodeTypes != null)
          'nodeTypes': nodeTypes!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a notification endpoint.
///
/// A notification endpoint resource defines an endpoint to receive
/// notifications when there are status changes detected by the associated
/// health check service.
///
/// For more information, see  Health checks overview.
///
/// (== resource_for {$api_version}.notificationEndpoint ==) (== resource_for
/// {$api_version}.regionNotificationEndpoints ==)
class NotificationEndpoint {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Settings of the gRPC notification endpoint including the endpoint URL and
  /// the retry duration.
  NotificationEndpointGrpcSettings? grpcSettings;

  /// A unique identifier for this resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#notificationEndpoint for notification endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the notification endpoint resides.
  ///
  /// This field applies only to the regional resource. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  NotificationEndpoint();

  NotificationEndpoint.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('grpcSettings')) {
      grpcSettings = NotificationEndpointGrpcSettings.fromJson(
          _json['grpcSettings'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (grpcSettings != null) 'grpcSettings': grpcSettings!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Represents a gRPC setting that describes one gRPC notification endpoint and
/// the retry duration attempting to send notification to this endpoint.
class NotificationEndpointGrpcSettings {
  /// If specified, this field is used to set the authority header by the sender
  /// of notifications.
  ///
  /// See https://tools.ietf.org/html/rfc7540#section-8.1.2.3
  ///
  /// Optional.
  core.String? authority;

  /// Endpoint to which gRPC notifications are sent.
  ///
  /// This must be a valid gRPCLB DNS name.
  core.String? endpoint;

  /// If specified, this field is used to populate the "name" field in gRPC
  /// requests.
  ///
  /// Optional.
  core.String? payloadName;

  /// This field is used to configure how often to send a full update of all
  /// non-healthy backends.
  ///
  /// If unspecified, full updates are not sent. If specified, must be in the
  /// range between 600 seconds to 3600 seconds. Nanos are disallowed.
  ///
  /// Optional.
  Duration? resendInterval;

  /// How much time (in seconds) is spent attempting notification retries until
  /// a successful response is received.
  ///
  /// Default is 30s. Limit is 20m (1200s). Must be a positive number.
  core.int? retryDurationSec;

  NotificationEndpointGrpcSettings();

  NotificationEndpointGrpcSettings.fromJson(core.Map _json) {
    if (_json.containsKey('authority')) {
      authority = _json['authority'] as core.String;
    }
    if (_json.containsKey('endpoint')) {
      endpoint = _json['endpoint'] as core.String;
    }
    if (_json.containsKey('payloadName')) {
      payloadName = _json['payloadName'] as core.String;
    }
    if (_json.containsKey('resendInterval')) {
      resendInterval = Duration.fromJson(
          _json['resendInterval'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('retryDurationSec')) {
      retryDurationSec = _json['retryDurationSec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (authority != null) 'authority': authority!,
        if (endpoint != null) 'endpoint': endpoint!,
        if (payloadName != null) 'payloadName': payloadName!,
        if (resendInterval != null) 'resendInterval': resendInterval!.toJson(),
        if (retryDurationSec != null) 'retryDurationSec': retryDurationSec!,
      };
}

class NotificationEndpointListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  NotificationEndpointListWarningData();

  NotificationEndpointListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class NotificationEndpointListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<NotificationEndpointListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  NotificationEndpointListWarning();

  NotificationEndpointListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<NotificationEndpointListWarningData>((value) =>
              NotificationEndpointListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class NotificationEndpointList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of NotificationEndpoint resources.
  core.List<NotificationEndpoint>? items;

  /// Type of the resource.
  ///
  /// Always compute#notificationEndpoint for notification endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  NotificationEndpointListWarning? warning;

  NotificationEndpointList();

  NotificationEndpointList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<NotificationEndpoint>((value) => NotificationEndpoint.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = NotificationEndpointListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationErrorErrors {
  /// The error type identifier for this error.
  ///
  /// Output only.
  core.String? code;

  /// Indicates the field in the request that caused the error.
  ///
  /// This property is optional.
  ///
  /// Output only.
  core.String? location;

  /// An optional, human-readable error message.
  ///
  /// Output only.
  core.String? message;

  OperationErrorErrors();

  OperationErrorErrors.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('location')) {
      location = _json['location'] as core.String;
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (location != null) 'location': location!,
        if (message != null) 'message': message!,
      };
}

/// If errors are generated during processing of the operation, this field will
/// be populated.
///
/// Output only.
class OperationError {
  /// The array of errors encountered while processing this operation.
  ///
  /// Output only.
  core.List<OperationErrorErrors>? errors;

  OperationError();

  OperationError.fromJson(core.Map _json) {
    if (_json.containsKey('errors')) {
      errors = (_json['errors'] as core.List)
          .map<OperationErrorErrors>((value) => OperationErrorErrors.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (errors != null)
          'errors': errors!.map((value) => value.toJson()).toList(),
      };
}

class OperationWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationWarningsData();

  OperationWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class OperationWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationWarnings();

  OperationWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationWarningsData>((value) => OperationWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents an Operation resource.
///
/// Google Compute Engine has three Operation resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/globalOperations) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionOperations) *
/// \[Zonal\](/compute/docs/reference/rest/{$api_version}/zoneOperations)
///
/// You can use an operation resource to manage asynchronous API requests.
///
/// For more information, read Handling API responses.
///
/// Operations can be global, regional or zonal.
/// - For global operations, use the `globalOperations` resource.
/// - For regional operations, use the `regionOperations` resource.
/// - For zonal operations, use the `zonalOperations` resource.
///
/// For more information, read Global, Regional, and Zonal Resources. (==
/// resource_for {$api_version}.globalOperations ==) (== resource_for
/// {$api_version}.regionOperations ==) (== resource_for
/// {$api_version}.zoneOperations ==)
class Operation {
  /// The value of `requestId` if you provided it in the request.
  ///
  /// Not present otherwise.
  ///
  /// Output only.
  core.String? clientOperationId;

  /// This field is deprecated.
  ///
  /// Deprecated.
  core.String? creationTimestamp;

  /// A textual description of the operation, which is set when the operation is
  /// created.
  ///
  /// Output only.
  core.String? description;

  /// The time that this operation was completed.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? endTime;

  /// If errors are generated during processing of the operation, this field
  /// will be populated.
  ///
  /// Output only.
  OperationError? error;

  /// If the operation fails, this field contains the HTTP error message that
  /// was returned, such as `NOT FOUND`.
  ///
  /// Output only.
  core.String? httpErrorMessage;

  /// If the operation fails, this field contains the HTTP error status code
  /// that was returned.
  ///
  /// For example, a `404` means the resource was not found.
  ///
  /// Output only.
  core.int? httpErrorStatusCode;

  /// The unique identifier for the operation.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The time that this operation was requested.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? insertTime;

  /// Type of the resource.
  ///
  /// Always `compute#operation` for Operation resources.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the operation.
  ///
  /// Output only.
  core.String? name;

  /// An ID that represents a group of operations, such as when a group of
  /// operations results from a `bulkInsert` API request.
  ///
  /// Output only.
  core.String? operationGroupId;

  /// The type of operation, such as `insert`, `update`, or `delete`, and so on.
  ///
  /// Output only.
  core.String? operationType;

  /// An optional progress indicator that ranges from 0 to 100.
  ///
  /// There is no requirement that this be linear or support any granularity of
  /// operations. This should not be used to guess when the operation will be
  /// complete. This number should monotonically increase as the operation
  /// progresses.
  ///
  /// Output only.
  core.int? progress;

  /// The URL of the region where the operation resides.
  ///
  /// Only applicable when performing regional operations.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The time that this operation was started by the server.
  ///
  /// This value is in RFC3339 text format.
  ///
  /// Output only.
  core.String? startTime;

  /// The status of the operation, which can be one of the following: `PENDING`,
  /// `RUNNING`, or `DONE`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DONE"
  /// - "PENDING"
  /// - "RUNNING"
  core.String? status;

  /// An optional textual description of the current status of the operation.
  ///
  /// Output only.
  core.String? statusMessage;

  /// The unique target ID, which identifies a specific incarnation of the
  /// target resource.
  ///
  /// Output only.
  core.String? targetId;

  /// The URL of the resource that the operation modifies.
  ///
  /// For operations related to creating a snapshot, this points to the
  /// persistent disk that the snapshot was created from.
  ///
  /// Output only.
  core.String? targetLink;

  /// User who requested the operation, for example: `user@example.com`.
  ///
  /// Output only.
  core.String? user;

  /// If warning messages are generated during processing of the operation, this
  /// field will be populated.
  ///
  /// Output only.
  core.List<OperationWarnings>? warnings;

  /// The URL of the zone where the operation resides.
  ///
  /// Only applicable when performing per-zone operations.
  ///
  /// Output only.
  core.String? zone;

  Operation();

  Operation.fromJson(core.Map _json) {
    if (_json.containsKey('clientOperationId')) {
      clientOperationId = _json['clientOperationId'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('endTime')) {
      endTime = _json['endTime'] as core.String;
    }
    if (_json.containsKey('error')) {
      error = OperationError.fromJson(
          _json['error'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('httpErrorMessage')) {
      httpErrorMessage = _json['httpErrorMessage'] as core.String;
    }
    if (_json.containsKey('httpErrorStatusCode')) {
      httpErrorStatusCode = _json['httpErrorStatusCode'] as core.int;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('insertTime')) {
      insertTime = _json['insertTime'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('operationGroupId')) {
      operationGroupId = _json['operationGroupId'] as core.String;
    }
    if (_json.containsKey('operationType')) {
      operationType = _json['operationType'] as core.String;
    }
    if (_json.containsKey('progress')) {
      progress = _json['progress'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('statusMessage')) {
      statusMessage = _json['statusMessage'] as core.String;
    }
    if (_json.containsKey('targetId')) {
      targetId = _json['targetId'] as core.String;
    }
    if (_json.containsKey('targetLink')) {
      targetLink = _json['targetLink'] as core.String;
    }
    if (_json.containsKey('user')) {
      user = _json['user'] as core.String;
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<OperationWarnings>((value) => OperationWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientOperationId != null) 'clientOperationId': clientOperationId!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!.toJson(),
        if (httpErrorMessage != null) 'httpErrorMessage': httpErrorMessage!,
        if (httpErrorStatusCode != null)
          'httpErrorStatusCode': httpErrorStatusCode!,
        if (id != null) 'id': id!,
        if (insertTime != null) 'insertTime': insertTime!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (operationGroupId != null) 'operationGroupId': operationGroupId!,
        if (operationType != null) 'operationType': operationType!,
        if (progress != null) 'progress': progress!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (startTime != null) 'startTime': startTime!,
        if (status != null) 'status': status!,
        if (statusMessage != null) 'statusMessage': statusMessage!,
        if (targetId != null) 'targetId': targetId!,
        if (targetLink != null) 'targetLink': targetLink!,
        if (user != null) 'user': user!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
        if (zone != null) 'zone': zone!,
      };
}

class OperationAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationAggregatedListWarningData();

  OperationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class OperationAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationAggregatedListWarning();

  OperationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationAggregatedListWarningData>((value) =>
              OperationAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class OperationAggregatedList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A map of scoped operation lists.
  ///
  /// Output only.
  core.Map<core.String, OperationsScopedList>? items;

  /// Type of resource.
  ///
  /// Always `compute#operationAggregatedList` for aggregated lists of
  /// operations.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than `maxResults`, use the
  /// `nextPageToken` as a value for the query parameter `pageToken` in the next
  /// list request. Subsequent list requests will have their own `nextPageToken`
  /// to continue paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  OperationAggregatedListWarning? warning;

  OperationAggregatedList();

  OperationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          OperationsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = OperationAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationListWarningData();

  OperationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class OperationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationListWarning();

  OperationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationListWarningData>((value) =>
              OperationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Operation resources.
class OperationList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Operation resources.
  ///
  /// Output only.
  core.List<Operation>? items;

  /// Type of resource.
  ///
  /// Always `compute#operations` for Operations resource.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than `maxResults`, use the
  /// `nextPageToken` as a value for the query parameter `pageToken` in the next
  /// list request. Subsequent list requests will have their own `nextPageToken`
  /// to continue paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  OperationListWarning? warning;

  OperationList();

  OperationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Operation>((value) =>
              Operation.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = OperationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class OperationsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  OperationsScopedListWarningData();

  OperationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of operations when the list is
/// empty.
///
/// Output only.
class OperationsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<OperationsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  OperationsScopedListWarning();

  OperationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<OperationsScopedListWarningData>((value) =>
              OperationsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class OperationsScopedList {
  /// A list of operations contained in this scope.
  ///
  /// Output only.
  core.List<Operation>? operations;

  /// Informational warning which replaces the list of operations when the list
  /// is empty.
  ///
  /// Output only.
  OperationsScopedListWarning? warning;

  OperationsScopedList();

  OperationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('operations')) {
      operations = (_json['operations'] as core.List)
          .map<Operation>((value) =>
              Operation.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = OperationsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (operations != null)
          'operations': operations!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Settings controlling the eviction of unhealthy hosts from the load balancing
/// pool for the backend service.
class OutlierDetection {
  /// The base time that a host is ejected for.
  ///
  /// The real ejection time is equal to the base ejection time multiplied by
  /// the number of times the host has been ejected. Defaults to 30000ms or 30s.
  Duration? baseEjectionTime;

  /// Number of errors before a host is ejected from the connection pool.
  ///
  /// When the backend host is accessed over HTTP, a 5xx return code qualifies
  /// as an error. Defaults to 5.
  core.int? consecutiveErrors;

  /// The number of consecutive gateway failures (502, 503, 504 status or
  /// connection errors that are mapped to one of those status codes) before a
  /// consecutive gateway failure ejection occurs.
  ///
  /// Defaults to 3.
  core.int? consecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive 5xx.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 0.
  core.int? enforcingConsecutiveErrors;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through consecutive gateway failures.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 100.
  core.int? enforcingConsecutiveGatewayFailure;

  /// The percentage chance that a host will be actually ejected when an outlier
  /// status is detected through success rate statistics.
  ///
  /// This setting can be used to disable ejection or to ramp it up slowly.
  /// Defaults to 100.
  core.int? enforcingSuccessRate;

  /// Time interval between ejection analysis sweeps.
  ///
  /// This can result in both new ejections as well as hosts being returned to
  /// service. Defaults to 1 second.
  Duration? interval;

  /// Maximum percentage of hosts in the load balancing pool for the backend
  /// service that can be ejected.
  ///
  /// Defaults to 50%.
  core.int? maxEjectionPercent;

  /// The number of hosts in a cluster that must have enough request volume to
  /// detect success rate outliers.
  ///
  /// If the number of hosts is less than this setting, outlier detection via
  /// success rate statistics is not performed for any host in the cluster.
  /// Defaults to 5.
  core.int? successRateMinimumHosts;

  /// The minimum number of total requests that must be collected in one
  /// interval (as defined by the interval duration above) to include this host
  /// in success rate based outlier detection.
  ///
  /// If the volume is lower than this setting, outlier detection via success
  /// rate statistics is not performed for that host. Defaults to 100.
  core.int? successRateRequestVolume;

  /// This factor is used to determine the ejection threshold for success rate
  /// outlier ejection.
  ///
  /// The ejection threshold is the difference between the mean success rate,
  /// and the product of this factor and the standard deviation of the mean
  /// success rate: mean - (stdev * success_rate_stdev_factor). This factor is
  /// divided by a thousand to get a double. That is, if the desired factor is
  /// 1.9, the runtime value should be 1900. Defaults to 1900.
  core.int? successRateStdevFactor;

  OutlierDetection();

  OutlierDetection.fromJson(core.Map _json) {
    if (_json.containsKey('baseEjectionTime')) {
      baseEjectionTime = Duration.fromJson(
          _json['baseEjectionTime'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('consecutiveErrors')) {
      consecutiveErrors = _json['consecutiveErrors'] as core.int;
    }
    if (_json.containsKey('consecutiveGatewayFailure')) {
      consecutiveGatewayFailure =
          _json['consecutiveGatewayFailure'] as core.int;
    }
    if (_json.containsKey('enforcingConsecutiveErrors')) {
      enforcingConsecutiveErrors =
          _json['enforcingConsecutiveErrors'] as core.int;
    }
    if (_json.containsKey('enforcingConsecutiveGatewayFailure')) {
      enforcingConsecutiveGatewayFailure =
          _json['enforcingConsecutiveGatewayFailure'] as core.int;
    }
    if (_json.containsKey('enforcingSuccessRate')) {
      enforcingSuccessRate = _json['enforcingSuccessRate'] as core.int;
    }
    if (_json.containsKey('interval')) {
      interval = Duration.fromJson(
          _json['interval'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('maxEjectionPercent')) {
      maxEjectionPercent = _json['maxEjectionPercent'] as core.int;
    }
    if (_json.containsKey('successRateMinimumHosts')) {
      successRateMinimumHosts = _json['successRateMinimumHosts'] as core.int;
    }
    if (_json.containsKey('successRateRequestVolume')) {
      successRateRequestVolume = _json['successRateRequestVolume'] as core.int;
    }
    if (_json.containsKey('successRateStdevFactor')) {
      successRateStdevFactor = _json['successRateStdevFactor'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseEjectionTime != null)
          'baseEjectionTime': baseEjectionTime!.toJson(),
        if (consecutiveErrors != null) 'consecutiveErrors': consecutiveErrors!,
        if (consecutiveGatewayFailure != null)
          'consecutiveGatewayFailure': consecutiveGatewayFailure!,
        if (enforcingConsecutiveErrors != null)
          'enforcingConsecutiveErrors': enforcingConsecutiveErrors!,
        if (enforcingConsecutiveGatewayFailure != null)
          'enforcingConsecutiveGatewayFailure':
              enforcingConsecutiveGatewayFailure!,
        if (enforcingSuccessRate != null)
          'enforcingSuccessRate': enforcingSuccessRate!,
        if (interval != null) 'interval': interval!.toJson(),
        if (maxEjectionPercent != null)
          'maxEjectionPercent': maxEjectionPercent!,
        if (successRateMinimumHosts != null)
          'successRateMinimumHosts': successRateMinimumHosts!,
        if (successRateRequestVolume != null)
          'successRateRequestVolume': successRateRequestVolume!,
        if (successRateStdevFactor != null)
          'successRateStdevFactor': successRateStdevFactor!,
      };
}

/// Represents a Packet Mirroring resource.
///
/// Packet Mirroring clones the traffic of specified instances in your Virtual
/// Private Cloud (VPC) network and forwards it to a collector destination, such
/// as an instance group of an internal TCP/UDP load balancer, for analysis or
/// examination.
///
/// For more information about setting up Packet Mirroring, see Using Packet
/// Mirroring. (== resource_for {$api_version}.packetMirrorings ==)
class PacketMirroring {
  /// The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
  /// will be used as collector for mirrored traffic.
  ///
  /// The specified forwarding rule must have isMirroringCollector set to true.
  PacketMirroringForwardingRuleInfo? collectorIlb;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Indicates whether or not this packet mirroring takes effect.
  ///
  /// If set to FALSE, this packet mirroring policy will not be enforced on the
  /// network.
  ///
  /// The default is TRUE.
  /// Possible string values are:
  /// - "FALSE"
  /// - "TRUE"
  core.String? enable;

  /// Filter for mirrored traffic.
  ///
  /// If unspecified, all traffic is mirrored.
  PacketMirroringFilter? filter;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#packetMirroring for packet mirrorings.
  ///
  /// Output only.
  core.String? kind;

  /// PacketMirroring mirroredResourceInfos.
  ///
  /// MirroredResourceInfo specifies a set of mirrored VM instances, subnetworks
  /// and/or tags for which traffic from/to all VM instances will be mirrored.
  PacketMirroringMirroredResourceInfo? mirroredResources;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Specifies the mirrored VPC network.
  ///
  /// Only packets in this network will be mirrored. All mirrored VMs should
  /// have a NIC in the given network. All mirrored subnetworks should belong to
  /// the given network.
  PacketMirroringNetworkInfo? network;

  /// The priority of applying this configuration.
  ///
  /// Priority is used to break ties in cases where there is more than one
  /// matching rule. In the case of two rules that apply for a given Instance,
  /// the one with the lowest-numbered priority value wins.
  ///
  /// Default value is 1000. Valid range is 0 through 65535.
  core.int? priority;

  /// URI of the region where the packetMirroring resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  PacketMirroring();

  PacketMirroring.fromJson(core.Map _json) {
    if (_json.containsKey('collectorIlb')) {
      collectorIlb = PacketMirroringForwardingRuleInfo.fromJson(
          _json['collectorIlb'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.String;
    }
    if (_json.containsKey('filter')) {
      filter = PacketMirroringFilter.fromJson(
          _json['filter'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('mirroredResources')) {
      mirroredResources = PacketMirroringMirroredResourceInfo.fromJson(
          _json['mirroredResources'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = PacketMirroringNetworkInfo.fromJson(
          _json['network'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (collectorIlb != null) 'collectorIlb': collectorIlb!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (enable != null) 'enable': enable!,
        if (filter != null) 'filter': filter!.toJson(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (mirroredResources != null)
          'mirroredResources': mirroredResources!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!.toJson(),
        if (priority != null) 'priority': priority!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

class PacketMirroringAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringAggregatedListWarningData();

  PacketMirroringAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PacketMirroringAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringAggregatedListWarning();

  PacketMirroringAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringAggregatedListWarningData>((value) =>
              PacketMirroringAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of packetMirrorings.
class PacketMirroringAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PacketMirroring resources.
  core.Map<core.String, PacketMirroringsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  PacketMirroringAggregatedListWarning? warning;

  PacketMirroringAggregatedList();

  PacketMirroringAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          PacketMirroringsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class PacketMirroringFilter {
  /// Protocols that apply as filter on mirrored traffic.
  ///
  /// If no protocols are specified, all traffic that matches the specified CIDR
  /// ranges is mirrored. If neither cidrRanges nor IPProtocols is specified,
  /// all traffic is mirrored.
  core.List<core.String>? IPProtocols;

  /// IP CIDR ranges that apply as filter on the source (ingress) or destination
  /// (egress) IP in the IP header.
  ///
  /// Only IPv4 is supported. If no ranges are specified, all traffic that
  /// matches the specified IPProtocols is mirrored. If neither cidrRanges nor
  /// IPProtocols is specified, all traffic is mirrored.
  core.List<core.String>? cidrRanges;

  /// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH.
  ///
  /// The default is BOTH.
  /// Possible string values are:
  /// - "BOTH"
  /// - "EGRESS"
  /// - "INGRESS"
  core.String? direction;

  PacketMirroringFilter();

  PacketMirroringFilter.fromJson(core.Map _json) {
    if (_json.containsKey('IPProtocols')) {
      IPProtocols = (_json['IPProtocols'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('cidrRanges')) {
      cidrRanges = (_json['cidrRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('direction')) {
      direction = _json['direction'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (IPProtocols != null) 'IPProtocols': IPProtocols!,
        if (cidrRanges != null) 'cidrRanges': cidrRanges!,
        if (direction != null) 'direction': direction!,
      };
}

class PacketMirroringForwardingRuleInfo {
  /// Unique identifier for the forwarding rule; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the forwarding rule representing the ILB configured as
  /// destination of the mirrored traffic.
  core.String? url;

  PacketMirroringForwardingRuleInfo();

  PacketMirroringForwardingRuleInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringListWarningData();

  PacketMirroringListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class PacketMirroringListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringListWarning();

  PacketMirroringListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringListWarningData>((value) =>
              PacketMirroringListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of PacketMirroring resources.
class PacketMirroringList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of PacketMirroring resources.
  core.List<PacketMirroring>? items;

  /// Type of resource.
  ///
  /// Always compute#packetMirroring for packetMirrorings.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  PacketMirroringListWarning? warning;

  PacketMirroringList();

  PacketMirroringList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PacketMirroring>((value) => PacketMirroring.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class PacketMirroringMirroredResourceInfo {
  /// A set of virtual machine instances that are being mirrored.
  ///
  /// They must live in zones contained in the same region as this
  /// packetMirroring.
  ///
  /// Note that this config will apply only to those network interfaces of the
  /// Instances that belong to the network specified in this packetMirroring.
  ///
  /// You may specify a maximum of 50 Instances.
  core.List<PacketMirroringMirroredResourceInfoInstanceInfo>? instances;

  /// A set of subnetworks for which traffic from/to all VM instances will be
  /// mirrored.
  ///
  /// They must live in the same region as this packetMirroring.
  ///
  /// You may specify a maximum of 5 subnetworks.
  core.List<PacketMirroringMirroredResourceInfoSubnetInfo>? subnetworks;

  /// A set of mirrored tags.
  ///
  /// Traffic from/to all VM instances that have one or more of these tags will
  /// be mirrored.
  core.List<core.String>? tags;

  PacketMirroringMirroredResourceInfo();

  PacketMirroringMirroredResourceInfo.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PacketMirroringMirroredResourceInfoInstanceInfo>((value) =>
              PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<PacketMirroringMirroredResourceInfoSubnetInfo>((value) =>
              PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('tags')) {
      tags = (_json['tags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (tags != null) 'tags': tags!,
      };
}

class PacketMirroringMirroredResourceInfoInstanceInfo {
  /// Unique identifier for the instance; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the virtual machine instance which is being mirrored.
  core.String? url;

  PacketMirroringMirroredResourceInfoInstanceInfo();

  PacketMirroringMirroredResourceInfoInstanceInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringMirroredResourceInfoSubnetInfo {
  /// Unique identifier for the subnetwork; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// Resource URL to the subnetwork for which traffic from/to all VM instances
  /// will be mirrored.
  core.String? url;

  PacketMirroringMirroredResourceInfoSubnetInfo();

  PacketMirroringMirroredResourceInfoSubnetInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringNetworkInfo {
  /// Unique identifier for the network; defined by the server.
  ///
  /// Output only.
  core.String? canonicalUrl;

  /// URL of the network resource.
  core.String? url;

  PacketMirroringNetworkInfo();

  PacketMirroringNetworkInfo.fromJson(core.Map _json) {
    if (_json.containsKey('canonicalUrl')) {
      canonicalUrl = _json['canonicalUrl'] as core.String;
    }
    if (_json.containsKey('url')) {
      url = _json['url'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (canonicalUrl != null) 'canonicalUrl': canonicalUrl!,
        if (url != null) 'url': url!,
      };
}

class PacketMirroringsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  PacketMirroringsScopedListWarningData();

  PacketMirroringsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of packetMirrorings when the
/// list is empty.
class PacketMirroringsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<PacketMirroringsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  PacketMirroringsScopedListWarning();

  PacketMirroringsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<PacketMirroringsScopedListWarningData>((value) =>
              PacketMirroringsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class PacketMirroringsScopedList {
  /// A list of packetMirrorings contained in this scope.
  core.List<PacketMirroring>? packetMirrorings;

  /// Informational warning which replaces the list of packetMirrorings when the
  /// list is empty.
  PacketMirroringsScopedListWarning? warning;

  PacketMirroringsScopedList();

  PacketMirroringsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('packetMirrorings')) {
      packetMirrorings = (_json['packetMirrorings'] as core.List)
          .map<PacketMirroring>((value) => PacketMirroring.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = PacketMirroringsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (packetMirrorings != null)
          'packetMirrorings':
              packetMirrorings!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A matcher for the path portion of the URL.
///
/// The BackendService from the longest-matched rule will serve the URL. If no
/// rule was matched, the default service will be used.
class PathMatcher {
  /// defaultRouteAction takes effect when none of the pathRules or routeRules
  /// match.
  ///
  /// The load balancer performs advanced routing actions like URL rewrites,
  /// header transformations, etc. prior to forwarding the request to the
  /// selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a pathMatcher's defaultRouteAction.
  HttpRouteAction? defaultRouteAction;

  /// The full or partial URL to the BackendService resource.
  ///
  /// This will be used if none of the pathRules or routeRules defined by this
  /// PathMatcher are matched. For example, the following are all valid URLs to
  /// a BackendService resource:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
  /// - compute/v1/projects/project/global/backendServices/backendService
  /// - global/backendServices/backendService If defaultRouteAction is
  /// additionally specified, advanced routing actions like URL Rewrites, etc.
  /// take effect prior to sending the request to the backend. However, if
  /// defaultService is specified, defaultRouteAction cannot contain any
  /// weightedBackendServices. Conversely, if defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be specified.
  /// Only one of defaultService, defaultUrlRedirect or
  /// defaultRouteAction.weightedBackendService must be set.
  /// Authorization requires one or more of the following Google IAM permissions
  /// on the specified resource default_service:
  /// - compute.backendBuckets.use
  /// - compute.backendServices.use
  core.String? defaultService;

  /// When none of the specified pathRules or routeRules match, the request is
  /// redirected to a URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? defaultUrlRedirect;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// HeaderAction specified here are applied after the matching HttpRouteRule
  /// HeaderAction and before the HeaderAction in the UrlMap
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// The name to which this PathMatcher is referred by the HostRule.
  core.String? name;

  /// The list of path rules.
  ///
  /// Use this list instead of routeRules when routing based on simple path
  /// matching is all that's required. The order by which path rules are
  /// specified does not matter. Matches are always done on the
  /// longest-path-first basis.
  /// For example: a pathRule with a path /a/b/c / * will match before /a/b / *
  /// irrespective of the order in which those paths appear in this list.
  /// Within a given pathMatcher, only one of pathRules or routeRules must be
  /// set.
  core.List<PathRule>? pathRules;

  /// The list of HTTP route rules.
  ///
  /// Use this list instead of pathRules when advanced route matching and
  /// routing actions are desired. routeRules are evaluated in order of
  /// priority, from the lowest to highest number.
  /// Within a given pathMatcher, you can set only one of pathRules or
  /// routeRules.
  core.List<HttpRouteRule>? routeRules;

  PathMatcher();

  PathMatcher.fromJson(core.Map _json) {
    if (_json.containsKey('defaultRouteAction')) {
      defaultRouteAction = HttpRouteAction.fromJson(
          _json['defaultRouteAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('defaultService')) {
      defaultService = _json['defaultService'] as core.String;
    }
    if (_json.containsKey('defaultUrlRedirect')) {
      defaultUrlRedirect = HttpRedirectAction.fromJson(
          _json['defaultUrlRedirect'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('pathRules')) {
      pathRules = (_json['pathRules'] as core.List)
          .map<PathRule>((value) =>
              PathRule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('routeRules')) {
      routeRules = (_json['routeRules'] as core.List)
          .map<HttpRouteRule>((value) => HttpRouteRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultRouteAction != null)
          'defaultRouteAction': defaultRouteAction!.toJson(),
        if (defaultService != null) 'defaultService': defaultService!,
        if (defaultUrlRedirect != null)
          'defaultUrlRedirect': defaultUrlRedirect!.toJson(),
        if (description != null) 'description': description!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (name != null) 'name': name!,
        if (pathRules != null)
          'pathRules': pathRules!.map((value) => value.toJson()).toList(),
        if (routeRules != null)
          'routeRules': routeRules!.map((value) => value.toJson()).toList(),
      };
}

/// A path-matching rule for a URL.
///
/// If matched, will use the specified BackendService to handle the traffic
/// arriving at this URL.
class PathRule {
  /// The list of path patterns to match.
  ///
  /// Each must start with / and the only place a * is allowed is at the end
  /// following a /. The string fed to the path matcher does not include any
  /// text after the first ? or #, and those chars are not allowed here.
  core.List<core.String>? paths;

  /// In response to a matching path, the load balancer performs advanced
  /// routing actions like URL rewrites, header transformations, etc.
  ///
  /// prior to forwarding the request to the selected backend. If routeAction
  /// specifies any weightedBackendServices, service must not be set. Conversely
  /// if service is set, routeAction cannot contain any weightedBackendServices.
  /// Only one of routeAction or urlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within a pathRule's routeAction.
  HttpRouteAction? routeAction;

  /// The full or partial URL of the backend service resource to which traffic
  /// is directed if this rule is matched.
  ///
  /// If routeAction is additionally specified, advanced routing actions like
  /// URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if service is specified, routeAction cannot contain any
  /// weightedBackendService s. Conversely, if routeAction specifies any
  /// weightedBackendServices, service must not be specified.
  /// Only one of urlRedirect, service or routeAction.weightedBackendService
  /// must be set.
  core.String? service;

  /// When a path pattern is matched, the request is redirected to a URL
  /// specified by urlRedirect.
  /// If urlRedirect is specified, service or routeAction must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? urlRedirect;

  PathRule();

  PathRule.fromJson(core.Map _json) {
    if (_json.containsKey('paths')) {
      paths = (_json['paths'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('routeAction')) {
      routeAction = HttpRouteAction.fromJson(
          _json['routeAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('urlRedirect')) {
      urlRedirect = HttpRedirectAction.fromJson(
          _json['urlRedirect'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (paths != null) 'paths': paths!,
        if (routeAction != null) 'routeAction': routeAction!.toJson(),
        if (service != null) 'service': service!,
        if (urlRedirect != null) 'urlRedirect': urlRedirect!.toJson(),
      };
}

class PerInstanceConfig {
  /// Fingerprint of this per-instance config.
  ///
  /// This field can be used in optimistic locking. It is ignored when inserting
  /// a per-instance config. An up-to-date fingerprint must be provided in order
  /// to update an existing per-instance config or the field needs to be unset.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The name of a per-instance config and its corresponding instance.
  ///
  /// Serves as a merge key during UpdatePerInstanceConfigs operations, that is,
  /// if a per-instance config with the same name exists then it will be
  /// updated, otherwise a new one will be created for the VM instance with the
  /// same name. An attempt to create a per-instance config for a VM instance
  /// that either doesn't exist or is not part of the group will result in an
  /// error.
  core.String? name;

  /// The intended preserved state for the given instance.
  ///
  /// Does not contain preserved state generated from a stateful policy.
  PreservedState? preservedState;

  /// The status of applying this per-instance config on the corresponding
  /// managed instance.
  /// Possible string values are:
  /// - "APPLYING"
  /// - "DELETING"
  /// - "EFFECTIVE"
  /// - "NONE"
  /// - "UNAPPLIED"
  /// - "UNAPPLIED_DELETION"
  core.String? status;

  PerInstanceConfig();

  PerInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('preservedState')) {
      preservedState = PreservedState.fromJson(
          _json['preservedState'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (name != null) 'name': name!,
        if (preservedState != null) 'preservedState': preservedState!.toJson(),
        if (status != null) 'status': status!,
      };
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
///
/// A `Policy` is a collection of `bindings`.
///
/// A `binding` binds one or more `members` to a single `role`. Members can be
/// user accounts, service accounts, Google groups, and domains (such as G
/// Suite). A `role` is a named list of permissions; each `role` can be an IAM
/// predefined role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// { "bindings": \[ { "role": "roles/resourcemanager.organizationAdmin",
/// "members": \[ "user:mike@example.com", "group:admins@example.com",
/// "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" \] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": \[
/// "user:eve@example.com" \], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } \], "etag":
/// "BwWWja0YfJA=", "version": 3 }
///
/// **YAML example:**
///
/// bindings: - members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') -
/// etag: BwWWja0YfJA= - version: 3
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
class Policy {
  /// Specifies cloud audit logging configuration for this policy.
  core.List<AuditConfig>? auditConfigs;

  /// Associates a list of `members` to a `role`.
  ///
  /// Optionally, may specify a `condition` that determines how and when the
  /// `bindings` are applied. Each of the `bindings` must contain at least one
  /// member.
  core.List<Binding>? bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other.
  ///
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  core.bool? iamOwned;

  /// If more than one rule is specified, the rules are applied in the following
  /// manner: - All matching LOG rules are always applied.
  ///
  /// - If any DENY/DENY_WITH_LOG rule matches, permission is denied. Logging
  /// will be applied if one or more matching rule requires logging. -
  /// Otherwise, if any ALLOW/ALLOW_WITH_LOG rule matches, permission is
  /// granted. Logging will be applied if one or more matching rule requires
  /// logging. - Otherwise, if no rule applies, permission is denied.
  core.List<Rule>? rules;

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`.
  ///
  /// Requests that specify an invalid value are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag`
  /// field whenever you call `setIamPolicy`. If you omit this field, then IAM
  /// allows you to overwrite a version `3` policy with a version `1` policy,
  /// and all of the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int? version;

  Policy();

  Policy.fromJson(core.Map _json) {
    if (_json.containsKey('auditConfigs')) {
      auditConfigs = (_json['auditConfigs'] as core.List)
          .map<AuditConfig>((value) => AuditConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('iamOwned')) {
      iamOwned = _json['iamOwned'] as core.bool;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<Rule>((value) =>
              Rule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('version')) {
      version = _json['version'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (auditConfigs != null)
          'auditConfigs': auditConfigs!.map((value) => value.toJson()).toList(),
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (iamOwned != null) 'iamOwned': iamOwned!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (version != null) 'version': version!,
      };
}

class PreconfiguredWafSet {
  /// List of entities that are currently supported for WAF rules.
  core.List<WafExpressionSet>? expressionSets;

  PreconfiguredWafSet();

  PreconfiguredWafSet.fromJson(core.Map _json) {
    if (_json.containsKey('expressionSets')) {
      expressionSets = (_json['expressionSets'] as core.List)
          .map<WafExpressionSet>((value) => WafExpressionSet.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (expressionSets != null)
          'expressionSets':
              expressionSets!.map((value) => value.toJson()).toList(),
      };
}

/// Preserved state for a given instance.
class PreservedState {
  /// Preserved disks defined for this instance.
  ///
  /// This map is keyed with the device names of the disks.
  core.Map<core.String, PreservedStatePreservedDisk>? disks;

  /// Preserved metadata defined for this instance.
  core.Map<core.String, core.String>? metadata;

  PreservedState();

  PreservedState.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          PreservedStatePreservedDisk.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('metadata')) {
      metadata = (_json['metadata'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (metadata != null) 'metadata': metadata!,
      };
}

class PreservedStatePreservedDisk {
  /// These stateful disks will never be deleted during autohealing, update,
  /// instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole MIG
  /// is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
  ///
  /// If not specified, the default is to attach the disk in READ_WRITE mode.
  /// Possible string values are:
  /// - "READ_ONLY"
  /// - "READ_WRITE"
  core.String? mode;

  /// The URL of the disk resource that is stateful and should be attached to
  /// the VM instance.
  core.String? source;

  PreservedStatePreservedDisk();

  PreservedStatePreservedDisk.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.String;
    }
    if (_json.containsKey('mode')) {
      mode = _json['mode'] as core.String;
    }
    if (_json.containsKey('source')) {
      source = _json['source'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
        if (mode != null) 'mode': mode!,
        if (source != null) 'source': source!,
      };
}

/// Represents a Project resource.
///
/// A project is used to organize resources in a Google Cloud Platform
/// environment.
///
/// For more information, read about the Resource Hierarchy. (== resource_for
/// {$api_version}.projects ==)
class Project {
  /// Metadata key/value pairs available to all instances contained in this
  /// project.
  ///
  /// See Custom metadata for more information.
  Metadata? commonInstanceMetadata;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// This signifies the default network tier used for configuring resources of
  /// the project and can only take the following values: PREMIUM, STANDARD.
  ///
  /// Initially the default network tier is PREMIUM.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? defaultNetworkTier;

  /// Default service account used by VMs running in this project.
  ///
  /// Output only.
  core.String? defaultServiceAccount;

  /// An optional textual description of the resource.
  core.String? description;

  /// Restricted features enabled for use on this project.
  core.List<core.String>? enabledFeatures;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server. This is not the project ID, and
  /// is just a unique ID used by Compute Engine to identify resources.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#project for projects.
  ///
  /// Output only.
  core.String? kind;

  /// The project ID.
  ///
  /// For example: my-example-project. Use the project ID to make requests to
  /// Compute Engine.
  core.String? name;

  /// Quotas assigned to this project.
  ///
  /// Output only.
  core.List<Quota>? quotas;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The naming prefix for daily usage reports and the Google Cloud Storage
  /// bucket where they are stored.
  UsageExportLocation? usageExportLocation;

  /// The role this project has in a shared VPC configuration.
  ///
  /// Currently, only projects with the host role, which is specified by the
  /// value HOST, are differentiated.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HOST"
  /// - "UNSPECIFIED_XPN_PROJECT_STATUS"
  core.String? xpnProjectStatus;

  Project();

  Project.fromJson(core.Map _json) {
    if (_json.containsKey('commonInstanceMetadata')) {
      commonInstanceMetadata = Metadata.fromJson(_json['commonInstanceMetadata']
          as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultNetworkTier')) {
      defaultNetworkTier = _json['defaultNetworkTier'] as core.String;
    }
    if (_json.containsKey('defaultServiceAccount')) {
      defaultServiceAccount = _json['defaultServiceAccount'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enabledFeatures')) {
      enabledFeatures = (_json['enabledFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('quotas')) {
      quotas = (_json['quotas'] as core.List)
          .map<Quota>((value) =>
              Quota.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('usageExportLocation')) {
      usageExportLocation = UsageExportLocation.fromJson(
          _json['usageExportLocation'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('xpnProjectStatus')) {
      xpnProjectStatus = _json['xpnProjectStatus'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (commonInstanceMetadata != null)
          'commonInstanceMetadata': commonInstanceMetadata!.toJson(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultNetworkTier != null)
          'defaultNetworkTier': defaultNetworkTier!,
        if (defaultServiceAccount != null)
          'defaultServiceAccount': defaultServiceAccount!,
        if (description != null) 'description': description!,
        if (enabledFeatures != null) 'enabledFeatures': enabledFeatures!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (quotas != null)
          'quotas': quotas!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (usageExportLocation != null)
          'usageExportLocation': usageExportLocation!.toJson(),
        if (xpnProjectStatus != null) 'xpnProjectStatus': xpnProjectStatus!,
      };
}

class ProjectsDisableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId? xpnResource;

  ProjectsDisableXpnResourceRequest();

  ProjectsDisableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('xpnResource')) {
      xpnResource = XpnResourceId.fromJson(
          _json['xpnResource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (xpnResource != null) 'xpnResource': xpnResource!.toJson(),
      };
}

class ProjectsEnableXpnResourceRequest {
  /// Service resource (a.k.a service project) ID.
  XpnResourceId? xpnResource;

  ProjectsEnableXpnResourceRequest();

  ProjectsEnableXpnResourceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('xpnResource')) {
      xpnResource = XpnResourceId.fromJson(
          _json['xpnResource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (xpnResource != null) 'xpnResource': xpnResource!.toJson(),
      };
}

class ProjectsGetXpnResources {
  /// Type of resource.
  ///
  /// Always compute#projectsGetXpnResources for lists of service resources
  /// (a.k.a service projects)
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Service resources (a.k.a service projects) attached to this project as
  /// their shared VPC host.
  core.List<XpnResourceId>? resources;

  ProjectsGetXpnResources();

  ProjectsGetXpnResources.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('resources')) {
      resources = (_json['resources'] as core.List)
          .map<XpnResourceId>((value) => XpnResourceId.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (resources != null)
          'resources': resources!.map((value) => value.toJson()).toList(),
      };
}

class ProjectsListXpnHostsRequest {
  /// Optional organization ID managed by Cloud Resource Manager, for which to
  /// list shared VPC host projects.
  ///
  /// If not specified, the organization will be inferred from the project.
  core.String? organization;

  ProjectsListXpnHostsRequest();

  ProjectsListXpnHostsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('organization')) {
      organization = _json['organization'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (organization != null) 'organization': organization!,
      };
}

class ProjectsSetDefaultNetworkTierRequest {
  /// Default network tier to be set.
  /// Possible string values are:
  /// - "PREMIUM"
  /// - "STANDARD"
  core.String? networkTier;

  ProjectsSetDefaultNetworkTierRequest();

  ProjectsSetDefaultNetworkTierRequest.fromJson(core.Map _json) {
    if (_json.containsKey('networkTier')) {
      networkTier = _json['networkTier'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (networkTier != null) 'networkTier': networkTier!,
      };
}

/// A quotas entry.
class Quota {
  /// Quota limit for this metric.
  ///
  /// Output only.
  core.double? limit;

  /// Name of the quota metric.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "A2_CPUS"
  /// - "AFFINITY_GROUPS"
  /// - "AUTOSCALERS"
  /// - "BACKEND_BUCKETS"
  /// - "BACKEND_SERVICES"
  /// - "C2_CPUS"
  /// - "COMMITMENTS"
  /// - "COMMITTED_A2_CPUS"
  /// - "COMMITTED_C2_CPUS"
  /// - "COMMITTED_CPUS"
  /// - "COMMITTED_E2_CPUS"
  /// - "COMMITTED_LICENSES"
  /// - "COMMITTED_LOCAL_SSD_TOTAL_GB"
  /// - "COMMITTED_MEMORY_OPTIMIZED_CPUS"
  /// - "COMMITTED_N2D_CPUS"
  /// - "COMMITTED_N2_CPUS"
  /// - "COMMITTED_NVIDIA_A100_GPUS"
  /// - "COMMITTED_NVIDIA_K80_GPUS"
  /// - "COMMITTED_NVIDIA_P100_GPUS"
  /// - "COMMITTED_NVIDIA_P4_GPUS"
  /// - "COMMITTED_NVIDIA_T4_GPUS"
  /// - "COMMITTED_NVIDIA_V100_GPUS"
  /// - "CPUS"
  /// - "CPUS_ALL_REGIONS"
  /// - "DISKS_TOTAL_GB"
  /// - "E2_CPUS"
  /// - "EXTERNAL_NETWORK_LB_FORWARDING_RULES"
  /// - "EXTERNAL_PROTOCOL_FORWARDING_RULES"
  /// - "EXTERNAL_VPN_GATEWAYS"
  /// - "FIREWALLS"
  /// - "FORWARDING_RULES"
  /// - "GLOBAL_INTERNAL_ADDRESSES"
  /// - "GPUS_ALL_REGIONS"
  /// - "HEALTH_CHECKS"
  /// - "IMAGES"
  /// - "INSTANCES"
  /// - "INSTANCE_GROUPS"
  /// - "INSTANCE_GROUP_MANAGERS"
  /// - "INSTANCE_TEMPLATES"
  /// - "INTERCONNECTS"
  /// - "INTERCONNECT_ATTACHMENTS_PER_REGION"
  /// - "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS"
  /// - "INTERCONNECT_TOTAL_GBPS"
  /// - "INTERNAL_ADDRESSES"
  /// - "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES"
  /// - "IN_PLACE_SNAPSHOTS"
  /// - "IN_USE_ADDRESSES"
  /// - "IN_USE_BACKUP_SCHEDULES"
  /// - "IN_USE_SNAPSHOT_SCHEDULES"
  /// - "LOCAL_SSD_TOTAL_GB"
  /// - "M1_CPUS"
  /// - "M2_CPUS"
  /// - "MACHINE_IMAGES"
  /// - "N2D_CPUS"
  /// - "N2_CPUS"
  /// - "NETWORKS"
  /// - "NETWORK_ENDPOINT_GROUPS"
  /// - "NETWORK_FIREWALL_POLICIES"
  /// - "NODE_GROUPS"
  /// - "NODE_TEMPLATES"
  /// - "NVIDIA_A100_GPUS"
  /// - "NVIDIA_K80_GPUS"
  /// - "NVIDIA_P100_GPUS"
  /// - "NVIDIA_P100_VWS_GPUS"
  /// - "NVIDIA_P4_GPUS"
  /// - "NVIDIA_P4_VWS_GPUS"
  /// - "NVIDIA_T4_GPUS"
  /// - "NVIDIA_T4_VWS_GPUS"
  /// - "NVIDIA_V100_GPUS"
  /// - "PACKET_MIRRORINGS"
  /// - "PD_EXTREME_TOTAL_PROVISIONED_IOPS"
  /// - "PREEMPTIBLE_CPUS"
  /// - "PREEMPTIBLE_LOCAL_SSD_GB"
  /// - "PREEMPTIBLE_NVIDIA_A100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_K80_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS"
  /// - "PREEMPTIBLE_NVIDIA_V100_GPUS"
  /// - "PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK"
  /// - "PUBLIC_ADVERTISED_PREFIXES"
  /// - "PUBLIC_DELEGATED_PREFIXES"
  /// - "REGIONAL_AUTOSCALERS"
  /// - "REGIONAL_INSTANCE_GROUP_MANAGERS"
  /// - "RESERVATIONS"
  /// - "RESOURCE_POLICIES"
  /// - "ROUTERS"
  /// - "ROUTES"
  /// - "SECURITY_POLICIES"
  /// - "SECURITY_POLICY_CEVAL_RULES"
  /// - "SECURITY_POLICY_RULES"
  /// - "SNAPSHOTS"
  /// - "SSD_TOTAL_GB"
  /// - "SSL_CERTIFICATES"
  /// - "STATIC_ADDRESSES"
  /// - "STATIC_BYOIP_ADDRESSES"
  /// - "SUBNETWORKS"
  /// - "TARGET_HTTPS_PROXIES"
  /// - "TARGET_HTTP_PROXIES"
  /// - "TARGET_INSTANCES"
  /// - "TARGET_POOLS"
  /// - "TARGET_SSL_PROXIES"
  /// - "TARGET_TCP_PROXIES"
  /// - "TARGET_VPN_GATEWAYS"
  /// - "URL_MAPS"
  /// - "VPN_GATEWAYS"
  /// - "VPN_TUNNELS"
  /// - "XPN_SERVICE_PROJECTS"
  core.String? metric;

  /// Owning resource.
  ///
  /// This is the resource on which this quota is applied.
  ///
  /// Output only.
  core.String? owner;

  /// Current usage of this metric.
  ///
  /// Output only.
  core.double? usage;

  Quota();

  Quota.fromJson(core.Map _json) {
    if (_json.containsKey('limit')) {
      limit = (_json['limit'] as core.num).toDouble();
    }
    if (_json.containsKey('metric')) {
      metric = _json['metric'] as core.String;
    }
    if (_json.containsKey('owner')) {
      owner = _json['owner'] as core.String;
    }
    if (_json.containsKey('usage')) {
      usage = (_json['usage'] as core.num).toDouble();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (limit != null) 'limit': limit!,
        if (metric != null) 'metric': metric!,
        if (owner != null) 'owner': owner!,
        if (usage != null) 'usage': usage!,
      };
}

/// Represents a reference to a resource.
class Reference {
  /// Type of the resource.
  ///
  /// Always compute#reference for references.
  ///
  /// Output only.
  core.String? kind;

  /// A description of the reference type with no implied semantics.
  ///
  /// Possible values include:
  /// - MEMBER_OF
  core.String? referenceType;

  /// URL of the resource which refers to the target.
  core.String? referrer;

  /// URL of the resource to which this reference points.
  core.String? target;

  Reference();

  Reference.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('referenceType')) {
      referenceType = _json['referenceType'] as core.String;
    }
    if (_json.containsKey('referrer')) {
      referrer = _json['referrer'] as core.String;
    }
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (referenceType != null) 'referenceType': referenceType!,
        if (referrer != null) 'referrer': referrer!,
        if (target != null) 'target': target!,
      };
}

/// Represents a Region resource.
///
/// A region is a geographical area where a resource is located.
///
/// For more information, read Regions and Zones. (== resource_for
/// {$api_version}.regions ==)
class Region {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this region.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// Textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#region for regions.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Quotas assigned to this region.
  ///
  /// Output only.
  core.List<Quota>? quotas;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Status of the region, either UP or DOWN.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String? status;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? supportsPzs;

  /// A list of zones available in this region, in the form of resource URLs.
  ///
  /// Output only.
  core.List<core.String>? zones;

  Region();

  Region.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('quotas')) {
      quotas = (_json['quotas'] as core.List)
          .map<Quota>((value) =>
              Quota.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('supportsPzs')) {
      supportsPzs = _json['supportsPzs'] as core.bool;
    }
    if (_json.containsKey('zones')) {
      zones = (_json['zones'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (quotas != null)
          'quotas': quotas!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (supportsPzs != null) 'supportsPzs': supportsPzs!,
        if (zones != null) 'zones': zones!,
      };
}

class RegionAutoscalerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionAutoscalerListWarningData();

  RegionAutoscalerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionAutoscalerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionAutoscalerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionAutoscalerListWarning();

  RegionAutoscalerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionAutoscalerListWarningData>((value) =>
              RegionAutoscalerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of autoscalers.
class RegionAutoscalerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Autoscaler resources.
  core.List<Autoscaler>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionAutoscalerListWarning? warning;

  RegionAutoscalerList();

  RegionAutoscalerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Autoscaler>((value) =>
              Autoscaler.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionAutoscalerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionDiskTypeListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionDiskTypeListWarningData();

  RegionDiskTypeListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionDiskTypeListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionDiskTypeListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionDiskTypeListWarning();

  RegionDiskTypeListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionDiskTypeListWarningData>((value) =>
              RegionDiskTypeListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionDiskTypeList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of DiskType resources.
  core.List<DiskType>? items;

  /// Type of resource.
  ///
  /// Always compute#regionDiskTypeList for region disk types.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionDiskTypeListWarning? warning;

  RegionDiskTypeList();

  RegionDiskTypeList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<DiskType>((value) =>
              DiskType.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionDiskTypeListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionDisksAddResourcePoliciesRequest {
  /// Resource policies to be added to this disk.
  core.List<core.String>? resourcePolicies;

  RegionDisksAddResourcePoliciesRequest();

  RegionDisksAddResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class RegionDisksRemoveResourcePoliciesRequest {
  /// Resource policies to be removed from this disk.
  core.List<core.String>? resourcePolicies;

  RegionDisksRemoveResourcePoliciesRequest();

  RegionDisksRemoveResourcePoliciesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null) 'resourcePolicies': resourcePolicies!,
      };
}

class RegionDisksResizeRequest {
  /// The new size of the regional persistent disk, which is specified in GB.
  core.String? sizeGb;

  RegionDisksResizeRequest();

  RegionDisksResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sizeGb')) {
      sizeGb = _json['sizeGb'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sizeGb != null) 'sizeGb': sizeGb!,
      };
}

class RegionInstanceGroupListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupListWarningData();

  RegionInstanceGroupListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupListWarning();

  RegionInstanceGroupListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupListWarningData>((value) =>
              RegionInstanceGroupListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of InstanceGroup resources.
class RegionInstanceGroupList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroup resources.
  core.List<InstanceGroup>? items;

  /// The resource type.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupListWarning? warning;

  RegionInstanceGroupList();

  RegionInstanceGroupList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroup>((value) => InstanceGroup.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// RegionInstanceGroupManagers.deletePerInstanceConfigs
class RegionInstanceGroupManagerDeleteInstanceConfigReq {
  /// The list of instance names for which we want to delete per-instance
  /// configs on this managed instance group.
  core.List<core.String>? names;

  RegionInstanceGroupManagerDeleteInstanceConfigReq();

  RegionInstanceGroupManagerDeleteInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('names')) {
      names = (_json['names'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

class RegionInstanceGroupManagerListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupManagerListWarningData();

  RegionInstanceGroupManagerListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupManagerListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupManagerListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupManagerListWarning();

  RegionInstanceGroupManagerListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupManagerListWarningData>((value) =>
              RegionInstanceGroupManagerListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of managed instance groups.
class RegionInstanceGroupManagerList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceGroupManager resources.
  core.List<InstanceGroupManager>? items;

  /// The resource type, which is always compute#instanceGroupManagerList for a
  /// list of managed instance groups that exist in th regional scope.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupManagerListWarning? warning;

  RegionInstanceGroupManagerList();

  RegionInstanceGroupManagerList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceGroupManager>((value) => InstanceGroupManager.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupManagerListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// RegionInstanceGroupManagers.patchPerInstanceConfigs
class RegionInstanceGroupManagerPatchInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  RegionInstanceGroupManagerPatchInstanceConfigReq();

  RegionInstanceGroupManagerPatchInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

/// RegionInstanceGroupManagers.updatePerInstanceConfigs
class RegionInstanceGroupManagerUpdateInstanceConfigReq {
  /// The list of per-instance configs to insert or patch on this managed
  /// instance group.
  core.List<PerInstanceConfig>? perInstanceConfigs;

  RegionInstanceGroupManagerUpdateInstanceConfigReq();

  RegionInstanceGroupManagerUpdateInstanceConfigReq.fromJson(core.Map _json) {
    if (_json.containsKey('perInstanceConfigs')) {
      perInstanceConfigs = (_json['perInstanceConfigs'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (perInstanceConfigs != null)
          'perInstanceConfigs':
              perInstanceConfigs!.map((value) => value.toJson()).toList(),
      };
}

class RegionInstanceGroupManagersAbandonInstancesRequest {
  /// The URLs of one or more instances to abandon.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  RegionInstanceGroupManagersAbandonInstancesRequest();

  RegionInstanceGroupManagersAbandonInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

/// RegionInstanceGroupManagers.applyUpdatesToInstances
class RegionInstanceGroupManagersApplyUpdatesRequest {
  /// Flag to update all instances instead of specified list of ?instances?.
  ///
  /// If the flag is set to true then the instances may not be specified in the
  /// request.
  core.bool? allInstances;

  /// The list of URLs of one or more instances for which you want to apply
  /// updates.
  ///
  /// Each URL can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  /// The minimal action that you want to perform on each instance during the
  /// update:
  /// - REPLACE: At minimum, delete the instance and create it again.
  ///
  ///
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all. By default, the minimum action
  /// is NONE. If your update requires a more disruptive action than you set
  /// with this flag, the necessary action is performed to execute the update.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String? minimalAction;

  /// The most disruptive action that you want to perform on each instance
  /// during the update:
  /// - REPLACE: Delete the instance and create it again.
  ///
  ///
  /// - RESTART: Stop the instance and start it again.
  /// - REFRESH: Do not stop the instance.
  /// - NONE: Do not disrupt the instance at all. By default, the most
  /// disruptive allowed action is REPLACE. If your update requires a more
  /// disruptive action than you set with this flag, the update request will
  /// fail.
  /// Possible string values are:
  /// - "NONE"
  /// - "REFRESH"
  /// - "REPLACE"
  /// - "RESTART"
  core.String? mostDisruptiveAllowedAction;

  RegionInstanceGroupManagersApplyUpdatesRequest();

  RegionInstanceGroupManagersApplyUpdatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('allInstances')) {
      allInstances = _json['allInstances'] as core.bool;
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('minimalAction')) {
      minimalAction = _json['minimalAction'] as core.String;
    }
    if (_json.containsKey('mostDisruptiveAllowedAction')) {
      mostDisruptiveAllowedAction =
          _json['mostDisruptiveAllowedAction'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (allInstances != null) 'allInstances': allInstances!,
        if (instances != null) 'instances': instances!,
        if (minimalAction != null) 'minimalAction': minimalAction!,
        if (mostDisruptiveAllowedAction != null)
          'mostDisruptiveAllowedAction': mostDisruptiveAllowedAction!,
      };
}

/// RegionInstanceGroupManagers.createInstances
class RegionInstanceGroupManagersCreateInstancesRequest {
  /// List of specifications of per-instance configs.
  ///
  /// Required.
  core.List<PerInstanceConfig>? instances;

  RegionInstanceGroupManagersCreateInstancesRequest();

  RegionInstanceGroupManagersCreateInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class RegionInstanceGroupManagersDeleteInstancesRequest {
  /// The URLs of one or more instances to delete.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  RegionInstanceGroupManagersDeleteInstancesRequest();

  RegionInstanceGroupManagersDeleteInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

class RegionInstanceGroupManagersListErrorsResponse {
  /// The list of errors of the managed instance group.
  ///
  /// Output only.
  core.List<InstanceManagedByIgmError>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  RegionInstanceGroupManagersListErrorsResponse();

  RegionInstanceGroupManagersListErrorsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceManagedByIgmError>((value) =>
              InstanceManagedByIgmError.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class RegionInstanceGroupManagersListInstanceConfigsRespWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData();

  RegionInstanceGroupManagersListInstanceConfigsRespWarningData.fromJson(
      core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupManagersListInstanceConfigsRespWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupManagersListInstanceConfigsRespWarningData>?
      data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupManagersListInstanceConfigsRespWarning();

  RegionInstanceGroupManagersListInstanceConfigsRespWarning.fromJson(
      core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupManagersListInstanceConfigsRespWarningData>(
              (value) =>
                  RegionInstanceGroupManagersListInstanceConfigsRespWarningData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionInstanceGroupManagersListInstanceConfigsResp {
  /// The list of PerInstanceConfig.
  ///
  /// Output only.
  core.List<PerInstanceConfig>? items;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupManagersListInstanceConfigsRespWarning? warning;

  RegionInstanceGroupManagersListInstanceConfigsResp();

  RegionInstanceGroupManagersListInstanceConfigsResp.fromJson(core.Map _json) {
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<PerInstanceConfig>((value) => PerInstanceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning =
          RegionInstanceGroupManagersListInstanceConfigsRespWarning.fromJson(
              _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionInstanceGroupManagersListInstancesResponse {
  /// A list of managed instances.
  core.List<ManagedInstance>? managedInstances;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  RegionInstanceGroupManagersListInstancesResponse();

  RegionInstanceGroupManagersListInstancesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('managedInstances')) {
      managedInstances = (_json['managedInstances'] as core.List)
          .map<ManagedInstance>((value) => ManagedInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (managedInstances != null)
          'managedInstances':
              managedInstances!.map((value) => value.toJson()).toList(),
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

class RegionInstanceGroupManagersRecreateRequest {
  /// The URLs of one or more instances to recreate.
  ///
  /// This can be a full URL or a partial URL, such as
  /// zones/\[ZONE\]/instances/\[INSTANCE_NAME\].
  core.List<core.String>? instances;

  RegionInstanceGroupManagersRecreateRequest();

  RegionInstanceGroupManagersRecreateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
      };
}

class RegionInstanceGroupManagersSetTargetPoolsRequest {
  /// Fingerprint of the target pools information, which is a hash of the
  /// contents.
  ///
  /// This field is used for optimistic locking when you update the target pool
  /// entries. This field is optional.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The URL of all TargetPool resources to which instances in the
  /// instanceGroup field are added.
  ///
  /// The target pools automatically apply to all of the instances in the
  /// managed instance group.
  core.List<core.String>? targetPools;

  RegionInstanceGroupManagersSetTargetPoolsRequest();

  RegionInstanceGroupManagersSetTargetPoolsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (targetPools != null) 'targetPools': targetPools!,
      };
}

class RegionInstanceGroupManagersSetTemplateRequest {
  /// URL of the InstanceTemplate resource from which all new instances will be
  /// created.
  core.String? instanceTemplate;

  RegionInstanceGroupManagersSetTemplateRequest();

  RegionInstanceGroupManagersSetTemplateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceTemplate')) {
      instanceTemplate = _json['instanceTemplate'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceTemplate != null) 'instanceTemplate': instanceTemplate!,
      };
}

class RegionInstanceGroupsListInstancesWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionInstanceGroupsListInstancesWarningData();

  RegionInstanceGroupsListInstancesWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionInstanceGroupsListInstancesWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionInstanceGroupsListInstancesWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionInstanceGroupsListInstancesWarning();

  RegionInstanceGroupsListInstancesWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionInstanceGroupsListInstancesWarningData>((value) =>
              RegionInstanceGroupsListInstancesWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RegionInstanceGroupsListInstances {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of InstanceWithNamedPorts resources.
  core.List<InstanceWithNamedPorts>? items;

  /// The resource type.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionInstanceGroupsListInstancesWarning? warning;

  RegionInstanceGroupsListInstances();

  RegionInstanceGroupsListInstances.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<InstanceWithNamedPorts>((value) =>
              InstanceWithNamedPorts.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionInstanceGroupsListInstancesWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionInstanceGroupsListInstancesRequest {
  /// Instances in which state should be returned.
  ///
  /// Valid options are: 'ALL', 'RUNNING'. By default, it lists all instances.
  /// Possible string values are:
  /// - "ALL"
  /// - "RUNNING"
  core.String? instanceState;

  /// Name of port user is interested in.
  ///
  /// It is optional. If it is set, only information about this ports will be
  /// returned. If it is not set, all the named ports will be returned. Always
  /// lists all instances.
  core.String? portName;

  RegionInstanceGroupsListInstancesRequest();

  RegionInstanceGroupsListInstancesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instanceState')) {
      instanceState = _json['instanceState'] as core.String;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceState != null) 'instanceState': instanceState!,
        if (portName != null) 'portName': portName!,
      };
}

class RegionInstanceGroupsSetNamedPortsRequest {
  /// The fingerprint of the named ports information for this instance group.
  ///
  /// Use this optional property to prevent conflicts when multiple users change
  /// the named ports settings concurrently. Obtain the fingerprint with the
  /// instanceGroups.get method. Then, include the fingerprint in your request
  /// to ensure that you do not overwrite changes that were applied from another
  /// concurrent request.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The list of named ports to set for this instance group.
  core.List<NamedPort>? namedPorts;

  RegionInstanceGroupsSetNamedPortsRequest();

  RegionInstanceGroupsSetNamedPortsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('namedPorts')) {
      namedPorts = (_json['namedPorts'] as core.List)
          .map<NamedPort>((value) =>
              NamedPort.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (namedPorts != null)
          'namedPorts': namedPorts!.map((value) => value.toJson()).toList(),
      };
}

class RegionListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RegionListWarningData();

  RegionListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RegionListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RegionListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RegionListWarning();

  RegionListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RegionListWarningData>((value) => RegionListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of region resources.
class RegionList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Region resources.
  core.List<Region>? items;

  /// Type of resource.
  ///
  /// Always compute#regionList for lists of regions.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RegionListWarning? warning;

  RegionList();

  RegionList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Region>((value) =>
              Region.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RegionListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RegionSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  RegionSetLabelsRequest();

  RegionSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class RegionSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  RegionSetPolicyRequest();

  RegionSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}

class RegionTargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  ///
  /// Currently exactly one SslCertificate resource must be specified.
  core.List<core.String>? sslCertificates;

  RegionTargetHttpsProxiesSetSslCertificatesRequest();

  RegionTargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

class RegionUrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap? resource;

  RegionUrlMapsValidateRequest();

  RegionUrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = UrlMap.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

/// A policy that specifies how requests intended for the route's backends are
/// shadowed to a separate mirrored backend service.
///
/// Loadbalancer does not wait for responses from the shadow service. Prior to
/// sending traffic to the shadow service, the host / authority header is
/// suffixed with -shadow.
class RequestMirrorPolicy {
  /// The full or partial URL to the BackendService resource being mirrored to.
  core.String? backendService;

  RequestMirrorPolicy();

  RequestMirrorPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
      };
}

/// Represents a reservation resource.
///
/// A reservation ensures that capacity is held in a specific zone even if the
/// reserved VMs are not running. For more information, read Reserving zonal
/// resources. (== resource_for {$api_version}.reservations ==)
class Reservation {
  /// Full or partial URL to a parent commitment.
  ///
  /// This field displays for reservations that are tied to a commitment.
  ///
  /// Output only.
  core.String? commitment;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#reservations for reservations.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Reservation for instances with specific machine shapes.
  AllocationSpecificSKUReservation? specificReservation;

  /// Indicates whether the reservation can be consumed by VMs with affinity for
  /// "any" reservation.
  ///
  /// If the field is set, then only VMs that target the reservation by name can
  /// consume from this reservation.
  core.bool? specificReservationRequired;

  /// The status of the reservation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "INVALID"
  /// - "READY"
  /// - "UPDATING"
  core.String? status;

  /// Zone in which the reservation resides.
  ///
  /// A zone must be provided if the reservation is created within a commitment.
  core.String? zone;

  Reservation();

  Reservation.fromJson(core.Map _json) {
    if (_json.containsKey('commitment')) {
      commitment = _json['commitment'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('specificReservation')) {
      specificReservation = AllocationSpecificSKUReservation.fromJson(
          _json['specificReservation'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('specificReservationRequired')) {
      specificReservationRequired =
          _json['specificReservationRequired'] as core.bool;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (commitment != null) 'commitment': commitment!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (specificReservation != null)
          'specificReservation': specificReservation!.toJson(),
        if (specificReservationRequired != null)
          'specificReservationRequired': specificReservationRequired!,
        if (status != null) 'status': status!,
        if (zone != null) 'zone': zone!,
      };
}

/// Specifies the reservations that this instance can consume from.
class ReservationAffinity {
  /// Specifies the type of reservation from which this instance can consume
  /// resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
  /// NO_RESERVATION.
  ///
  /// See  Consuming reserved instances for examples.
  /// Possible string values are:
  /// - "ANY_RESERVATION"
  /// - "NO_RESERVATION"
  /// - "SPECIFIC_RESERVATION"
  /// - "UNSPECIFIED"
  core.String? consumeReservationType;

  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, specify
  /// googleapis.com/reservation-name as the key and specify the name of your
  /// reservation as its value.
  core.String? key;

  /// Corresponds to the label values of a reservation resource.
  core.List<core.String>? values;

  ReservationAffinity();

  ReservationAffinity.fromJson(core.Map _json) {
    if (_json.containsKey('consumeReservationType')) {
      consumeReservationType = _json['consumeReservationType'] as core.String;
    }
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (consumeReservationType != null)
          'consumeReservationType': consumeReservationType!,
        if (key != null) 'key': key!,
        if (values != null) 'values': values!,
      };
}

class ReservationAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationAggregatedListWarningData();

  ReservationAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ReservationAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationAggregatedListWarning();

  ReservationAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationAggregatedListWarningData>((value) =>
              ReservationAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of reservations.
class ReservationAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Allocation resources.
  core.Map<core.String, ReservationsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ReservationAggregatedListWarning? warning;

  ReservationAggregatedList();

  ReservationAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          ReservationsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ReservationAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ReservationListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationListWarningData();

  ReservationListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ReservationListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationListWarning();

  ReservationListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationListWarningData>((value) =>
              ReservationListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ReservationList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Allocation resources.
  ///
  /// Output only.
  core.List<Reservation>? items;

  /// Type of resource.Always compute#reservationsList for listsof reservations
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ReservationListWarning? warning;

  ReservationList();

  ReservationList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ReservationListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ReservationsResizeRequest {
  /// Number of allocated resources can be resized with minimum = 1 and maximum
  /// = 1000.
  core.String? specificSkuCount;

  ReservationsResizeRequest();

  ReservationsResizeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('specificSkuCount')) {
      specificSkuCount = _json['specificSkuCount'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (specificSkuCount != null) 'specificSkuCount': specificSkuCount!,
      };
}

class ReservationsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ReservationsScopedListWarningData();

  ReservationsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of reservations when the list
/// is empty.
class ReservationsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ReservationsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ReservationsScopedListWarning();

  ReservationsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ReservationsScopedListWarningData>((value) =>
              ReservationsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ReservationsScopedList {
  /// A list of reservations contained in this scope.
  core.List<Reservation>? reservations;

  /// Informational warning which replaces the list of reservations when the
  /// list is empty.
  ReservationsScopedListWarning? warning;

  ReservationsScopedList();

  ReservationsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('reservations')) {
      reservations = (_json['reservations'] as core.List)
          .map<Reservation>((value) => Reservation.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ReservationsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (reservations != null)
          'reservations': reservations!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Commitment for a particular resource (a Commitment is composed of one or
/// more of these).
class ResourceCommitment {
  /// Name of the accelerator type resource.
  ///
  /// Applicable only when the type is ACCELERATOR.
  core.String? acceleratorType;

  /// The amount of the resource purchased (in a type-dependent unit, such as
  /// bytes).
  ///
  /// For vCPUs, this can just be an integer. For memory, this must be provided
  /// in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of memory per
  /// every vCPU.
  core.String? amount;

  /// Type of resource for which this commitment applies.
  ///
  /// Possible values are VCPU and MEMORY
  /// Possible string values are:
  /// - "ACCELERATOR"
  /// - "LOCAL_SSD"
  /// - "MEMORY"
  /// - "UNSPECIFIED"
  /// - "VCPU"
  core.String? type;

  ResourceCommitment();

  ResourceCommitment.fromJson(core.Map _json) {
    if (_json.containsKey('acceleratorType')) {
      acceleratorType = _json['acceleratorType'] as core.String;
    }
    if (_json.containsKey('amount')) {
      amount = _json['amount'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
        if (amount != null) 'amount': amount!,
        if (type != null) 'type': type!,
      };
}

class ResourceGroupReference {
  /// A URI referencing one of the instance groups or network endpoint groups
  /// listed in the backend service.
  core.String? group;

  ResourceGroupReference();

  ResourceGroupReference.fromJson(core.Map _json) {
    if (_json.containsKey('group')) {
      group = _json['group'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (group != null) 'group': group!,
      };
}

class ResourcePoliciesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePoliciesScopedListWarningData();

  ResourcePoliciesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of resourcePolicies when the
/// list is empty.
class ResourcePoliciesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePoliciesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePoliciesScopedListWarning();

  ResourcePoliciesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePoliciesScopedListWarningData>((value) =>
              ResourcePoliciesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ResourcePoliciesScopedList {
  /// A list of resourcePolicies contained in this scope.
  core.List<ResourcePolicy>? resourcePolicies;

  /// Informational warning which replaces the list of resourcePolicies when the
  /// list is empty.
  ResourcePoliciesScopedListWarning? warning;

  ResourcePoliciesScopedList();

  ResourcePoliciesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('resourcePolicies')) {
      resourcePolicies = (_json['resourcePolicies'] as core.List)
          .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePoliciesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourcePolicies != null)
          'resourcePolicies':
              resourcePolicies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Resource Policy resource.
///
/// You can use resource policies to schedule actions for some Compute Engine
/// resources. For example, you can use them to schedule persistent disk
/// snapshots.
///
/// (== resource_for {$api_version}.resourcePolicies ==)
class ResourcePolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;
  core.String? description;

  /// Resource policy for instances for placement configuration.
  ResourcePolicyGroupPlacementPolicy? groupPlacementPolicy;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Resource policy for scheduling instance operations.
  ResourcePolicyInstanceSchedulePolicy? instanceSchedulePolicy;

  /// Type of the resource.
  ///
  /// Always compute#resource_policies for resource policies.
  ///
  /// Output only.
  core.String? kind;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The resource name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;
  core.String? region;

  /// The system status of the resource policy.
  ///
  /// Output only.
  ResourcePolicyResourceStatus? resourceStatus;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Resource policy for persistent disks for creating snapshots.
  ResourcePolicySnapshotSchedulePolicy? snapshotSchedulePolicy;

  /// The status of resource policy creation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "EXPIRED"
  /// - "INVALID"
  /// - "READY"
  core.String? status;

  ResourcePolicy();

  ResourcePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('groupPlacementPolicy')) {
      groupPlacementPolicy = ResourcePolicyGroupPlacementPolicy.fromJson(
          _json['groupPlacementPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instanceSchedulePolicy')) {
      instanceSchedulePolicy = ResourcePolicyInstanceSchedulePolicy.fromJson(
          _json['instanceSchedulePolicy']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('resourceStatus')) {
      resourceStatus = ResourcePolicyResourceStatus.fromJson(
          _json['resourceStatus'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('snapshotSchedulePolicy')) {
      snapshotSchedulePolicy = ResourcePolicySnapshotSchedulePolicy.fromJson(
          _json['snapshotSchedulePolicy']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (groupPlacementPolicy != null)
          'groupPlacementPolicy': groupPlacementPolicy!.toJson(),
        if (id != null) 'id': id!,
        if (instanceSchedulePolicy != null)
          'instanceSchedulePolicy': instanceSchedulePolicy!.toJson(),
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (resourceStatus != null) 'resourceStatus': resourceStatus!.toJson(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (snapshotSchedulePolicy != null)
          'snapshotSchedulePolicy': snapshotSchedulePolicy!.toJson(),
        if (status != null) 'status': status!,
      };
}

class ResourcePolicyAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePolicyAggregatedListWarningData();

  ResourcePolicyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ResourcePolicyAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePolicyAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePolicyAggregatedListWarning();

  ResourcePolicyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePolicyAggregatedListWarningData>((value) =>
              ResourcePolicyAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of resourcePolicies.
class ResourcePolicyAggregatedList {
  core.String? etag;

  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ResourcePolicy resources.
  core.Map<core.String, ResourcePoliciesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  ResourcePolicyAggregatedListWarning? warning;

  ResourcePolicyAggregatedList();

  ResourcePolicyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          ResourcePoliciesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePolicyAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Time window specified for daily operations.
class ResourcePolicyDailyCycle {
  /// Defines a schedule with units measured in months.
  ///
  /// The value determines how many months pass between the start of each cycle.
  core.int? daysInCycle;

  /// A predetermined duration for the window, automatically chosen to be the
  /// smallest possible in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Start time of the window.
  ///
  /// This must be in UTC format that resolves to one of 00:00, 04:00, 08:00,
  /// 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
  core.String? startTime;

  ResourcePolicyDailyCycle();

  ResourcePolicyDailyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('daysInCycle')) {
      daysInCycle = _json['daysInCycle'] as core.int;
    }
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (daysInCycle != null) 'daysInCycle': daysInCycle!,
        if (duration != null) 'duration': duration!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// A GroupPlacementPolicy specifies resource placement configuration.
///
/// It specifies the failure bucket separation as well as network locality
class ResourcePolicyGroupPlacementPolicy {
  /// The number of availability domains instances will be spread across.
  ///
  /// If two instances are in different availability domain, they will not be
  /// put in the same low latency network
  core.int? availabilityDomainCount;

  /// Specifies network collocation
  /// Possible string values are:
  /// - "COLLOCATED"
  /// - "UNSPECIFIED_COLLOCATION"
  core.String? collocation;

  /// Number of vms in this placement group
  core.int? vmCount;

  ResourcePolicyGroupPlacementPolicy();

  ResourcePolicyGroupPlacementPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('availabilityDomainCount')) {
      availabilityDomainCount = _json['availabilityDomainCount'] as core.int;
    }
    if (_json.containsKey('collocation')) {
      collocation = _json['collocation'] as core.String;
    }
    if (_json.containsKey('vmCount')) {
      vmCount = _json['vmCount'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (availabilityDomainCount != null)
          'availabilityDomainCount': availabilityDomainCount!,
        if (collocation != null) 'collocation': collocation!,
        if (vmCount != null) 'vmCount': vmCount!,
      };
}

/// Time window specified for hourly operations.
class ResourcePolicyHourlyCycle {
  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Defines a schedule with units measured in hours.
  ///
  /// The value determines how many hours pass between the start of each cycle.
  core.int? hoursInCycle;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  ResourcePolicyHourlyCycle();

  ResourcePolicyHourlyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('hoursInCycle')) {
      hoursInCycle = _json['hoursInCycle'] as core.int;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (duration != null) 'duration': duration!,
        if (hoursInCycle != null) 'hoursInCycle': hoursInCycle!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// An InstanceSchedulePolicy specifies when and how frequent certain operations
/// are performed on the instance.
class ResourcePolicyInstanceSchedulePolicy {
  /// The expiration time of the schedule.
  ///
  /// The timestamp is an RFC3339 string.
  core.String? expirationTime;

  /// The start time of the schedule.
  ///
  /// The timestamp is an RFC3339 string.
  core.String? startTime;

  /// Specifies the time zone to be used in interpreting Schedule.schedule.
  ///
  /// The value of this field must be a time zone name from the tz database:
  /// http://en.wikipedia.org/wiki/Tz_database.
  core.String? timeZone;

  /// Specifies the schedule for starting instances.
  ResourcePolicyInstanceSchedulePolicySchedule? vmStartSchedule;

  /// Specifies the schedule for stopping instances.
  ResourcePolicyInstanceSchedulePolicySchedule? vmStopSchedule;

  ResourcePolicyInstanceSchedulePolicy();

  ResourcePolicyInstanceSchedulePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('expirationTime')) {
      expirationTime = _json['expirationTime'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
    if (_json.containsKey('timeZone')) {
      timeZone = _json['timeZone'] as core.String;
    }
    if (_json.containsKey('vmStartSchedule')) {
      vmStartSchedule = ResourcePolicyInstanceSchedulePolicySchedule.fromJson(
          _json['vmStartSchedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('vmStopSchedule')) {
      vmStopSchedule = ResourcePolicyInstanceSchedulePolicySchedule.fromJson(
          _json['vmStopSchedule'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (expirationTime != null) 'expirationTime': expirationTime!,
        if (startTime != null) 'startTime': startTime!,
        if (timeZone != null) 'timeZone': timeZone!,
        if (vmStartSchedule != null)
          'vmStartSchedule': vmStartSchedule!.toJson(),
        if (vmStopSchedule != null) 'vmStopSchedule': vmStopSchedule!.toJson(),
      };
}

/// Schedule for an instance operation.
class ResourcePolicyInstanceSchedulePolicySchedule {
  /// Specifies the frequency for the operation, using the unix-cron format.
  core.String? schedule;

  ResourcePolicyInstanceSchedulePolicySchedule();

  ResourcePolicyInstanceSchedulePolicySchedule.fromJson(core.Map _json) {
    if (_json.containsKey('schedule')) {
      schedule = _json['schedule'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (schedule != null) 'schedule': schedule!,
      };
}

class ResourcePolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ResourcePolicyListWarningData();

  ResourcePolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ResourcePolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ResourcePolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ResourcePolicyListWarning();

  ResourcePolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ResourcePolicyListWarningData>((value) =>
              ResourcePolicyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class ResourcePolicyList {
  core.String? etag;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of ResourcePolicy resources.
  ///
  /// Output only.
  core.List<ResourcePolicy>? items;

  /// Type of resource.Always compute#resourcePoliciesList for listsof
  /// resourcePolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ResourcePolicyListWarning? warning;

  ResourcePolicyList();

  ResourcePolicyList.fromJson(core.Map _json) {
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<ResourcePolicy>((value) => ResourcePolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ResourcePolicyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (etag != null) 'etag': etag!,
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Contains output only fields.
///
/// Use this sub-message for all output fields set on ResourcePolicy. The
/// internal structure of this "status" field should mimic the structure of
/// ResourcePolicy proto specification.
class ResourcePolicyResourceStatus {
  /// Specifies a set of output values reffering to the instance_schedule_policy
  /// system status.
  ///
  /// This field should have the same name as corresponding policy field.
  ///
  /// Output only.
  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus?
      instanceSchedulePolicy;

  ResourcePolicyResourceStatus();

  ResourcePolicyResourceStatus.fromJson(core.Map _json) {
    if (_json.containsKey('instanceSchedulePolicy')) {
      instanceSchedulePolicy =
          ResourcePolicyResourceStatusInstanceSchedulePolicyStatus.fromJson(
              _json['instanceSchedulePolicy']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceSchedulePolicy != null)
          'instanceSchedulePolicy': instanceSchedulePolicy!.toJson(),
      };
}

class ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
  /// The last time the schedule successfully ran.
  ///
  /// The timestamp is an RFC3339 string.
  ///
  /// Output only.
  core.String? lastRunStartTime;

  /// The next time the schedule is planned to run.
  ///
  /// The actual time might be slightly different. The timestamp is an RFC3339
  /// string.
  ///
  /// Output only.
  core.String? nextRunStartTime;

  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus();

  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus.fromJson(
      core.Map _json) {
    if (_json.containsKey('lastRunStartTime')) {
      lastRunStartTime = _json['lastRunStartTime'] as core.String;
    }
    if (_json.containsKey('nextRunStartTime')) {
      nextRunStartTime = _json['nextRunStartTime'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (lastRunStartTime != null) 'lastRunStartTime': lastRunStartTime!,
        if (nextRunStartTime != null) 'nextRunStartTime': nextRunStartTime!,
      };
}

/// A snapshot schedule policy specifies when and how frequently snapshots are
/// to be created for the target disk.
///
/// Also specifies how many and how long these scheduled snapshots should be
/// retained.
class ResourcePolicySnapshotSchedulePolicy {
  /// Retention policy applied to snapshots created by this resource policy.
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy? retentionPolicy;

  /// A Vm Maintenance Policy specifies what kind of infrastructure maintenance
  /// we are allowed to perform on this VM and when.
  ///
  /// Schedule that is applied to disks covered by this policy.
  ResourcePolicySnapshotSchedulePolicySchedule? schedule;

  /// Properties with which snapshots are created such as labels, encryption
  /// keys.
  ResourcePolicySnapshotSchedulePolicySnapshotProperties? snapshotProperties;

  ResourcePolicySnapshotSchedulePolicy();

  ResourcePolicySnapshotSchedulePolicy.fromJson(core.Map _json) {
    if (_json.containsKey('retentionPolicy')) {
      retentionPolicy =
          ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(
              _json['retentionPolicy'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('schedule')) {
      schedule = ResourcePolicySnapshotSchedulePolicySchedule.fromJson(
          _json['schedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('snapshotProperties')) {
      snapshotProperties =
          ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
              _json['snapshotProperties']
                  as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (retentionPolicy != null)
          'retentionPolicy': retentionPolicy!.toJson(),
        if (schedule != null) 'schedule': schedule!.toJson(),
        if (snapshotProperties != null)
          'snapshotProperties': snapshotProperties!.toJson(),
      };
}

/// Policy for retention of scheduled snapshots.
class ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
  /// Maximum age of the snapshot that is allowed to be kept.
  core.int? maxRetentionDays;

  /// Specifies the behavior to apply to scheduled snapshots when the source
  /// disk is deleted.
  /// Possible string values are:
  /// - "APPLY_RETENTION_POLICY"
  /// - "KEEP_AUTO_SNAPSHOTS"
  /// - "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
  core.String? onSourceDiskDelete;

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy();

  ResourcePolicySnapshotSchedulePolicyRetentionPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('maxRetentionDays')) {
      maxRetentionDays = _json['maxRetentionDays'] as core.int;
    }
    if (_json.containsKey('onSourceDiskDelete')) {
      onSourceDiskDelete = _json['onSourceDiskDelete'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxRetentionDays != null) 'maxRetentionDays': maxRetentionDays!,
        if (onSourceDiskDelete != null)
          'onSourceDiskDelete': onSourceDiskDelete!,
      };
}

/// A schedule for disks where the schedueled operations are performed.
class ResourcePolicySnapshotSchedulePolicySchedule {
  ResourcePolicyDailyCycle? dailySchedule;
  ResourcePolicyHourlyCycle? hourlySchedule;
  ResourcePolicyWeeklyCycle? weeklySchedule;

  ResourcePolicySnapshotSchedulePolicySchedule();

  ResourcePolicySnapshotSchedulePolicySchedule.fromJson(core.Map _json) {
    if (_json.containsKey('dailySchedule')) {
      dailySchedule = ResourcePolicyDailyCycle.fromJson(
          _json['dailySchedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('hourlySchedule')) {
      hourlySchedule = ResourcePolicyHourlyCycle.fromJson(
          _json['hourlySchedule'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weeklySchedule')) {
      weeklySchedule = ResourcePolicyWeeklyCycle.fromJson(
          _json['weeklySchedule'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (dailySchedule != null) 'dailySchedule': dailySchedule!.toJson(),
        if (hourlySchedule != null) 'hourlySchedule': hourlySchedule!.toJson(),
        if (weeklySchedule != null) 'weeklySchedule': weeklySchedule!.toJson(),
      };
}

/// Specified snapshot properties for scheduled snapshots created by this
/// policy.
class ResourcePolicySnapshotSchedulePolicySnapshotProperties {
  /// Chain name that the snapshot is created in.
  core.String? chainName;

  /// Indication to perform a 'guest aware' snapshot.
  core.bool? guestFlush;

  /// Labels to apply to scheduled snapshots.
  ///
  /// These can be later modified by the setLabels method. Label values may be
  /// empty.
  core.Map<core.String, core.String>? labels;

  /// Cloud Storage bucket storage location of the auto snapshot (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  ResourcePolicySnapshotSchedulePolicySnapshotProperties();

  ResourcePolicySnapshotSchedulePolicySnapshotProperties.fromJson(
      core.Map _json) {
    if (_json.containsKey('chainName')) {
      chainName = _json['chainName'] as core.String;
    }
    if (_json.containsKey('guestFlush')) {
      guestFlush = _json['guestFlush'] as core.bool;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (chainName != null) 'chainName': chainName!,
        if (guestFlush != null) 'guestFlush': guestFlush!,
        if (labels != null) 'labels': labels!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

/// Time window specified for weekly operations.
class ResourcePolicyWeeklyCycle {
  /// Up to 7 intervals/windows, one for each day of the week.
  core.List<ResourcePolicyWeeklyCycleDayOfWeek>? dayOfWeeks;

  ResourcePolicyWeeklyCycle();

  ResourcePolicyWeeklyCycle.fromJson(core.Map _json) {
    if (_json.containsKey('dayOfWeeks')) {
      dayOfWeeks = (_json['dayOfWeeks'] as core.List)
          .map<ResourcePolicyWeeklyCycleDayOfWeek>((value) =>
              ResourcePolicyWeeklyCycleDayOfWeek.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (dayOfWeeks != null)
          'dayOfWeeks': dayOfWeeks!.map((value) => value.toJson()).toList(),
      };
}

class ResourcePolicyWeeklyCycleDayOfWeek {
  /// Defines a schedule that runs on specific days of the week.
  ///
  /// Specify one or more days. The following options are available: MONDAY,
  /// TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
  /// Possible string values are:
  /// - "FRIDAY"
  /// - "INVALID"
  /// - "MONDAY"
  /// - "SATURDAY"
  /// - "SUNDAY"
  /// - "THURSDAY"
  /// - "TUESDAY"
  /// - "WEDNESDAY"
  core.String? day;

  /// Duration of the time window, automatically chosen to be smallest possible
  /// in the given scenario.
  ///
  /// Output only.
  core.String? duration;

  /// Time within the window to start the operations.
  ///
  /// It must be in format "HH:MM", where HH : \[00-23\] and MM : \[00-00\] GMT.
  core.String? startTime;

  ResourcePolicyWeeklyCycleDayOfWeek();

  ResourcePolicyWeeklyCycleDayOfWeek.fromJson(core.Map _json) {
    if (_json.containsKey('day')) {
      day = _json['day'] as core.String;
    }
    if (_json.containsKey('duration')) {
      duration = _json['duration'] as core.String;
    }
    if (_json.containsKey('startTime')) {
      startTime = _json['startTime'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (day != null) 'day': day!,
        if (duration != null) 'duration': duration!,
        if (startTime != null) 'startTime': startTime!,
      };
}

class RouteWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouteWarningsData();

  RouteWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class RouteWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouteWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouteWarnings();

  RouteWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouteWarningsData>((value) => RouteWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents a Route resource.
///
/// A route defines a path from VM instances in the VPC network to a specific
/// destination.
///
/// This destination can be inside or outside the VPC network. For more
/// information, read the Routes overview. (== resource_for
/// {$api_version}.routes ==)
class Route {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this field when you create the resource.
  core.String? description;

  /// The destination range of outgoing packets that this route applies to.
  ///
  /// Both IPv4 and IPv6 are supported.
  core.String? destRange;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of this resource.
  ///
  /// Always compute#routes for Route resources.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase
  /// letter, and all following characters (except for the last character) must
  /// be a dash, lowercase letter, or digit. The last character must be a
  /// lowercase letter or digit.
  core.String? name;

  /// Fully-qualified URL of the network that this route applies to.
  core.String? network;

  /// The URL to a gateway that should handle matching packets.
  ///
  /// You can only specify the internet gateway using a full or partial valid
  /// URL: projects/project/global/gateways/default-internet-gateway
  core.String? nextHopGateway;

  /// The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
  /// should handle matching packets or the IP address of the forwarding Rule.
  ///
  /// For example, the following are all valid URLs:
  /// - 10.128.0.56
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/regions/region/forwardingRules/forwardingRule
  /// - regions/region/forwardingRules/forwardingRule
  core.String? nextHopIlb;

  /// The URL to an instance that should handle matching packets.
  ///
  /// You can specify this as a full or partial URL. For example:
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
  core.String? nextHopInstance;

  /// The network IP address of an instance that should handle matching packets.
  ///
  /// Only IPv4 is supported.
  core.String? nextHopIp;

  /// The URL of the local network if it should handle matching packets.
  core.String? nextHopNetwork;

  /// The network peering name that should handle matching packets, which should
  /// conform to RFC1035.
  ///
  /// Output only.
  core.String? nextHopPeering;

  /// The URL to a VpnTunnel that should handle matching packets.
  core.String? nextHopVpnTunnel;

  /// The priority of this route.
  ///
  /// Priority is used to break ties in cases where there is more than one
  /// matching route of equal prefix length. In cases where multiple routes have
  /// equal prefix length, the one with the lowest-numbered priority value wins.
  /// The default value is `1000`. The priority value must be from `0` to
  /// `65535`, inclusive.
  core.int? priority;

  /// Server-defined fully-qualified URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A list of instance tags to which this route applies.
  core.List<core.String>? tags;

  /// If potential misconfigurations are detected for this route, this field
  /// will be populated with warning messages.
  ///
  /// Output only.
  core.List<RouteWarnings>? warnings;

  Route();

  Route.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('destRange')) {
      destRange = _json['destRange'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('nextHopGateway')) {
      nextHopGateway = _json['nextHopGateway'] as core.String;
    }
    if (_json.containsKey('nextHopIlb')) {
      nextHopIlb = _json['nextHopIlb'] as core.String;
    }
    if (_json.containsKey('nextHopInstance')) {
      nextHopInstance = _json['nextHopInstance'] as core.String;
    }
    if (_json.containsKey('nextHopIp')) {
      nextHopIp = _json['nextHopIp'] as core.String;
    }
    if (_json.containsKey('nextHopNetwork')) {
      nextHopNetwork = _json['nextHopNetwork'] as core.String;
    }
    if (_json.containsKey('nextHopPeering')) {
      nextHopPeering = _json['nextHopPeering'] as core.String;
    }
    if (_json.containsKey('nextHopVpnTunnel')) {
      nextHopVpnTunnel = _json['nextHopVpnTunnel'] as core.String;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('tags')) {
      tags = (_json['tags'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<RouteWarnings>((value) => RouteWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (destRange != null) 'destRange': destRange!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (nextHopGateway != null) 'nextHopGateway': nextHopGateway!,
        if (nextHopIlb != null) 'nextHopIlb': nextHopIlb!,
        if (nextHopInstance != null) 'nextHopInstance': nextHopInstance!,
        if (nextHopIp != null) 'nextHopIp': nextHopIp!,
        if (nextHopNetwork != null) 'nextHopNetwork': nextHopNetwork!,
        if (nextHopPeering != null) 'nextHopPeering': nextHopPeering!,
        if (nextHopVpnTunnel != null) 'nextHopVpnTunnel': nextHopVpnTunnel!,
        if (priority != null) 'priority': priority!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (tags != null) 'tags': tags!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
      };
}

class RouteListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouteListWarningData();

  RouteListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouteListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouteListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouteListWarning();

  RouteListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouteListWarningData>((value) => RouteListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Route resources.
class RouteList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Route resources.
  core.List<Route>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RouteListWarning? warning;

  RouteList();

  RouteList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RouteListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Cloud Router resource.
///
/// For more information about Cloud Router, read the Cloud Router overview.
class Router {
  /// BGP information specific to this router.
  RouterBgp? bgp;

  /// BGP information that must be configured into the routing stack to
  /// establish BGP peering.
  ///
  /// This information must specify the peer ASN and either the interface name,
  /// IP address, or peer IP address. Please refer to RFC4273.
  core.List<RouterBgpPeer>? bgpPeers;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Router interfaces.
  ///
  /// Each interface requires either one linked resource, (for example,
  /// linkedVpnTunnel), or IP address and IP address range (for example,
  /// ipRange), or both.
  core.List<RouterInterface>? interfaces;

  /// Type of resource.
  ///
  /// Always compute#router for routers.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A list of NAT services created in this router.
  core.List<RouterNat>? nats;

  /// URI of the network to which this router belongs.
  core.String? network;

  /// URI of the region where the router resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  Router();

  Router.fromJson(core.Map _json) {
    if (_json.containsKey('bgp')) {
      bgp = RouterBgp.fromJson(
          _json['bgp'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('bgpPeers')) {
      bgpPeers = (_json['bgpPeers'] as core.List)
          .map<RouterBgpPeer>((value) => RouterBgpPeer.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('interfaces')) {
      interfaces = (_json['interfaces'] as core.List)
          .map<RouterInterface>((value) => RouterInterface.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('nats')) {
      nats = (_json['nats'] as core.List)
          .map<RouterNat>((value) =>
              RouterNat.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bgp != null) 'bgp': bgp!.toJson(),
        if (bgpPeers != null)
          'bgpPeers': bgpPeers!.map((value) => value.toJson()).toList(),
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (interfaces != null)
          'interfaces': interfaces!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (nats != null) 'nats': nats!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

/// Description-tagged IP ranges for the router to advertise.
class RouterAdvertisedIpRange {
  /// User-specified description for the IP range.
  core.String? description;

  /// The IP range to advertise.
  ///
  /// The value must be a CIDR-formatted string.
  core.String? range;

  RouterAdvertisedIpRange();

  RouterAdvertisedIpRange.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('range')) {
      range = _json['range'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (range != null) 'range': range!,
      };
}

class RouterAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouterAggregatedListWarningData();

  RouterAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouterAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouterAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouterAggregatedListWarning();

  RouterAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouterAggregatedListWarningData>((value) =>
              RouterAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of routers.
class RouterAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Router resources.
  core.Map<core.String, RoutersScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  RouterAggregatedListWarning? warning;

  RouterAggregatedList();

  RouterAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          RoutersScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = RouterAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class RouterBgp {
  /// User-specified flag to indicate which mode to use for advertisement.
  ///
  /// The options are DEFAULT or CUSTOM.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String? advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These groups will be advertised in
  /// addition to any specified prefixes. Leave this field blank to advertise no
  /// custom groups.
  core.List<core.String>? advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and is
  /// advertised to all peers of the router. These IP ranges will be advertised
  /// in addition to any specified groups. Leave this field blank to advertise
  /// no custom IP ranges.
  core.List<RouterAdvertisedIpRange>? advertisedIpRanges;

  /// Local BGP Autonomous System Number (ASN).
  ///
  /// Must be an RFC6996 private ASN, either 16-bit or 32-bit. The value will be
  /// fixed for this router resource. All VPN tunnels that link to this router
  /// will have the same local ASN.
  core.int? asn;

  RouterBgp();

  RouterBgp.fromJson(core.Map _json) {
    if (_json.containsKey('advertiseMode')) {
      advertiseMode = _json['advertiseMode'] as core.String;
    }
    if (_json.containsKey('advertisedGroups')) {
      advertisedGroups = (_json['advertisedGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('advertisedIpRanges')) {
      advertisedIpRanges = (_json['advertisedIpRanges'] as core.List)
          .map<RouterAdvertisedIpRange>((value) =>
              RouterAdvertisedIpRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('asn')) {
      asn = _json['asn'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertiseMode != null) 'advertiseMode': advertiseMode!,
        if (advertisedGroups != null) 'advertisedGroups': advertisedGroups!,
        if (advertisedIpRanges != null)
          'advertisedIpRanges':
              advertisedIpRanges!.map((value) => value.toJson()).toList(),
        if (asn != null) 'asn': asn!,
      };
}

class RouterBgpPeer {
  /// User-specified flag to indicate which mode to use for advertisement.
  /// Possible string values are:
  /// - "CUSTOM"
  /// - "DEFAULT"
  core.String? advertiseMode;

  /// User-specified list of prefix groups to advertise in custom mode, which
  /// can take one of the following options:
  /// - ALL_SUBNETS: Advertises all available subnets, including peer VPC
  /// subnets.
  ///
  ///
  /// - ALL_VPC_SUBNETS: Advertises the router's own VPC subnets.
  /// - ALL_PEER_VPC_SUBNETS: Advertises peer subnets of the router's VPC
  /// network. Note that this field can only be populated if advertise_mode is
  /// CUSTOM and overrides the list defined for the router (in the "bgp"
  /// message). These groups are advertised in addition to any specified
  /// prefixes. Leave this field blank to advertise no custom groups.
  core.List<core.String>? advertisedGroups;

  /// User-specified list of individual IP ranges to advertise in custom mode.
  ///
  /// This field can only be populated if advertise_mode is CUSTOM and overrides
  /// the list defined for the router (in the "bgp" message). These IP ranges
  /// are advertised in addition to any specified groups. Leave this field blank
  /// to advertise no custom IP ranges.
  core.List<RouterAdvertisedIpRange>? advertisedIpRanges;

  /// The priority of routes advertised to this BGP peer.
  ///
  /// Where there is more than one matching route of maximum length, the routes
  /// with the lowest priority value win.
  core.int? advertisedRoutePriority;

  /// Name of the interface the BGP peer is associated with.
  core.String? interfaceName;

  /// IP address of the interface inside Google Cloud Platform.
  ///
  /// Only IPv4 is supported.
  core.String? ipAddress;

  /// The resource that configures and manages this BGP peer.
  ///
  ///
  /// - MANAGED_BY_USER is the default value and can be managed by you or other
  /// users
  /// - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by
  /// Cloud Interconnect, specifically by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// BGP peer when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String? managementType;

  /// Name of this BGP peer.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Peer BGP Autonomous System Number (ASN).
  ///
  /// Each BGP interface may use a different value.
  core.int? peerAsn;

  /// IP address of the BGP interface outside Google Cloud Platform.
  ///
  /// Only IPv4 is supported.
  core.String? peerIpAddress;

  RouterBgpPeer();

  RouterBgpPeer.fromJson(core.Map _json) {
    if (_json.containsKey('advertiseMode')) {
      advertiseMode = _json['advertiseMode'] as core.String;
    }
    if (_json.containsKey('advertisedGroups')) {
      advertisedGroups = (_json['advertisedGroups'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('advertisedIpRanges')) {
      advertisedIpRanges = (_json['advertisedIpRanges'] as core.List)
          .map<RouterAdvertisedIpRange>((value) =>
              RouterAdvertisedIpRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('advertisedRoutePriority')) {
      advertisedRoutePriority = _json['advertisedRoutePriority'] as core.int;
    }
    if (_json.containsKey('interfaceName')) {
      interfaceName = _json['interfaceName'] as core.String;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('managementType')) {
      managementType = _json['managementType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerAsn')) {
      peerAsn = _json['peerAsn'] as core.int;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertiseMode != null) 'advertiseMode': advertiseMode!,
        if (advertisedGroups != null) 'advertisedGroups': advertisedGroups!,
        if (advertisedIpRanges != null)
          'advertisedIpRanges':
              advertisedIpRanges!.map((value) => value.toJson()).toList(),
        if (advertisedRoutePriority != null)
          'advertisedRoutePriority': advertisedRoutePriority!,
        if (interfaceName != null) 'interfaceName': interfaceName!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (managementType != null) 'managementType': managementType!,
        if (name != null) 'name': name!,
        if (peerAsn != null) 'peerAsn': peerAsn!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
      };
}

class RouterInterface {
  /// IP address and range of the interface.
  ///
  /// The IP range must be in the RFC3927 link-local IP address space. The value
  /// must be a CIDR-formatted string, for example: 169.254.0.1/30. NOTE: Do not
  /// truncate the address as it represents the IP address of the interface.
  core.String? ipRange;

  /// URI of the linked Interconnect attachment.
  ///
  /// It must be in the same region as the router. Each interface can have one
  /// linked resource, which can be a VPN tunnel, an Interconnect attachment, or
  /// a virtual machine instance.
  core.String? linkedInterconnectAttachment;

  /// URI of the linked VPN tunnel, which must be in the same region as the
  /// router.
  ///
  /// Each interface can have one linked resource, which can be a VPN tunnel, an
  /// Interconnect attachment, or a virtual machine instance.
  core.String? linkedVpnTunnel;

  /// The resource that configures and manages this interface.
  ///
  ///
  /// - MANAGED_BY_USER is the default value and can be managed directly by
  /// users.
  /// - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by
  /// Cloud Interconnect, specifically, by an InterconnectAttachment of type
  /// PARTNER. Google automatically creates, updates, and deletes this type of
  /// interface when the PARTNER InterconnectAttachment is created, updated, or
  /// deleted.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MANAGED_BY_ATTACHMENT"
  /// - "MANAGED_BY_USER"
  core.String? managementType;

  /// Name of this interface entry.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  RouterInterface();

  RouterInterface.fromJson(core.Map _json) {
    if (_json.containsKey('ipRange')) {
      ipRange = _json['ipRange'] as core.String;
    }
    if (_json.containsKey('linkedInterconnectAttachment')) {
      linkedInterconnectAttachment =
          _json['linkedInterconnectAttachment'] as core.String;
    }
    if (_json.containsKey('linkedVpnTunnel')) {
      linkedVpnTunnel = _json['linkedVpnTunnel'] as core.String;
    }
    if (_json.containsKey('managementType')) {
      managementType = _json['managementType'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipRange != null) 'ipRange': ipRange!,
        if (linkedInterconnectAttachment != null)
          'linkedInterconnectAttachment': linkedInterconnectAttachment!,
        if (linkedVpnTunnel != null) 'linkedVpnTunnel': linkedVpnTunnel!,
        if (managementType != null) 'managementType': managementType!,
        if (name != null) 'name': name!,
      };
}

class RouterListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RouterListWarningData();

  RouterListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class RouterListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RouterListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RouterListWarning();

  RouterListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RouterListWarningData>((value) => RouterListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Router resources.
class RouterList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Router resources.
  core.List<Router>? items;

  /// Type of resource.
  ///
  /// Always compute#router for routers.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  RouterListWarning? warning;

  RouterList();

  RouterList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Router>((value) =>
              Router.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = RouterListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Nat resource.
///
/// It enables the VMs within the specified subnetworks to access Internet
/// without external IP addresses. It specifies a list of subnetworks (and the
/// ranges within) that want to use NAT. Customers can also provide the external
/// IPs that would be used for NAT. GCP would auto-allocate ephemeral IPs if no
/// external IPs are provided.
class RouterNat {
  /// A list of URLs of the IP resources to be drained.
  ///
  /// These IPs must be valid static external IPs that have been assigned to the
  /// NAT. These IPs should be used for updating/patching a NAT only.
  core.List<core.String>? drainNatIps;
  core.bool? enableEndpointIndependentMapping;

  /// Timeout (in seconds) for ICMP connections.
  ///
  /// Defaults to 30s if not set.
  core.int? icmpIdleTimeoutSec;

  /// Configure logging on this NAT.
  RouterNatLogConfig? logConfig;

  /// Minimum number of ports allocated to a VM from this NAT config.
  ///
  /// If not set, a default number of ports is allocated to a VM. This is
  /// rounded up to the nearest power of 2. For example, if the value of this
  /// field is 50, at least 64 ports are allocated to a VM.
  core.int? minPortsPerVm;

  /// Unique name of this Nat service.
  ///
  /// The name must be 1-63 characters long and comply with RFC1035.
  core.String? name;

  /// Specify the NatIpAllocateOption, which can take one of the following
  /// values:
  /// - MANUAL_ONLY: Uses only Nat IP addresses provided by customers.
  ///
  /// When there are not enough specified Nat IPs, the Nat service fails for new
  /// VMs.
  /// - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers
  /// can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be
  /// empty.
  /// Possible string values are:
  /// - "AUTO_ONLY"
  /// - "MANUAL_ONLY"
  core.String? natIpAllocateOption;

  /// A list of URLs of the IP resources used for this Nat service.
  ///
  /// These IP addresses must be valid static external IP addresses assigned to
  /// the project.
  core.List<core.String>? natIps;

  /// Specify the Nat option, which can take one of the following values:
  /// - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork
  /// are allowed to Nat.
  ///
  ///
  /// - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in
  /// every Subnetwork are allowed to Nat.
  /// - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified
  /// in the field subnetwork below) The default is
  /// SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field
  /// contains ALL_SUBNETWORKS_ALL_IP_RANGES or
  /// ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other
  /// Router.Nat section in any Router for this network in this region.
  /// Possible string values are:
  /// - "ALL_SUBNETWORKS_ALL_IP_RANGES"
  /// - "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES"
  /// - "LIST_OF_SUBNETWORKS"
  core.String? sourceSubnetworkIpRangesToNat;

  /// A list of Subnetwork resources whose traffic should be translated by NAT
  /// Gateway.
  ///
  /// It is used only when LIST_OF_SUBNETWORKS is selected for the
  /// SubnetworkIpRangeToNatOption above.
  core.List<RouterNatSubnetworkToNat>? subnetworks;

  /// Timeout (in seconds) for TCP established connections.
  ///
  /// Defaults to 1200s if not set.
  core.int? tcpEstablishedIdleTimeoutSec;

  /// Timeout (in seconds) for TCP transitory connections.
  ///
  /// Defaults to 30s if not set.
  core.int? tcpTransitoryIdleTimeoutSec;

  /// Timeout (in seconds) for UDP connections.
  ///
  /// Defaults to 30s if not set.
  core.int? udpIdleTimeoutSec;

  RouterNat();

  RouterNat.fromJson(core.Map _json) {
    if (_json.containsKey('drainNatIps')) {
      drainNatIps = (_json['drainNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('enableEndpointIndependentMapping')) {
      enableEndpointIndependentMapping =
          _json['enableEndpointIndependentMapping'] as core.bool;
    }
    if (_json.containsKey('icmpIdleTimeoutSec')) {
      icmpIdleTimeoutSec = _json['icmpIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = RouterNatLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('minPortsPerVm')) {
      minPortsPerVm = _json['minPortsPerVm'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natIpAllocateOption')) {
      natIpAllocateOption = _json['natIpAllocateOption'] as core.String;
    }
    if (_json.containsKey('natIps')) {
      natIps = (_json['natIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceSubnetworkIpRangesToNat')) {
      sourceSubnetworkIpRangesToNat =
          _json['sourceSubnetworkIpRangesToNat'] as core.String;
    }
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<RouterNatSubnetworkToNat>((value) =>
              RouterNatSubnetworkToNat.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('tcpEstablishedIdleTimeoutSec')) {
      tcpEstablishedIdleTimeoutSec =
          _json['tcpEstablishedIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('tcpTransitoryIdleTimeoutSec')) {
      tcpTransitoryIdleTimeoutSec =
          _json['tcpTransitoryIdleTimeoutSec'] as core.int;
    }
    if (_json.containsKey('udpIdleTimeoutSec')) {
      udpIdleTimeoutSec = _json['udpIdleTimeoutSec'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainNatIps != null) 'drainNatIps': drainNatIps!,
        if (enableEndpointIndependentMapping != null)
          'enableEndpointIndependentMapping': enableEndpointIndependentMapping!,
        if (icmpIdleTimeoutSec != null)
          'icmpIdleTimeoutSec': icmpIdleTimeoutSec!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (minPortsPerVm != null) 'minPortsPerVm': minPortsPerVm!,
        if (name != null) 'name': name!,
        if (natIpAllocateOption != null)
          'natIpAllocateOption': natIpAllocateOption!,
        if (natIps != null) 'natIps': natIps!,
        if (sourceSubnetworkIpRangesToNat != null)
          'sourceSubnetworkIpRangesToNat': sourceSubnetworkIpRangesToNat!,
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (tcpEstablishedIdleTimeoutSec != null)
          'tcpEstablishedIdleTimeoutSec': tcpEstablishedIdleTimeoutSec!,
        if (tcpTransitoryIdleTimeoutSec != null)
          'tcpTransitoryIdleTimeoutSec': tcpTransitoryIdleTimeoutSec!,
        if (udpIdleTimeoutSec != null) 'udpIdleTimeoutSec': udpIdleTimeoutSec!,
      };
}

/// Configuration of logging on a NAT.
class RouterNatLogConfig {
  /// Indicates whether or not to export logs.
  ///
  /// This is false by default.
  core.bool? enable;

  /// Specify the desired filtering of logs on this NAT.
  ///
  /// If unspecified, logs are exported for all connections handled by this NAT.
  /// This option can take one of the following values:
  /// - ERRORS_ONLY: Export logs only for connection failures.
  /// - TRANSLATIONS_ONLY: Export logs only for successful connections.
  /// - ALL: Export logs for all connections, successful and unsuccessful.
  /// Possible string values are:
  /// - "ALL"
  /// - "ERRORS_ONLY"
  /// - "TRANSLATIONS_ONLY"
  core.String? filter;

  RouterNatLogConfig();

  RouterNatLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('filter')) {
      filter = _json['filter'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enable != null) 'enable': enable!,
        if (filter != null) 'filter': filter!,
      };
}

/// Defines the IP ranges that want to use NAT for a subnetwork.
class RouterNatSubnetworkToNat {
  /// URL for the subnetwork resource that will use NAT.
  core.String? name;

  /// A list of the secondary ranges of the Subnetwork that are allowed to use
  /// NAT.
  ///
  /// This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of the
  /// values in source_ip_ranges_to_nat.
  core.List<core.String>? secondaryIpRangeNames;

  /// Specify the options for NAT ranges in the Subnetwork.
  ///
  /// All options of a single value are valid except
  /// NAT_IP_RANGE_OPTION_UNSPECIFIED. The only valid option with multiple
  /// values is: \["PRIMARY_IP_RANGE", "LIST_OF_SECONDARY_IP_RANGES"\] Default:
  /// \[ALL_IP_RANGES\]
  core.List<core.String>? sourceIpRangesToNat;

  RouterNatSubnetworkToNat();

  RouterNatSubnetworkToNat.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('secondaryIpRangeNames')) {
      secondaryIpRangeNames = (_json['secondaryIpRangeNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sourceIpRangesToNat')) {
      sourceIpRangesToNat = (_json['sourceIpRangesToNat'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (secondaryIpRangeNames != null)
          'secondaryIpRangeNames': secondaryIpRangeNames!,
        if (sourceIpRangesToNat != null)
          'sourceIpRangesToNat': sourceIpRangesToNat!,
      };
}

class RouterStatus {
  /// Best routes for this router's network.
  core.List<Route>? bestRoutes;

  /// Best routes learned by this router.
  core.List<Route>? bestRoutesForRouter;
  core.List<RouterStatusBgpPeerStatus>? bgpPeerStatus;
  core.List<RouterStatusNatStatus>? natStatus;

  /// URI of the network to which this router belongs.
  core.String? network;

  RouterStatus();

  RouterStatus.fromJson(core.Map _json) {
    if (_json.containsKey('bestRoutes')) {
      bestRoutes = (_json['bestRoutes'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bestRoutesForRouter')) {
      bestRoutesForRouter = (_json['bestRoutesForRouter'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('bgpPeerStatus')) {
      bgpPeerStatus = (_json['bgpPeerStatus'] as core.List)
          .map<RouterStatusBgpPeerStatus>((value) =>
              RouterStatusBgpPeerStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('natStatus')) {
      natStatus = (_json['natStatus'] as core.List)
          .map<RouterStatusNatStatus>((value) => RouterStatusNatStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bestRoutes != null)
          'bestRoutes': bestRoutes!.map((value) => value.toJson()).toList(),
        if (bestRoutesForRouter != null)
          'bestRoutesForRouter':
              bestRoutesForRouter!.map((value) => value.toJson()).toList(),
        if (bgpPeerStatus != null)
          'bgpPeerStatus':
              bgpPeerStatus!.map((value) => value.toJson()).toList(),
        if (natStatus != null)
          'natStatus': natStatus!.map((value) => value.toJson()).toList(),
        if (network != null) 'network': network!,
      };
}

class RouterStatusBgpPeerStatus {
  /// Routes that were advertised to the remote BGP peer
  core.List<Route>? advertisedRoutes;

  /// IP address of the local BGP interface.
  core.String? ipAddress;

  /// URL of the VPN tunnel that this BGP peer controls.
  core.String? linkedVpnTunnel;

  /// Name of this BGP peer.
  ///
  /// Unique within the Routers resource.
  core.String? name;

  /// Number of routes learned from the remote BGP Peer.
  core.int? numLearnedRoutes;

  /// IP address of the remote BGP interface.
  core.String? peerIpAddress;

  /// BGP state as specified in RFC1771.
  core.String? state;

  /// Status of the BGP peer: {UP, DOWN}
  /// Possible string values are:
  /// - "DOWN"
  /// - "UNKNOWN"
  /// - "UP"
  core.String? status;

  /// Time this session has been up.
  ///
  /// Format: 14 years, 51 weeks, 6 days, 23 hours, 59 minutes, 59 seconds
  core.String? uptime;

  /// Time this session has been up, in seconds.
  ///
  /// Format: 145
  core.String? uptimeSeconds;

  RouterStatusBgpPeerStatus();

  RouterStatusBgpPeerStatus.fromJson(core.Map _json) {
    if (_json.containsKey('advertisedRoutes')) {
      advertisedRoutes = (_json['advertisedRoutes'] as core.List)
          .map<Route>((value) =>
              Route.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
    if (_json.containsKey('linkedVpnTunnel')) {
      linkedVpnTunnel = _json['linkedVpnTunnel'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('numLearnedRoutes')) {
      numLearnedRoutes = _json['numLearnedRoutes'] as core.int;
    }
    if (_json.containsKey('peerIpAddress')) {
      peerIpAddress = _json['peerIpAddress'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('uptime')) {
      uptime = _json['uptime'] as core.String;
    }
    if (_json.containsKey('uptimeSeconds')) {
      uptimeSeconds = _json['uptimeSeconds'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (advertisedRoutes != null)
          'advertisedRoutes':
              advertisedRoutes!.map((value) => value.toJson()).toList(),
        if (ipAddress != null) 'ipAddress': ipAddress!,
        if (linkedVpnTunnel != null) 'linkedVpnTunnel': linkedVpnTunnel!,
        if (name != null) 'name': name!,
        if (numLearnedRoutes != null) 'numLearnedRoutes': numLearnedRoutes!,
        if (peerIpAddress != null) 'peerIpAddress': peerIpAddress!,
        if (state != null) 'state': state!,
        if (status != null) 'status': status!,
        if (uptime != null) 'uptime': uptime!,
        if (uptimeSeconds != null) 'uptimeSeconds': uptimeSeconds!,
      };
}

/// Status of a NAT contained in this router.
class RouterStatusNatStatus {
  /// A list of IPs auto-allocated for NAT.
  ///
  /// Example: \["1.1.1.1", "129.2.16.89"\]
  core.List<core.String>? autoAllocatedNatIps;

  /// A list of IPs auto-allocated for NAT that are in drain mode.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? drainAutoAllocatedNatIps;

  /// A list of IPs user-allocated for NAT that are in drain mode.
  ///
  /// Example: \["1.1.1.1", "179.12.26.133"\].
  core.List<core.String>? drainUserAllocatedNatIps;

  /// The number of extra IPs to allocate.
  ///
  /// This will be greater than 0 only if user-specified IPs are NOT enough to
  /// allow all configured VMs to use NAT. This value is meaningful only when
  /// auto-allocation of NAT IPs is *not* used.
  core.int? minExtraNatIpsNeeded;

  /// Unique name of this NAT.
  core.String? name;

  /// Number of VM endpoints (i.e., Nics) that can use NAT.
  core.int? numVmEndpointsWithNatMappings;

  /// A list of fully qualified URLs of reserved IP address resources.
  core.List<core.String>? userAllocatedNatIpResources;

  /// A list of IPs user-allocated for NAT.
  ///
  /// They will be raw IP strings like "179.12.26.133".
  core.List<core.String>? userAllocatedNatIps;

  RouterStatusNatStatus();

  RouterStatusNatStatus.fromJson(core.Map _json) {
    if (_json.containsKey('autoAllocatedNatIps')) {
      autoAllocatedNatIps = (_json['autoAllocatedNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('drainAutoAllocatedNatIps')) {
      drainAutoAllocatedNatIps =
          (_json['drainAutoAllocatedNatIps'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('drainUserAllocatedNatIps')) {
      drainUserAllocatedNatIps =
          (_json['drainUserAllocatedNatIps'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('minExtraNatIpsNeeded')) {
      minExtraNatIpsNeeded = _json['minExtraNatIpsNeeded'] as core.int;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('numVmEndpointsWithNatMappings')) {
      numVmEndpointsWithNatMappings =
          _json['numVmEndpointsWithNatMappings'] as core.int;
    }
    if (_json.containsKey('userAllocatedNatIpResources')) {
      userAllocatedNatIpResources =
          (_json['userAllocatedNatIpResources'] as core.List)
              .map<core.String>((value) => value as core.String)
              .toList();
    }
    if (_json.containsKey('userAllocatedNatIps')) {
      userAllocatedNatIps = (_json['userAllocatedNatIps'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoAllocatedNatIps != null)
          'autoAllocatedNatIps': autoAllocatedNatIps!,
        if (drainAutoAllocatedNatIps != null)
          'drainAutoAllocatedNatIps': drainAutoAllocatedNatIps!,
        if (drainUserAllocatedNatIps != null)
          'drainUserAllocatedNatIps': drainUserAllocatedNatIps!,
        if (minExtraNatIpsNeeded != null)
          'minExtraNatIpsNeeded': minExtraNatIpsNeeded!,
        if (name != null) 'name': name!,
        if (numVmEndpointsWithNatMappings != null)
          'numVmEndpointsWithNatMappings': numVmEndpointsWithNatMappings!,
        if (userAllocatedNatIpResources != null)
          'userAllocatedNatIpResources': userAllocatedNatIpResources!,
        if (userAllocatedNatIps != null)
          'userAllocatedNatIps': userAllocatedNatIps!,
      };
}

class RouterStatusResponse {
  /// Type of resource.
  core.String? kind;
  RouterStatus? result;

  RouterStatusResponse();

  RouterStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('result')) {
      result = RouterStatus.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (kind != null) 'kind': kind!,
        if (result != null) 'result': result!.toJson(),
      };
}

class RoutersPreviewResponse {
  /// Preview of given router.
  Router? resource;

  RoutersPreviewResponse();

  RoutersPreviewResponse.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = Router.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

class RoutersScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  RoutersScopedListWarningData();

  RoutersScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of routers when the list is
/// empty.
class RoutersScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<RoutersScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  RoutersScopedListWarning();

  RoutersScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<RoutersScopedListWarningData>((value) =>
              RoutersScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class RoutersScopedList {
  /// A list of routers contained in this scope.
  core.List<Router>? routers;

  /// Informational warning which replaces the list of routers when the list is
  /// empty.
  RoutersScopedListWarning? warning;

  RoutersScopedList();

  RoutersScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('routers')) {
      routers = (_json['routers'] as core.List)
          .map<Router>((value) =>
              Router.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = RoutersScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (routers != null)
          'routers': routers!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A rule to be applied in a Policy.
class Rule {
  /// Required
  /// Possible string values are:
  /// - "ALLOW"
  /// - "ALLOW_WITH_LOG"
  /// - "DENY"
  /// - "DENY_WITH_LOG"
  /// - "LOG"
  /// - "NO_ACTION"
  core.String? action;

  /// Additional restrictions that must be met.
  ///
  /// All conditions must pass for the rule to match.
  core.List<Condition>? conditions;

  /// Human-readable description of the rule.
  core.String? description;

  /// If one or more 'in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in at least one of these entries.
  core.List<core.String>? ins;

  /// The config returned to callers of tech.iam.IAM.CheckPolicy for any entries
  /// that match the LOG action.
  core.List<LogConfig>? logConfigs;

  /// If one or more 'not_in' clauses are specified, the rule matches if the
  /// PRINCIPAL/AUTHORITY_SELECTOR is in none of the entries.
  core.List<core.String>? notIns;

  /// A permission is a string of form '..' (e.g., 'storage.buckets.list').
  ///
  /// A value of '*' matches all permissions, and a verb part of '*' (e.g.,
  /// 'storage.buckets.*') matches all verbs.
  core.List<core.String>? permissions;

  Rule();

  Rule.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('conditions')) {
      conditions = (_json['conditions'] as core.List)
          .map<Condition>((value) =>
              Condition.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('ins')) {
      ins = (_json['ins'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('logConfigs')) {
      logConfigs = (_json['logConfigs'] as core.List)
          .map<LogConfig>((value) =>
              LogConfig.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('notIns')) {
      notIns = (_json['notIns'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (conditions != null)
          'conditions': conditions!.map((value) => value.toJson()).toList(),
        if (description != null) 'description': description!,
        if (ins != null) 'ins': ins!,
        if (logConfigs != null)
          'logConfigs': logConfigs!.map((value) => value.toJson()).toList(),
        if (notIns != null) 'notIns': notIns!,
        if (permissions != null) 'permissions': permissions!,
      };
}

class SSLHealthCheck {
  /// The TCP port number for the health check request.
  ///
  /// The default value is 443. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, SSL health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The application data to send once the SSL connection has been established
  /// (default value is empty).
  ///
  /// If both request and response are empty, the connection establishment alone
  /// will indicate health. The request data can only be ASCII.
  core.String? request;

  /// The bytes to match against the beginning of the response data.
  ///
  /// If left empty (the default value), any response will indicate health. The
  /// response data can only be ASCII.
  core.String? response;

  SSLHealthCheck();

  SSLHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('request')) {
      request = _json['request'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (request != null) 'request': request!,
        if (response != null) 'response': response!,
      };
}

/// Sets the scheduling options for an Instance.
///
/// NextID: 17
class Scheduling {
  /// Specifies whether the instance should be automatically restarted if it is
  /// terminated by Compute Engine (not terminated by a user).
  ///
  /// You can only set the automatic restart option for standard instances.
  /// Preemptible instances cannot be automatically restarted.
  ///
  /// By default, this is set to true so an instance is automatically restarted
  /// if it is terminated by Compute Engine.
  core.bool? automaticRestart;

  /// An opaque location hint used to place the instance close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// The minimum number of virtual CPUs this instance will consume when running
  /// on a sole-tenant node.
  core.int? minNodeCpus;

  /// A set of node affinity and anti-affinity configurations.
  ///
  /// Refer to Configuring node affinity for more information. Overrides
  /// reservationAffinity.
  core.List<SchedulingNodeAffinity>? nodeAffinities;

  /// Defines the maintenance behavior for this instance.
  ///
  /// For standard instances, the default behavior is MIGRATE. For preemptible
  /// instances, the default and only possible behavior is TERMINATE. For more
  /// information, see Setting Instance Scheduling Options.
  /// Possible string values are:
  /// - "MIGRATE"
  /// - "TERMINATE"
  core.String? onHostMaintenance;

  /// Defines whether the instance is preemptible.
  ///
  /// This can only be set during instance creation or while the instance is
  /// stopped and therefore, in a `TERMINATED` state. See Instance Life Cycle
  /// for more information on the possible instance states.
  core.bool? preemptible;

  Scheduling();

  Scheduling.fromJson(core.Map _json) {
    if (_json.containsKey('automaticRestart')) {
      automaticRestart = _json['automaticRestart'] as core.bool;
    }
    if (_json.containsKey('locationHint')) {
      locationHint = _json['locationHint'] as core.String;
    }
    if (_json.containsKey('minNodeCpus')) {
      minNodeCpus = _json['minNodeCpus'] as core.int;
    }
    if (_json.containsKey('nodeAffinities')) {
      nodeAffinities = (_json['nodeAffinities'] as core.List)
          .map<SchedulingNodeAffinity>((value) =>
              SchedulingNodeAffinity.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('onHostMaintenance')) {
      onHostMaintenance = _json['onHostMaintenance'] as core.String;
    }
    if (_json.containsKey('preemptible')) {
      preemptible = _json['preemptible'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticRestart != null) 'automaticRestart': automaticRestart!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (minNodeCpus != null) 'minNodeCpus': minNodeCpus!,
        if (nodeAffinities != null)
          'nodeAffinities':
              nodeAffinities!.map((value) => value.toJson()).toList(),
        if (onHostMaintenance != null) 'onHostMaintenance': onHostMaintenance!,
        if (preemptible != null) 'preemptible': preemptible!,
      };
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled.
class SchedulingNodeAffinity {
  /// Corresponds to the label key of Node resource.
  core.String? key;

  /// Defines the operation of node selection.
  ///
  /// Valid operators are IN for affinity and NOT_IN for anti-affinity.
  /// Possible string values are:
  /// - "IN"
  /// - "NOT_IN"
  /// - "OPERATOR_UNSPECIFIED"
  core.String? operator;

  /// Corresponds to the label values of Node resource.
  core.List<core.String>? values;

  SchedulingNodeAffinity();

  SchedulingNodeAffinity.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('operator')) {
      operator = _json['operator'] as core.String;
    }
    if (_json.containsKey('values')) {
      values = (_json['values'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (operator != null) 'operator': operator!,
        if (values != null) 'values': values!,
      };
}

/// An instance's screenshot.
class Screenshot {
  /// The Base64-encoded screenshot data.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#screenshot for the screenshots.
  ///
  /// Output only.
  core.String? kind;

  Screenshot();

  Screenshot.fromJson(core.Map _json) {
    if (_json.containsKey('contents')) {
      contents = _json['contents'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (kind != null) 'kind': kind!,
      };
}

class SecurityPoliciesListPreconfiguredExpressionSetsResponse {
  SecurityPoliciesWafConfig? preconfiguredExpressionSets;

  SecurityPoliciesListPreconfiguredExpressionSetsResponse();

  SecurityPoliciesListPreconfiguredExpressionSetsResponse.fromJson(
      core.Map _json) {
    if (_json.containsKey('preconfiguredExpressionSets')) {
      preconfiguredExpressionSets = SecurityPoliciesWafConfig.fromJson(
          _json['preconfiguredExpressionSets']
              as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (preconfiguredExpressionSets != null)
          'preconfiguredExpressionSets': preconfiguredExpressionSets!.toJson(),
      };
}

class SecurityPoliciesWafConfig {
  PreconfiguredWafSet? wafRules;

  SecurityPoliciesWafConfig();

  SecurityPoliciesWafConfig.fromJson(core.Map _json) {
    if (_json.containsKey('wafRules')) {
      wafRules = PreconfiguredWafSet.fromJson(
          _json['wafRules'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (wafRules != null) 'wafRules': wafRules!.toJson(),
      };
}

/// Represents a Google Cloud Armor security policy resource.
///
/// Only external backend services that use load balancers can reference a
/// security policy.
///
/// For more information, see Google Cloud Armor security policy overview. (==
/// resource_for {$api_version}.securityPolicies ==)
class SecurityPolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Specifies a fingerprint for this resource, which is essentially a hash of
  /// the metadata's contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update metadata. You must always provide an
  /// up-to-date fingerprint hash in order to update or change metadata,
  /// otherwise the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make get() request to the security policy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#securityPolicyfor security policies
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A list of rules that belong to this policy.
  ///
  /// There must always be a default rule (rule with priority 2147483647 and
  /// match "*"). If no rules are provided when creating a security policy, a
  /// default rule with action "allow" will be added.
  core.List<SecurityPolicyRule>? rules;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  SecurityPolicy();

  SecurityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('rules')) {
      rules = (_json['rules'] as core.List)
          .map<SecurityPolicyRule>((value) => SecurityPolicyRule.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (rules != null)
          'rules': rules!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
      };
}

class SecurityPolicyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SecurityPolicyListWarningData();

  SecurityPolicyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SecurityPolicyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SecurityPolicyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SecurityPolicyListWarning();

  SecurityPolicyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SecurityPolicyListWarningData>((value) =>
              SecurityPolicyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SecurityPolicyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SecurityPolicy resources.
  core.List<SecurityPolicy>? items;

  /// Type of resource.
  ///
  /// Always compute#securityPolicyList for listsof securityPolicies
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Informational warning message.
  ///
  /// Output only.
  SecurityPolicyListWarning? warning;

  SecurityPolicyList();

  SecurityPolicyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SecurityPolicy>((value) => SecurityPolicy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SecurityPolicyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SecurityPolicyReference {
  core.String? securityPolicy;

  SecurityPolicyReference();

  SecurityPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey('securityPolicy')) {
      securityPolicy = _json['securityPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (securityPolicy != null) 'securityPolicy': securityPolicy!,
      };
}

/// Represents a rule that describes one or more match conditions along with the
/// action to be taken when traffic matches this condition (allow or deny).
class SecurityPolicyRule {
  /// The Action to preform when the client connection triggers the rule.
  ///
  /// Can currently be either "allow" or "deny()" where valid values for status
  /// are 403, 404, and 502.
  core.String? action;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Type of the resource.
  ///
  /// Always compute#securityPolicyRule for security policy rules
  ///
  /// Output only.
  core.String? kind;

  /// A match condition that incoming traffic is evaluated against.
  ///
  /// If it evaluates to true, the corresponding 'action' is enforced.
  SecurityPolicyRuleMatcher? match;

  /// If set to true, the specified action is not enforced.
  core.bool? preview;

  /// An integer indicating the priority of a rule in the list.
  ///
  /// The priority must be a positive value between 0 and 2147483647. Rules are
  /// evaluated from highest to lowest priority where 0 is the highest priority
  /// and 2147483647 is the lowest priority.
  core.int? priority;

  SecurityPolicyRule();

  SecurityPolicyRule.fromJson(core.Map _json) {
    if (_json.containsKey('action')) {
      action = _json['action'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('match')) {
      match = SecurityPolicyRuleMatcher.fromJson(
          _json['match'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('preview')) {
      preview = _json['preview'] as core.bool;
    }
    if (_json.containsKey('priority')) {
      priority = _json['priority'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (action != null) 'action': action!,
        if (description != null) 'description': description!,
        if (kind != null) 'kind': kind!,
        if (match != null) 'match': match!.toJson(),
        if (preview != null) 'preview': preview!,
        if (priority != null) 'priority': priority!,
      };
}

/// Represents a match condition that incoming traffic is evaluated against.
///
/// Exactly one field must be specified.
class SecurityPolicyRuleMatcher {
  /// The configuration options available when specifying versioned_expr.
  ///
  /// This field must be specified if versioned_expr is specified and cannot be
  /// specified if versioned_expr is not specified.
  SecurityPolicyRuleMatcherConfig? config;

  /// User defined CEVAL expression.
  ///
  /// A CEVAL expression is used to specify match criteria such as origin.ip,
  /// source.region_code and contents in the request header.
  Expr? expr;

  /// Preconfigured versioned expression.
  ///
  /// If this field is specified, config must also be specified. Available
  /// preconfigured expressions along with their requirements are: SRC_IPS_V1 -
  /// must specify the corresponding src_ip_range field in config.
  /// Possible string values are:
  /// - "SRC_IPS_V1"
  core.String? versionedExpr;

  SecurityPolicyRuleMatcher();

  SecurityPolicyRuleMatcher.fromJson(core.Map _json) {
    if (_json.containsKey('config')) {
      config = SecurityPolicyRuleMatcherConfig.fromJson(
          _json['config'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('expr')) {
      expr =
          Expr.fromJson(_json['expr'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('versionedExpr')) {
      versionedExpr = _json['versionedExpr'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (config != null) 'config': config!.toJson(),
        if (expr != null) 'expr': expr!.toJson(),
        if (versionedExpr != null) 'versionedExpr': versionedExpr!,
      };
}

class SecurityPolicyRuleMatcherConfig {
  /// CIDR IP address range.
  ///
  /// Maximum number of src_ip_ranges allowed is 10.
  core.List<core.String>? srcIpRanges;

  SecurityPolicyRuleMatcherConfig();

  SecurityPolicyRuleMatcherConfig.fromJson(core.Map _json) {
    if (_json.containsKey('srcIpRanges')) {
      srcIpRanges = (_json['srcIpRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (srcIpRanges != null) 'srcIpRanges': srcIpRanges!,
      };
}

/// The authentication and authorization settings for a BackendService.
class SecuritySettings {
  /// A URL referring to a networksecurity.ClientTlsPolicy resource that
  /// describes how clients should authenticate with this service's backends.
  /// clientTlsPolicy only applies to a global BackendService with the
  /// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  /// If left blank, communications are not encrypted.
  /// Note: This field currently has no impact.
  ///
  /// Optional.
  core.String? clientTlsPolicy;

  /// A list of Subject Alternative Names (SANs) that the client verifies during
  /// a mutual TLS handshake with an server/endpoint for this BackendService.
  ///
  /// When the server presents its X.509 certificate to the client, the client
  /// inspects the certificate's subjectAltName field. If the field contains one
  /// of the specified values, the communication continues. Otherwise, it fails.
  /// This additional check enables the client to verify that the server is
  /// authorized to run the requested service.
  /// Note that the contents of the server certificate's subjectAltName field
  /// are configured by the Public Key Infrastructure which provisions server
  /// identities.
  /// Only applies to a global BackendService with loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED. Only applies when BackendService has an attached
  /// clientTlsPolicy with clientCertificate (mTLS mode).
  /// Note: This field currently has no impact.
  ///
  /// Optional.
  core.List<core.String>? subjectAltNames;

  SecuritySettings();

  SecuritySettings.fromJson(core.Map _json) {
    if (_json.containsKey('clientTlsPolicy')) {
      clientTlsPolicy = _json['clientTlsPolicy'] as core.String;
    }
    if (_json.containsKey('subjectAltNames')) {
      subjectAltNames = (_json['subjectAltNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientTlsPolicy != null) 'clientTlsPolicy': clientTlsPolicy!,
        if (subjectAltNames != null) 'subjectAltNames': subjectAltNames!,
      };
}

/// An instance's serial console output.
class SerialPortOutput {
  /// The contents of the console output.
  ///
  /// Output only.
  core.String? contents;

  /// Type of the resource.
  ///
  /// Always compute#serialPortOutput for serial port output.
  ///
  /// Output only.
  core.String? kind;

  /// The position of the next byte of content, regardless of whether the
  /// content exists, following the output returned in the `contents` property.
  ///
  /// Use this value in the next request as the start parameter.
  ///
  /// Output only.
  core.String? next;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The starting byte position of the output that was returned.
  ///
  /// This should match the start parameter sent with the request. If the serial
  /// console output exceeds the size of the buffer (1 MB), older output is
  /// overwritten by newer content. The output start value will indicate the
  /// byte position of the output that was returned, which might be different
  /// than the `start` value that was specified in the request.
  core.String? start;

  SerialPortOutput();

  SerialPortOutput.fromJson(core.Map _json) {
    if (_json.containsKey('contents')) {
      contents = _json['contents'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('next')) {
      next = _json['next'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('start')) {
      start = _json['start'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (kind != null) 'kind': kind!,
        if (next != null) 'next': next!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (start != null) 'start': start!,
      };
}

class ServerBinding {
  ///
  /// Possible string values are:
  /// - "RESTART_NODE_ON_ANY_SERVER"
  /// - "RESTART_NODE_ON_MINIMAL_SERVERS"
  /// - "SERVER_BINDING_TYPE_UNSPECIFIED"
  core.String? type;

  ServerBinding();

  ServerBinding.fromJson(core.Map _json) {
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (type != null) 'type': type!,
      };
}

/// A service account.
class ServiceAccount {
  /// Email address of the service account.
  core.String? email;

  /// The list of scopes to be made available for this service account.
  core.List<core.String>? scopes;

  ServiceAccount();

  ServiceAccount.fromJson(core.Map _json) {
    if (_json.containsKey('email')) {
      email = _json['email'] as core.String;
    }
    if (_json.containsKey('scopes')) {
      scopes = (_json['scopes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (email != null) 'email': email!,
        if (scopes != null) 'scopes': scopes!,
      };
}

/// A set of Shielded Instance options.
class ShieldedInstanceConfig {
  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enabled by default.
  core.bool? enableIntegrityMonitoring;

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Disabled by default.
  core.bool? enableSecureBoot;

  /// Defines whether the instance has the vTPM enabled.
  ///
  /// Enabled by default.
  core.bool? enableVtpm;

  ShieldedInstanceConfig();

  ShieldedInstanceConfig.fromJson(core.Map _json) {
    if (_json.containsKey('enableIntegrityMonitoring')) {
      enableIntegrityMonitoring =
          _json['enableIntegrityMonitoring'] as core.bool;
    }
    if (_json.containsKey('enableSecureBoot')) {
      enableSecureBoot = _json['enableSecureBoot'] as core.bool;
    }
    if (_json.containsKey('enableVtpm')) {
      enableVtpm = _json['enableVtpm'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableIntegrityMonitoring != null)
          'enableIntegrityMonitoring': enableIntegrityMonitoring!,
        if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
        if (enableVtpm != null) 'enableVtpm': enableVtpm!,
      };
}

/// A shielded Instance identity entry.
class ShieldedInstanceIdentity {
  /// An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry? encryptionKey;

  /// Type of the resource.
  ///
  /// Always compute#shieldedInstanceIdentity for shielded Instance identity
  /// entry.
  ///
  /// Output only.
  core.String? kind;

  /// An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
  /// Shielded Instance's vTPM.
  ShieldedInstanceIdentityEntry? signingKey;

  ShieldedInstanceIdentity();

  ShieldedInstanceIdentity.fromJson(core.Map _json) {
    if (_json.containsKey('encryptionKey')) {
      encryptionKey = ShieldedInstanceIdentityEntry.fromJson(
          _json['encryptionKey'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('signingKey')) {
      signingKey = ShieldedInstanceIdentityEntry.fromJson(
          _json['signingKey'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (encryptionKey != null) 'encryptionKey': encryptionKey!.toJson(),
        if (kind != null) 'kind': kind!,
        if (signingKey != null) 'signingKey': signingKey!.toJson(),
      };
}

/// A Shielded Instance Identity Entry.
class ShieldedInstanceIdentityEntry {
  /// A PEM-encoded X.509 certificate.
  ///
  /// This field can be empty.
  core.String? ekCert;

  /// A PEM-encoded public key.
  core.String? ekPub;

  ShieldedInstanceIdentityEntry();

  ShieldedInstanceIdentityEntry.fromJson(core.Map _json) {
    if (_json.containsKey('ekCert')) {
      ekCert = _json['ekCert'] as core.String;
    }
    if (_json.containsKey('ekPub')) {
      ekPub = _json['ekPub'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ekCert != null) 'ekCert': ekCert!,
        if (ekPub != null) 'ekPub': ekPub!,
      };
}

/// The policy describes the baseline against which Instance boot integrity is
/// measured.
class ShieldedInstanceIntegrityPolicy {
  /// Updates the integrity policy baseline using the measurements from the VM
  /// instance's most recent boot.
  core.bool? updateAutoLearnPolicy;

  ShieldedInstanceIntegrityPolicy();

  ShieldedInstanceIntegrityPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('updateAutoLearnPolicy')) {
      updateAutoLearnPolicy = _json['updateAutoLearnPolicy'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (updateAutoLearnPolicy != null)
          'updateAutoLearnPolicy': updateAutoLearnPolicy!,
      };
}

/// Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
class SignedUrlKey {
  /// Name of the key.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? keyName;

  /// 128-bit key value used for signing the URL.
  ///
  /// The key value must be a valid RFC 4648 Section 5 base64url encoded string.
  core.String? keyValue;

  SignedUrlKey();

  SignedUrlKey.fromJson(core.Map _json) {
    if (_json.containsKey('keyName')) {
      keyName = _json['keyName'] as core.String;
    }
    if (_json.containsKey('keyValue')) {
      keyValue = _json['keyValue'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (keyName != null) 'keyName': keyName!,
        if (keyValue != null) 'keyValue': keyValue!,
      };
}

/// Represents a Persistent Disk Snapshot resource.
///
/// You can use snapshots to back up data on a regular interval.
///
/// For more information, read Creating persistent disk snapshots. (==
/// resource_for {$api_version}.snapshots ==)
class Snapshot {
  /// Set to true if snapshots are automatically created by applying resource
  /// policy on the target disk.
  ///
  /// Output only.
  core.bool? autoCreated;

  /// Creates the new snapshot in the snapshot chain labeled with the specified
  /// name.
  ///
  /// The chain name must be 1-63 characters long and comply with RFC1035. This
  /// is an uncommon option only for advanced service owners who needs to create
  /// separate snapshot chains, for example, for chargeback tracking. When you
  /// describe your snapshot resource, this field is visible only if it has a
  /// non-empty value.
  core.String? chainName;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Size of the source disk, specified in GB.
  ///
  /// Output only.
  core.String? diskSizeGb;

  /// Number of bytes downloaded to restore a snapshot to a disk.
  ///
  /// Output only.
  core.String? downloadBytes;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#snapshot for Snapshot resources.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this snapshot, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// snapshot.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels to apply to this snapshot.
  ///
  /// These can be later modified by the setLabels method. Label values may be
  /// empty.
  core.Map<core.String, core.String>? labels;

  /// Integer license codes indicating which licenses are attached to this
  /// snapshot.
  ///
  /// Output only.
  core.List<core.String>? licenseCodes;

  /// A list of public visible licenses that apply to this snapshot.
  ///
  /// This can be because the original image had licenses attached (such as a
  /// Windows image).
  ///
  /// Output only.
  core.List<core.String>? licenses;

  /// An opaque location hint used to place the snapshot close to other
  /// resources.
  ///
  /// This field is for use by internal tools that use the public API.
  core.String? locationHint;

  /// Name of the resource; provided by the client when the resource is created.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Encrypts the snapshot using a customer-supplied encryption key.
  ///
  /// After you encrypt a snapshot using a customer-supplied key, you must
  /// provide the same key if you use the snapshot later.
  ///
  /// For example, you must provide the encryption key when you create a disk
  /// from the encrypted snapshot in a future request.
  ///
  /// Customer-supplied encryption keys do not protect access to metadata of the
  /// snapshot.
  ///
  /// If you do not provide an encryption key when creating the snapshot, then
  /// the snapshot will be encrypted using an automatically generated key and
  /// you do not need to provide a key to use the snapshot later.
  CustomerEncryptionKey? snapshotEncryptionKey;

  /// The source disk used to create this snapshot.
  core.String? sourceDisk;

  /// The customer-supplied encryption key of the source disk.
  ///
  /// Required if the source disk is protected by a customer-supplied encryption
  /// key.
  CustomerEncryptionKey? sourceDiskEncryptionKey;

  /// The ID value of the disk used to create this snapshot.
  ///
  /// This value may be used to determine whether the snapshot was taken from
  /// the current or a previous instance of a given disk name.
  ///
  /// Output only.
  core.String? sourceDiskId;

  /// The status of the snapshot.
  ///
  /// This can be CREATING, DELETING, FAILED, READY, or UPLOADING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  /// - "UPLOADING"
  core.String? status;

  /// A size of the storage used by the snapshot.
  ///
  /// As snapshots share storage, this number is expected to change with
  /// snapshot creation/deletion.
  ///
  /// Output only.
  core.String? storageBytes;

  /// An indicator whether storageBytes is in a stable state or it is being
  /// adjusted as a result of shared storage reallocation.
  ///
  /// This status can either be UPDATING, meaning the size of the snapshot is
  /// being updated, or UP_TO_DATE, meaning the size of the snapshot is
  /// up-to-date.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UPDATING"
  /// - "UP_TO_DATE"
  core.String? storageBytesStatus;

  /// Cloud Storage bucket storage location of the snapshot (regional or
  /// multi-regional).
  core.List<core.String>? storageLocations;

  Snapshot();

  Snapshot.fromJson(core.Map _json) {
    if (_json.containsKey('autoCreated')) {
      autoCreated = _json['autoCreated'] as core.bool;
    }
    if (_json.containsKey('chainName')) {
      chainName = _json['chainName'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('diskSizeGb')) {
      diskSizeGb = _json['diskSizeGb'] as core.String;
    }
    if (_json.containsKey('downloadBytes')) {
      downloadBytes = _json['downloadBytes'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('licenseCodes')) {
      licenseCodes = (_json['licenseCodes'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('licenses')) {
      licenses = (_json['licenses'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('locationHint')) {
      locationHint = _json['locationHint'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('satisfiesPzs')) {
      satisfiesPzs = _json['satisfiesPzs'] as core.bool;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('snapshotEncryptionKey')) {
      snapshotEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['snapshotEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDisk')) {
      sourceDisk = _json['sourceDisk'] as core.String;
    }
    if (_json.containsKey('sourceDiskEncryptionKey')) {
      sourceDiskEncryptionKey = CustomerEncryptionKey.fromJson(
          _json['sourceDiskEncryptionKey']
              as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('sourceDiskId')) {
      sourceDiskId = _json['sourceDiskId'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('storageBytes')) {
      storageBytes = _json['storageBytes'] as core.String;
    }
    if (_json.containsKey('storageBytesStatus')) {
      storageBytesStatus = _json['storageBytesStatus'] as core.String;
    }
    if (_json.containsKey('storageLocations')) {
      storageLocations = (_json['storageLocations'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoCreated != null) 'autoCreated': autoCreated!,
        if (chainName != null) 'chainName': chainName!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (downloadBytes != null) 'downloadBytes': downloadBytes!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (licenseCodes != null) 'licenseCodes': licenseCodes!,
        if (licenses != null) 'licenses': licenses!,
        if (locationHint != null) 'locationHint': locationHint!,
        if (name != null) 'name': name!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (snapshotEncryptionKey != null)
          'snapshotEncryptionKey': snapshotEncryptionKey!.toJson(),
        if (sourceDisk != null) 'sourceDisk': sourceDisk!,
        if (sourceDiskEncryptionKey != null)
          'sourceDiskEncryptionKey': sourceDiskEncryptionKey!.toJson(),
        if (sourceDiskId != null) 'sourceDiskId': sourceDiskId!,
        if (status != null) 'status': status!,
        if (storageBytes != null) 'storageBytes': storageBytes!,
        if (storageBytesStatus != null)
          'storageBytesStatus': storageBytesStatus!,
        if (storageLocations != null) 'storageLocations': storageLocations!,
      };
}

class SnapshotListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SnapshotListWarningData();

  SnapshotListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SnapshotListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SnapshotListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SnapshotListWarning();

  SnapshotListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SnapshotListWarningData>((value) =>
              SnapshotListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Snapshot resources.
class SnapshotList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Snapshot resources.
  core.List<Snapshot>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SnapshotListWarning? warning;

  SnapshotList();

  SnapshotList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Snapshot>((value) =>
              Snapshot.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SnapshotListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// A specification of the parameters to use when creating the instance template
/// from a source instance.
class SourceInstanceParams {
  /// Attached disks configuration.
  ///
  /// If not provided, defaults are applied: For boot disk and any other R/W
  /// disks, new custom images will be created from each disk. For read-only
  /// disks, they will be attached in read-only mode. Local SSD disks will be
  /// created as blank volumes.
  core.List<DiskInstantiationConfig>? diskConfigs;

  SourceInstanceParams();

  SourceInstanceParams.fromJson(core.Map _json) {
    if (_json.containsKey('diskConfigs')) {
      diskConfigs = (_json['diskConfigs'] as core.List)
          .map<DiskInstantiationConfig>((value) =>
              DiskInstantiationConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskConfigs != null)
          'diskConfigs': diskConfigs!.map((value) => value.toJson()).toList(),
      };
}

/// Represents an SSL Certificate resource.
///
/// Google Compute Engine has two SSL Certificate resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/sslCertificates) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionSslCertificates)
///
///
///
/// The sslCertificates are used by:
/// - external HTTPS load balancers
/// - SSL proxy load balancers
///
/// The regionSslCertificates are used by internal HTTPS load balancers.
///
/// Optionally, certificate file contents that you upload can contain a set of
/// up to five PEM-encoded certificates.
///
/// The API call creates an object (sslCertificate) that holds this data. You
/// can use SSL keys and certificates to secure connections to a load balancer.
/// For more information, read Creating and using SSL certificates, SSL
/// certificates quotas and limits, and Troubleshooting SSL certificates. (==
/// resource_for {$api_version}.sslCertificates ==) (== resource_for
/// {$api_version}.regionSslCertificates ==)
class SslCertificate {
  /// A value read into memory from a certificate file.
  ///
  /// The certificate file must be in PEM format. The certificate chain must be
  /// no greater than 5 certs long. The chain must include at least one
  /// intermediate cert.
  core.String? certificate;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Expire time of the certificate.
  ///
  /// RFC3339
  ///
  /// Output only.
  core.String? expireTime;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#sslCertificate for SSL certificates.
  ///
  /// Output only.
  core.String? kind;

  /// Configuration and status of a managed SSL certificate.
  SslCertificateManagedSslCertificate? managed;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// A value read into memory from a write-only private key file.
  ///
  /// The private key file must be in PEM format. For security, only insert
  /// requests include this field.
  core.String? privateKey;

  /// URL of the region where the regional SSL Certificate resides.
  ///
  /// This field is not applicable to global SSL Certificate.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Configuration and status of a self-managed SSL certificate.
  SslCertificateSelfManagedSslCertificate? selfManaged;

  /// Domains associated with the certificate via Subject Alternative Name.
  ///
  /// Output only.
  core.List<core.String>? subjectAlternativeNames;

  /// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or
  /// "MANAGED".
  ///
  /// If not specified, the certificate is self-managed and the fields
  /// certificate and private_key are used.
  /// Possible string values are:
  /// - "MANAGED"
  /// - "SELF_MANAGED"
  /// - "TYPE_UNSPECIFIED"
  core.String? type;

  SslCertificate();

  SslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('certificate')) {
      certificate = _json['certificate'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expireTime')) {
      expireTime = _json['expireTime'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('managed')) {
      managed = SslCertificateManagedSslCertificate.fromJson(
          _json['managed'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('privateKey')) {
      privateKey = _json['privateKey'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('selfManaged')) {
      selfManaged = SslCertificateSelfManagedSslCertificate.fromJson(
          _json['selfManaged'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('subjectAlternativeNames')) {
      subjectAlternativeNames = (_json['subjectAlternativeNames'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (certificate != null) 'certificate': certificate!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (expireTime != null) 'expireTime': expireTime!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (managed != null) 'managed': managed!.toJson(),
        if (name != null) 'name': name!,
        if (privateKey != null) 'privateKey': privateKey!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfManaged != null) 'selfManaged': selfManaged!.toJson(),
        if (subjectAlternativeNames != null)
          'subjectAlternativeNames': subjectAlternativeNames!,
        if (type != null) 'type': type!,
      };
}

class SslCertificateAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificateAggregatedListWarningData();

  SslCertificateAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslCertificateAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificateAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificateAggregatedListWarning();

  SslCertificateAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificateAggregatedListWarningData>((value) =>
              SslCertificateAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslCertificateAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslCertificatesScopedList resources.
  core.Map<core.String, SslCertificatesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#sslCertificateAggregatedList for lists of SSL Certificates.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  SslCertificateAggregatedListWarning? warning;

  SslCertificateAggregatedList();

  SslCertificateAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          SslCertificatesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificateAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslCertificateListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificateListWarningData();

  SslCertificateListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslCertificateListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificateListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificateListWarning();

  SslCertificateListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificateListWarningData>((value) =>
              SslCertificateListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of SslCertificate resources.
class SslCertificateList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslCertificate resources.
  core.List<SslCertificate>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SslCertificateListWarning? warning;

  SslCertificateList();

  SslCertificateList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SslCertificate>((value) => SslCertificate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificateListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Configuration and status of a managed SSL certificate.
class SslCertificateManagedSslCertificate {
  /// Detailed statuses of the domains specified for managed certificate
  /// resource.
  ///
  /// Output only.
  core.Map<core.String, core.String>? domainStatus;

  /// The domains for which a managed SSL certificate will be generated.
  ///
  /// Each Google-managed SSL certificate supports up to the \[maximum number of
  /// domains per Google-managed SSL
  /// certificate\](/load-balancing/docs/quotas#ssl_certificates).
  core.List<core.String>? domains;

  /// Status of the managed certificate resource.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
  /// - "PROVISIONING"
  /// - "PROVISIONING_FAILED"
  /// - "PROVISIONING_FAILED_PERMANENTLY"
  /// - "RENEWAL_FAILED"
  core.String? status;

  SslCertificateManagedSslCertificate();

  SslCertificateManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('domainStatus')) {
      domainStatus =
          (_json['domainStatus'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('domains')) {
      domains = (_json['domains'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (domainStatus != null) 'domainStatus': domainStatus!,
        if (domains != null) 'domains': domains!,
        if (status != null) 'status': status!,
      };
}

/// Configuration and status of a self-managed SSL certificate.
class SslCertificateSelfManagedSslCertificate {
  /// A local certificate file.
  ///
  /// The certificate must be in PEM format. The certificate chain must be no
  /// greater than 5 certs long. The chain must include at least one
  /// intermediate cert.
  core.String? certificate;

  /// A write-only private key in PEM format.
  ///
  /// Only insert requests will include this field.
  core.String? privateKey;

  SslCertificateSelfManagedSslCertificate();

  SslCertificateSelfManagedSslCertificate.fromJson(core.Map _json) {
    if (_json.containsKey('certificate')) {
      certificate = _json['certificate'] as core.String;
    }
    if (_json.containsKey('privateKey')) {
      privateKey = _json['privateKey'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (certificate != null) 'certificate': certificate!,
        if (privateKey != null) 'privateKey': privateKey!,
      };
}

class SslCertificatesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslCertificatesScopedListWarningData();

  SslCertificatesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class SslCertificatesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslCertificatesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslCertificatesScopedListWarning();

  SslCertificatesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslCertificatesScopedListWarningData>((value) =>
              SslCertificatesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslCertificatesScopedList {
  /// List of SslCertificates contained in this scope.
  core.List<SslCertificate>? sslCertificates;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  SslCertificatesScopedListWarning? warning;

  SslCertificatesScopedList();

  SslCertificatesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<SslCertificate>((value) => SslCertificate.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SslCertificatesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null)
          'sslCertificates':
              sslCertificates!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslPoliciesListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslPoliciesListWarningData();

  SslPoliciesListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SslPoliciesListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslPoliciesListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslPoliciesListWarning();

  SslPoliciesListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslPoliciesListWarningData>((value) =>
              SslPoliciesListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SslPoliciesList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SslPolicy resources.
  core.List<SslPolicy>? items;

  /// Type of the resource.
  ///
  /// Always compute#sslPoliciesList for lists of sslPolicies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SslPoliciesListWarning? warning;

  SslPoliciesList();

  SslPoliciesList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<SslPolicy>((value) =>
              SslPolicy.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SslPoliciesListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SslPoliciesListAvailableFeaturesResponse {
  core.List<core.String>? features;

  SslPoliciesListAvailableFeaturesResponse();

  SslPoliciesListAvailableFeaturesResponse.fromJson(core.Map _json) {
    if (_json.containsKey('features')) {
      features = (_json['features'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
      };
}

class SslPolicyWarningsData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SslPolicyWarningsData();

  SslPolicyWarningsData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

class SslPolicyWarnings {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SslPolicyWarningsData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SslPolicyWarnings();

  SslPolicyWarnings.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SslPolicyWarningsData>((value) => SslPolicyWarningsData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Represents an SSL Policy resource.
///
/// Use SSL policies to control the SSL features, such as versions and cipher
/// suites, offered by an HTTPS or SSL Proxy load balancer.
///
/// For more information, read SSL Policy Concepts. (== resource_for
/// {$api_version}.sslPolicies ==)
class SslPolicy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// A list of features enabled when the selected profile is CUSTOM.
  ///
  /// The
  /// - method returns the set of features that can be specified in this list.
  /// This field must be empty if the profile is not CUSTOM.
  core.List<core.String>? customFeatures;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The list of features enabled in the SSL policy.
  ///
  /// Output only.
  core.List<core.String>? enabledFeatures;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a SslPolicy.
  /// An up-to-date fingerprint must be provided in order to update the
  /// SslPolicy, otherwise the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// SslPolicy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#sslPolicyfor SSL policies.
  ///
  /// Output only.
  core.String? kind;

  /// The minimum version of SSL protocol that can be used by the clients to
  /// establish a connection with the load balancer.
  ///
  /// This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
  /// Possible string values are:
  /// - "TLS_1_0"
  /// - "TLS_1_1"
  /// - "TLS_1_2"
  core.String? minTlsVersion;

  /// Name of the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// Profile specifies the set of SSL features that can be used by the load
  /// balancer when negotiating SSL with clients.
  ///
  /// This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using
  /// CUSTOM, the set of SSL features to enable must be specified in the
  /// customFeatures field.
  /// Possible string values are:
  /// - "COMPATIBLE"
  /// - "CUSTOM"
  /// - "MODERN"
  /// - "RESTRICTED"
  core.String? profile;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// If potential misconfigurations are detected for this SSL policy, this
  /// field will be populated with warning messages.
  ///
  /// Output only.
  core.List<SslPolicyWarnings>? warnings;

  SslPolicy();

  SslPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('customFeatures')) {
      customFeatures = (_json['customFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enabledFeatures')) {
      enabledFeatures = (_json['enabledFeatures'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('minTlsVersion')) {
      minTlsVersion = _json['minTlsVersion'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('profile')) {
      profile = _json['profile'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warnings')) {
      warnings = (_json['warnings'] as core.List)
          .map<SslPolicyWarnings>((value) => SslPolicyWarnings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (customFeatures != null) 'customFeatures': customFeatures!,
        if (description != null) 'description': description!,
        if (enabledFeatures != null) 'enabledFeatures': enabledFeatures!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (minTlsVersion != null) 'minTlsVersion': minTlsVersion!,
        if (name != null) 'name': name!,
        if (profile != null) 'profile': profile!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warnings != null)
          'warnings': warnings!.map((value) => value.toJson()).toList(),
      };
}

class SslPolicyReference {
  /// URL of the SSL policy resource.
  ///
  /// Set this to empty string to clear any existing SSL policy associated with
  /// the target proxy resource.
  core.String? sslPolicy;

  SslPolicyReference();

  SslPolicyReference.fromJson(core.Map _json) {
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
      };
}

class StatefulPolicy {
  StatefulPolicyPreservedState? preservedState;

  StatefulPolicy();

  StatefulPolicy.fromJson(core.Map _json) {
    if (_json.containsKey('preservedState')) {
      preservedState = StatefulPolicyPreservedState.fromJson(
          _json['preservedState'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (preservedState != null) 'preservedState': preservedState!.toJson(),
      };
}

/// Configuration of preserved resources.
class StatefulPolicyPreservedState {
  /// Disks created on the instances that will be preserved on instance delete,
  /// update, etc.
  ///
  /// This map is keyed with the device names of the disks.
  core.Map<core.String, StatefulPolicyPreservedStateDiskDevice>? disks;

  StatefulPolicyPreservedState();

  StatefulPolicyPreservedState.fromJson(core.Map _json) {
    if (_json.containsKey('disks')) {
      disks = (_json['disks'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          StatefulPolicyPreservedStateDiskDevice.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (disks != null)
          'disks': disks!.map((key, item) => core.MapEntry(key, item.toJson())),
      };
}

class StatefulPolicyPreservedStateDiskDevice {
  /// These stateful disks will never be deleted during autohealing, update or
  /// VM instance recreate operations.
  ///
  /// This flag is used to configure if the disk should be deleted after it is
  /// no longer used by the group, e.g. when the given instance or the whole
  /// group is deleted. Note: disks attached in READ_ONLY mode cannot be
  /// auto-deleted.
  /// Possible string values are:
  /// - "NEVER"
  /// - "ON_PERMANENT_INSTANCE_DELETION"
  core.String? autoDelete;

  StatefulPolicyPreservedStateDiskDevice();

  StatefulPolicyPreservedStateDiskDevice.fromJson(core.Map _json) {
    if (_json.containsKey('autoDelete')) {
      autoDelete = _json['autoDelete'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoDelete != null) 'autoDelete': autoDelete!,
      };
}

/// Represents a Subnetwork resource.
///
/// A subnetwork (also known as a subnet) is a logical partition of a Virtual
/// Private Cloud network with one primary IP range and zero or more secondary
/// IP ranges.
///
/// For more information, read Virtual Private Cloud (VPC) Network. (==
/// resource_for {$api_version}.subnetworks ==)
class Subnetwork {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource. This field can be set
  /// only at resource creation time.
  core.String? description;

  /// Whether to enable flow logging for this subnetwork.
  ///
  /// If this field is not explicitly set, it will not appear in get listings.
  /// If not set the default behavior is to disable flow logging. This field
  /// isn't supported with the purpose field set to
  /// INTERNAL_HTTPS_LOAD_BALANCER.
  core.bool? enableFlowLogs;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// Subnetwork. An up-to-date fingerprint must be provided in order to update
  /// the Subnetwork, otherwise the request will fail with error 412
  /// conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a
  /// Subnetwork.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The gateway address for default routes to reach destination addresses
  /// outside this subnetwork.
  ///
  /// Output only.
  core.String? gatewayAddress;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// The range of internal addresses that are owned by this subnetwork.
  ///
  /// Provide this property when you create the subnetwork. For example,
  /// 10.0.0.0/8 or 100.64.0.0/10. Ranges must be unique and non-overlapping
  /// within a network. Only IPv4 is supported. This field is set at resource
  /// creation time. The range can be any range listed in the Valid ranges list.
  /// The range can be expanded after creation using expandIpCidrRange.
  core.String? ipCidrRange;

  /// The range of internal IPv6 addresses that are owned by this subnetwork.
  ///
  /// Output only.
  core.String? ipv6CidrRange;

  /// Type of the resource.
  ///
  /// Always compute#subnetwork for Subnetwork resources.
  ///
  /// Output only.
  core.String? kind;

  /// This field denotes the VPC flow logging options for this subnetwork.
  ///
  /// If logging is enabled, logs are exported to Cloud Logging.
  SubnetworkLogConfig? logConfig;

  /// The name of the resource, provided by the client when initially creating
  /// the resource.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035.
  /// Specifically, the name must be 1-63 characters long and match the regular
  /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character
  /// must be a lowercase letter, and all following characters must be a dash,
  /// lowercase letter, or digit, except the last character, which cannot be a
  /// dash.
  core.String? name;

  /// The URL of the network to which this subnetwork belongs, provided by the
  /// client when initially creating the subnetwork.
  ///
  /// Only networks that are in the distributed mode can have subnetworks. This
  /// field can be set only at resource creation time.
  core.String? network;

  /// Whether the VMs in this subnet can access Google services without assigned
  /// external IP addresses.
  ///
  /// This field can be both set at resource creation time and updated using
  /// setPrivateIpGoogleAccess.
  core.bool? privateIpGoogleAccess;

  /// The private IPv6 google access type for the VMs in this subnet.
  ///
  /// This is an expanded field of enablePrivateV6Access. If both fields are
  /// set, privateIpv6GoogleAccess will take priority.
  ///
  /// This field can be both set at resource creation time and updated using
  /// patch.
  /// Possible string values are:
  /// - "DISABLE_GOOGLE_ACCESS"
  /// - "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
  /// - "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
  core.String? privateIpv6GoogleAccess;

  /// The purpose of the resource.
  ///
  /// This field can be either PRIVATE_RFC_1918 or INTERNAL_HTTPS_LOAD_BALANCER.
  /// A subnetwork with purpose set to INTERNAL_HTTPS_LOAD_BALANCER is a
  /// user-created subnetwork that is reserved for Internal HTTP(S) Load
  /// Balancing. If unspecified, the purpose defaults to PRIVATE_RFC_1918. The
  /// enableFlowLogs field isn't supported with the purpose field set to
  /// INTERNAL_HTTPS_LOAD_BALANCER.
  /// Possible string values are:
  /// - "INTERNAL_HTTPS_LOAD_BALANCER"
  /// - "PRIVATE"
  /// - "PRIVATE_RFC_1918"
  core.String? purpose;

  /// URL of the region where the Subnetwork resides.
  ///
  /// This field can be set only at resource creation time.
  core.String? region;

  /// The role of subnetwork.
  ///
  /// Currently, this field is only used when purpose =
  /// INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or BACKUP. An
  /// ACTIVE subnetwork is one that is currently being used for Internal HTTP(S)
  /// Load Balancing. A BACKUP subnetwork is one that is ready to be promoted to
  /// ACTIVE or is currently draining. This field can be updated with a patch
  /// request.
  /// Possible string values are:
  /// - "ACTIVE"
  /// - "BACKUP"
  core.String? role;

  /// An array of configurations for secondary IP ranges for VM instances
  /// contained in this subnetwork.
  ///
  /// The primary IP of such VM must belong to the primary ipCidrRange of the
  /// subnetwork. The alias IPs may belong to either primary or secondary
  /// ranges. This field can be updated with a patch request.
  core.List<SubnetworkSecondaryRange>? secondaryIpRanges;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The state of the subnetwork, which can be one of the following values:
  /// READY: Subnetwork is created and ready to use DRAINING: only applicable to
  /// subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and
  /// indicates that connections to the load balancer are being drained.
  ///
  /// A subnetwork that is draining cannot be used or modified until it reaches
  /// a status of READY CREATING: Subnetwork is provisioning DELETING:
  /// Subnetwork is being deleted UPDATING: Subnetwork is being updated
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DRAINING"
  /// - "READY"
  core.String? state;

  Subnetwork();

  Subnetwork.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('enableFlowLogs')) {
      enableFlowLogs = _json['enableFlowLogs'] as core.bool;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('gatewayAddress')) {
      gatewayAddress = _json['gatewayAddress'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('ipv6CidrRange')) {
      ipv6CidrRange = _json['ipv6CidrRange'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('logConfig')) {
      logConfig = SubnetworkLogConfig.fromJson(
          _json['logConfig'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('privateIpGoogleAccess')) {
      privateIpGoogleAccess = _json['privateIpGoogleAccess'] as core.bool;
    }
    if (_json.containsKey('privateIpv6GoogleAccess')) {
      privateIpv6GoogleAccess = _json['privateIpv6GoogleAccess'] as core.String;
    }
    if (_json.containsKey('purpose')) {
      purpose = _json['purpose'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('role')) {
      role = _json['role'] as core.String;
    }
    if (_json.containsKey('secondaryIpRanges')) {
      secondaryIpRanges = (_json['secondaryIpRanges'] as core.List)
          .map<SubnetworkSecondaryRange>((value) =>
              SubnetworkSecondaryRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (enableFlowLogs != null) 'enableFlowLogs': enableFlowLogs!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (gatewayAddress != null) 'gatewayAddress': gatewayAddress!,
        if (id != null) 'id': id!,
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (ipv6CidrRange != null) 'ipv6CidrRange': ipv6CidrRange!,
        if (kind != null) 'kind': kind!,
        if (logConfig != null) 'logConfig': logConfig!.toJson(),
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (privateIpGoogleAccess != null)
          'privateIpGoogleAccess': privateIpGoogleAccess!,
        if (privateIpv6GoogleAccess != null)
          'privateIpv6GoogleAccess': privateIpv6GoogleAccess!,
        if (purpose != null) 'purpose': purpose!,
        if (region != null) 'region': region!,
        if (role != null) 'role': role!,
        if (secondaryIpRanges != null)
          'secondaryIpRanges':
              secondaryIpRanges!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (state != null) 'state': state!,
      };
}

class SubnetworkAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworkAggregatedListWarningData();

  SubnetworkAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SubnetworkAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworkAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworkAggregatedListWarning();

  SubnetworkAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworkAggregatedListWarningData>((value) =>
              SubnetworkAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SubnetworkAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of SubnetworksScopedList resources.
  core.Map<core.String, SubnetworksScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#subnetworkAggregatedList for aggregated lists of
  /// subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  SubnetworkAggregatedListWarning? warning;

  SubnetworkAggregatedList();

  SubnetworkAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          SubnetworksScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworkAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SubnetworkListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworkListWarningData();

  SubnetworkListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class SubnetworkListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworkListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworkListWarning();

  SubnetworkListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworkListWarningData>((value) =>
              SubnetworkListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of Subnetwork resources.
class SubnetworkList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Subnetwork resources.
  core.List<Subnetwork>? items;

  /// Type of resource.
  ///
  /// Always compute#subnetworkList for lists of subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  SubnetworkListWarning? warning;

  SubnetworkList();

  SubnetworkList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Subnetwork>((value) =>
              Subnetwork.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworkListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The available logging options for this subnetwork.
class SubnetworkLogConfig {
  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// Toggles the aggregation interval for collecting flow logs. Increasing the
  /// interval time will reduce the amount of generated flow logs for long
  /// lasting connections. Default is an interval of 5 seconds per connection.
  /// Possible string values are:
  /// - "INTERVAL_10_MIN"
  /// - "INTERVAL_15_MIN"
  /// - "INTERVAL_1_MIN"
  /// - "INTERVAL_30_SEC"
  /// - "INTERVAL_5_MIN"
  /// - "INTERVAL_5_SEC"
  core.String? aggregationInterval;

  /// Whether to enable flow logging for this subnetwork.
  ///
  /// If this field is not explicitly set, it will not appear in get listings.
  /// If not set the default behavior is to disable flow logging.
  core.bool? enable;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// Export filter used to define which VPC flow logs should be logged.
  core.String? filterExpr;

  /// Can only be specified if VPC flow logging for this subnetwork is enabled.
  ///
  /// The value of the field must be in \[0, 1\]. Set the sampling rate of VPC
  /// flow logs within the subnetwork where 1.0 means all collected logs are
  /// reported and 0.0 means no logs are reported. Default is 0.5, which means
  /// half of all collected logs are reported.
  core.double? flowSampling;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled.
  ///
  /// Configures whether all, none or a subset of metadata fields should be
  /// added to the reported VPC flow logs. Default is INCLUDE_ALL_METADATA.
  /// Possible string values are:
  /// - "CUSTOM_METADATA"
  /// - "EXCLUDE_ALL_METADATA"
  /// - "INCLUDE_ALL_METADATA"
  core.String? metadata;

  /// Can only be specified if VPC flow logs for this subnetwork is enabled and
  /// "metadata" was set to CUSTOM_METADATA.
  core.List<core.String>? metadataFields;

  SubnetworkLogConfig();

  SubnetworkLogConfig.fromJson(core.Map _json) {
    if (_json.containsKey('aggregationInterval')) {
      aggregationInterval = _json['aggregationInterval'] as core.String;
    }
    if (_json.containsKey('enable')) {
      enable = _json['enable'] as core.bool;
    }
    if (_json.containsKey('filterExpr')) {
      filterExpr = _json['filterExpr'] as core.String;
    }
    if (_json.containsKey('flowSampling')) {
      flowSampling = (_json['flowSampling'] as core.num).toDouble();
    }
    if (_json.containsKey('metadata')) {
      metadata = _json['metadata'] as core.String;
    }
    if (_json.containsKey('metadataFields')) {
      metadataFields = (_json['metadataFields'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (aggregationInterval != null)
          'aggregationInterval': aggregationInterval!,
        if (enable != null) 'enable': enable!,
        if (filterExpr != null) 'filterExpr': filterExpr!,
        if (flowSampling != null) 'flowSampling': flowSampling!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataFields != null) 'metadataFields': metadataFields!,
      };
}

/// Represents a secondary IP range of a subnetwork.
class SubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  ///
  /// Provide this property when you create the subnetwork. Ranges must be
  /// unique and non-overlapping with all primary and secondary IP ranges within
  /// a network. Only IPv4 is supported. The range can be any range listed in
  /// the Valid ranges list.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  SubnetworkSecondaryRange();

  SubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('rangeName')) {
      rangeName = _json['rangeName'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (rangeName != null) 'rangeName': rangeName!,
      };
}

class SubnetworksExpandIpCidrRangeRequest {
  /// The IP (in CIDR format or netmask) of internal addresses that are legal on
  /// this Subnetwork.
  ///
  /// This range should be disjoint from other subnetworks within this network.
  /// This range can only be larger than (i.e. a superset of) the range
  /// previously defined before the update.
  core.String? ipCidrRange;

  SubnetworksExpandIpCidrRangeRequest();

  SubnetworksExpandIpCidrRangeRequest.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
      };
}

class SubnetworksScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  SubnetworksScopedListWarningData();

  SubnetworksScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// An informational warning that appears when the list of addresses is empty.
class SubnetworksScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<SubnetworksScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  SubnetworksScopedListWarning();

  SubnetworksScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<SubnetworksScopedListWarningData>((value) =>
              SubnetworksScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class SubnetworksScopedList {
  /// A list of subnetworks contained in this scope.
  core.List<Subnetwork>? subnetworks;

  /// An informational warning that appears when the list of addresses is empty.
  SubnetworksScopedListWarning? warning;

  SubnetworksScopedList();

  SubnetworksScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('subnetworks')) {
      subnetworks = (_json['subnetworks'] as core.List)
          .map<Subnetwork>((value) =>
              Subnetwork.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = SubnetworksScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (subnetworks != null)
          'subnetworks': subnetworks!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class SubnetworksSetPrivateIpGoogleAccessRequest {
  core.bool? privateIpGoogleAccess;

  SubnetworksSetPrivateIpGoogleAccessRequest();

  SubnetworksSetPrivateIpGoogleAccessRequest.fromJson(core.Map _json) {
    if (_json.containsKey('privateIpGoogleAccess')) {
      privateIpGoogleAccess = _json['privateIpGoogleAccess'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (privateIpGoogleAccess != null)
          'privateIpGoogleAccess': privateIpGoogleAccess!,
      };
}

class TCPHealthCheck {
  /// The TCP port number for the health check request.
  ///
  /// The default value is 80. Valid values are 1 through 65535.
  core.int? port;

  /// Port name as defined in InstanceGroup#NamedPort#name.
  ///
  /// If both port and port_name are defined, port takes precedence.
  core.String? portName;

  /// Specifies how port is selected for health checking, can be one of
  /// following values:
  /// USE_FIXED_PORT: The port number in port is used for health checking.
  /// USE_NAMED_PORT: The portName is used for health checking.
  /// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for each
  /// network endpoint is used for health checking.
  ///
  /// For other backends, the port or named port specified in the Backend
  /// Service is used for health checking.
  ///
  ///
  /// If not specified, TCP health check follows behavior specified in port and
  /// portName fields.
  /// Possible string values are:
  /// - "USE_FIXED_PORT"
  /// - "USE_NAMED_PORT"
  /// - "USE_SERVING_PORT"
  core.String? portSpecification;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// The application data to send once the TCP connection has been established
  /// (default value is empty).
  ///
  /// If both request and response are empty, the connection establishment alone
  /// will indicate health. The request data can only be ASCII.
  core.String? request;

  /// The bytes to match against the beginning of the response data.
  ///
  /// If left empty (the default value), any response will indicate health. The
  /// response data can only be ASCII.
  core.String? response;

  TCPHealthCheck();

  TCPHealthCheck.fromJson(core.Map _json) {
    if (_json.containsKey('port')) {
      port = _json['port'] as core.int;
    }
    if (_json.containsKey('portName')) {
      portName = _json['portName'] as core.String;
    }
    if (_json.containsKey('portSpecification')) {
      portSpecification = _json['portSpecification'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('request')) {
      request = _json['request'] as core.String;
    }
    if (_json.containsKey('response')) {
      response = _json['response'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (port != null) 'port': port!,
        if (portName != null) 'portName': portName!,
        if (portSpecification != null) 'portSpecification': portSpecification!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (request != null) 'request': request!,
        if (response != null) 'response': response!,
      };
}

/// A set of instance tags.
class Tags {
  /// Specifies a fingerprint for this request, which is essentially a hash of
  /// the tags' contents and used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update tags. You must always provide an
  /// up-to-date fingerprint hash in order to update or change tags.
  ///
  /// To see the latest fingerprint, make get() request to the instance.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// An array of tags.
  ///
  /// Each tag must be 1-63 characters long, and comply with RFC1035.
  core.List<core.String>? items;

  Tags();

  Tags.fromJson(core.Map _json) {
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (items != null) 'items': items!,
      };
}

/// Represents a Target gRPC Proxy resource.
///
/// A target gRPC proxy is a component of load balancers intended for load
/// balancing gRPC traffic.
///
/// Only global forwarding rules with load balancing scheme
/// INTERNAL_SELF_MANAGED can reference a target gRPC proxy. The target gRPC
/// Proxy references a URL map that specifies how traffic is routed to gRPC
/// backend services. (== resource_for {$api_version}.targetGrpcProxies ==)
class TargetGrpcProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetGrpcProxy. An up-to-date fingerprint must be provided in order to
  /// patch/update the TargetGrpcProxy; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the TargetGrpcProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource type.
  ///
  /// The server generates this identifier.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetGrpcProxy for target grpc proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Server-defined URL with id for the resource.
  ///
  /// Output only.
  core.String? selfLinkWithId;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  ///
  /// The protocol field in the BackendService must be set to GRPC.
  core.String? urlMap;

  /// If true, indicates that the BackendServices referenced by the urlMap may
  /// be accessed by gRPC applications without using a sidecar proxy.
  ///
  /// This will enable configuration checks on urlMap and its referenced
  /// BackendServices to not allow unsupported features. A gRPC application must
  /// use "xds:///" scheme in the target URI of the service it is connecting to.
  /// If false, indicates that the BackendServices referenced by the urlMap will
  /// be accessed by gRPC applications via a sidecar proxy. In this case, a gRPC
  /// application must not use "xds:///" scheme in the target URI of the service
  /// it is connecting to
  core.bool? validateForProxyless;

  TargetGrpcProxy();

  TargetGrpcProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('selfLinkWithId')) {
      selfLinkWithId = _json['selfLinkWithId'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
    if (_json.containsKey('validateForProxyless')) {
      validateForProxyless = _json['validateForProxyless'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (selfLinkWithId != null) 'selfLinkWithId': selfLinkWithId!,
        if (urlMap != null) 'urlMap': urlMap!,
        if (validateForProxyless != null)
          'validateForProxyless': validateForProxyless!,
      };
}

class TargetGrpcProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetGrpcProxyListWarningData();

  TargetGrpcProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetGrpcProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetGrpcProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetGrpcProxyListWarning();

  TargetGrpcProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetGrpcProxyListWarningData>((value) =>
              TargetGrpcProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetGrpcProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetGrpcProxy resources.
  core.List<TargetGrpcProxy>? items;

  /// Type of the resource.
  ///
  /// Always compute#targetGrpcProxy for target grpc proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetGrpcProxyListWarning? warning;

  TargetGrpcProxyList();

  TargetGrpcProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetGrpcProxy>((value) => TargetGrpcProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetGrpcProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpProxiesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpProxiesScopedListWarningData();

  TargetHttpProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpProxiesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpProxiesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpProxiesScopedListWarning();

  TargetHttpProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpProxiesScopedListWarningData>((value) =>
              TargetHttpProxiesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpProxiesScopedList {
  /// A list of TargetHttpProxies contained in this scope.
  core.List<TargetHttpProxy>? targetHttpProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpProxiesScopedListWarning? warning;

  TargetHttpProxiesScopedList();

  TargetHttpProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetHttpProxies')) {
      targetHttpProxies = (_json['targetHttpProxies'] as core.List)
          .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpProxiesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetHttpProxies != null)
          'targetHttpProxies':
              targetHttpProxies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target HTTP Proxy resource.
///
/// Google Compute Engine has two Target HTTP Proxy resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/targetHttpProxies)
/// *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionTargetHttpProxies)
///
/// A target HTTP proxy is a component of GCP HTTP load balancers.
///
/// * targetHttpProxies are used by external HTTP load balancers and Traffic
/// Director.
///
/// * regionTargetHttpProxies are used by internal HTTP load balancers.
///
/// Forwarding rules reference a target HTTP proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpProxies ==)
class TargetHttpProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a
  /// TargetHttpProxy. An up-to-date fingerprint must be provided in order to
  /// patch/update the TargetHttpProxy; otherwise, the request will fail with
  /// error 412 conditionNotMet. To see the latest fingerprint, make a get()
  /// request to retrieve the TargetHttpProxy.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxy for target HTTP proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule.
  ///
  /// This is generally useful when using Traffic Director to configure Envoy as
  /// a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy
  /// proxy listens for inbound requests and handles requests when it receives
  /// them.
  ///
  /// The default is false.
  core.bool? proxyBind;

  /// URL of the region where the regional Target HTTP Proxy resides.
  ///
  /// This field is not applicable to global Target HTTP Proxies.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the UrlMap resource that defines the mapping from URL to the
  /// BackendService.
  core.String? urlMap;

  TargetHttpProxy();

  TargetHttpProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyBind')) {
      proxyBind = _json['proxyBind'] as core.bool;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

class TargetHttpProxyAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpProxiesScopedList resources.
  core.Map<core.String, TargetHttpProxiesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxyAggregatedList for lists of Target HTTP
  /// Proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  TargetHttpProxyAggregatedList();

  TargetHttpProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          TargetHttpProxiesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
      };
}

class TargetHttpProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpProxyListWarningData();

  TargetHttpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpProxyListWarning();

  TargetHttpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpProxyListWarningData>((value) =>
              TargetHttpProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// A list of TargetHttpProxy resources.
class TargetHttpProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpProxy resources.
  core.List<TargetHttpProxy>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpProxyList for lists of target HTTP proxies.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpProxyListWarning? warning;

  TargetHttpProxyList();

  TargetHttpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetHttpProxy>((value) => TargetHttpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxiesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxiesScopedListWarningData();

  TargetHttpsProxiesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class TargetHttpsProxiesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxiesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxiesScopedListWarning();

  TargetHttpsProxiesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxiesScopedListWarningData>((value) =>
              TargetHttpsProxiesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpsProxiesScopedList {
  /// A list of TargetHttpsProxies contained in this scope.
  core.List<TargetHttpsProxy>? targetHttpsProxies;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  TargetHttpsProxiesScopedListWarning? warning;

  TargetHttpsProxiesScopedList();

  TargetHttpsProxiesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetHttpsProxies')) {
      targetHttpsProxies = (_json['targetHttpsProxies'] as core.List)
          .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxiesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetHttpsProxies != null)
          'targetHttpsProxies':
              targetHttpsProxies!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxiesSetQuicOverrideRequest {
  /// QUIC policy for the TargetHttpsProxy resource.
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String? quicOverride;

  TargetHttpsProxiesSetQuicOverrideRequest();

  TargetHttpsProxiesSetQuicOverrideRequest.fromJson(core.Map _json) {
    if (_json.containsKey('quicOverride')) {
      quicOverride = _json['quicOverride'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (quicOverride != null) 'quicOverride': quicOverride!,
      };
}

class TargetHttpsProxiesSetSslCertificatesRequest {
  /// New set of SslCertificate resources to associate with this
  /// TargetHttpsProxy resource.
  ///
  /// Currently exactly one SslCertificate resource must be specified.
  core.List<core.String>? sslCertificates;

  TargetHttpsProxiesSetSslCertificatesRequest();

  TargetHttpsProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

/// Represents a Target HTTPS Proxy resource.
///
/// Google Compute Engine has two Target HTTPS Proxy resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/targetHttpsProxies)
/// *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionTargetHttpsProxies)
///
/// A target HTTPS proxy is a component of GCP HTTPS load balancers.
///
/// * targetHttpsProxies are used by external HTTPS load balancers.
///
/// * regionTargetHttpsProxies are used by internal HTTPS load balancers.
///
/// Forwarding rules reference a target HTTPS proxy, and the target proxy then
/// references a URL map. For more information, read Using Target Proxies and
/// Forwarding rule concepts. (== resource_for {$api_version}.targetHttpsProxies
/// ==) (== resource_for {$api_version}.regionTargetHttpsProxies ==)
class TargetHttpsProxy {
  /// A URL referring to a networksecurity.AuthorizationPolicy resource that
  /// describes how the proxy should authorize inbound traffic.
  ///
  /// If left blank, access will not be restricted by an authorization policy.
  /// Refer to the AuthorizationPolicy resource for additional details.
  /// authorizationPolicy only applies to a global TargetHttpsProxy attached to
  /// globalForwardingRules with the loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED.
  /// Note: This field currently has no impact.
  ///
  /// Optional.
  core.String? authorizationPolicy;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxy for target HTTPS proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule.
  ///
  /// This is generally useful when using Traffic Director to configure Envoy as
  /// a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy
  /// proxy listens for inbound requests and handles requests when it receives
  /// them.
  ///
  /// The default is false.
  core.bool? proxyBind;

  /// Specifies the QUIC override policy for this TargetHttpsProxy resource.
  ///
  /// This setting determines whether the load balancer attempts to negotiate
  /// QUIC with clients. You can specify NONE, ENABLE, or DISABLE.
  /// - When quic-override is set to NONE, Google manages whether QUIC is used.
  /// - When quic-override is set to ENABLE, the load balancer uses QUIC when
  /// possible.
  /// - When quic-override is set to DISABLE, the load balancer doesn't use
  /// QUIC.
  /// - If the quic-override flag is not specified, NONE is implied.
  /// Possible string values are:
  /// - "DISABLE"
  /// - "ENABLE"
  /// - "NONE"
  core.String? quicOverride;

  /// URL of the region where the regional TargetHttpsProxy resides.
  ///
  /// This field is not applicable to global TargetHttpsProxies.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A URL referring to a networksecurity.ServerTlsPolicy resource that
  /// describes how the proxy should authenticate inbound traffic.
  /// serverTlsPolicy only applies to a global TargetHttpsProxy attached to
  /// globalForwardingRules with the loadBalancingScheme set to
  /// INTERNAL_SELF_MANAGED.
  /// If left blank, communications are not encrypted.
  /// Note: This field currently has no impact.
  ///
  /// Optional.
  core.String? serverTlsPolicy;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// between users and the load balancer.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  /// URL of SslPolicy resource that will be associated with the
  /// TargetHttpsProxy resource.
  ///
  /// If not set, the TargetHttpsProxy resource has no SSL policy configured.
  core.String? sslPolicy;

  /// A fully-qualified or valid partial URL to the UrlMap resource that defines
  /// the mapping from URL to the BackendService.
  ///
  /// For example, the following are all valid URLs for specifying a URL map:
  /// -
  /// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
  /// - projects/project/global/urlMaps/url-map
  /// - global/urlMaps/url-map
  core.String? urlMap;

  TargetHttpsProxy();

  TargetHttpsProxy.fromJson(core.Map _json) {
    if (_json.containsKey('authorizationPolicy')) {
      authorizationPolicy = _json['authorizationPolicy'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyBind')) {
      proxyBind = _json['proxyBind'] as core.bool;
    }
    if (_json.containsKey('quicOverride')) {
      quicOverride = _json['quicOverride'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('serverTlsPolicy')) {
      serverTlsPolicy = _json['serverTlsPolicy'] as core.String;
    }
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (authorizationPolicy != null)
          'authorizationPolicy': authorizationPolicy!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (quicOverride != null) 'quicOverride': quicOverride!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (serverTlsPolicy != null) 'serverTlsPolicy': serverTlsPolicy!,
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

class TargetHttpsProxyAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxyAggregatedListWarningData();

  TargetHttpsProxyAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpsProxyAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxyAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxyAggregatedListWarning();

  TargetHttpsProxyAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxyAggregatedListWarningData>((value) =>
              TargetHttpsProxyAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetHttpsProxyAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpsProxiesScopedList resources.
  core.Map<core.String, TargetHttpsProxiesScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxyAggregatedList for lists of Target HTTP
  /// Proxies.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpsProxyAggregatedListWarning? warning;

  TargetHttpsProxyAggregatedList();

  TargetHttpsProxyAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          TargetHttpsProxiesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxyAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetHttpsProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetHttpsProxyListWarningData();

  TargetHttpsProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetHttpsProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetHttpsProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetHttpsProxyListWarning();

  TargetHttpsProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetHttpsProxyListWarningData>((value) =>
              TargetHttpsProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetHttpsProxy resources.
class TargetHttpsProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetHttpsProxy resources.
  core.List<TargetHttpsProxy>? items;

  /// Type of resource.
  ///
  /// Always compute#targetHttpsProxyList for lists of target HTTPS proxies.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetHttpsProxyListWarning? warning;

  TargetHttpsProxyList();

  TargetHttpsProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetHttpsProxy>((value) => TargetHttpsProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetHttpsProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target Instance resource.
///
/// You can use a target instance to handle traffic for one or more forwarding
/// rules, which is ideal for forwarding protocol traffic that is managed by a
/// single source.
///
/// For example, ESP, AH, TCP, or UDP. For more information, read Target
/// instances. (== resource_for {$api_version}.targetInstances ==)
class TargetInstance {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A URL to the virtual machine instance that handles traffic for this target
  /// instance.
  ///
  /// When creating a target instance, you can provide the fully-qualified URL
  /// or a valid partial URL to the desired virtual machine. For example, the
  /// following are all valid URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
  /// - projects/project/zones/zone/instances/instance
  /// - zones/zone/instances/instance
  core.String? instance;

  /// The type of the resource.
  ///
  /// Always compute#targetInstance for target instances.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// NAT option controlling how IPs are NAT'ed to the instance.
  ///
  /// Currently only NO_NAT (default value) is supported.
  /// Possible string values are:
  /// - "NO_NAT"
  core.String? natPolicy;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL of the zone where the target instance resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? zone;

  TargetInstance();

  TargetInstance.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instance')) {
      instance = _json['instance'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('natPolicy')) {
      natPolicy = _json['natPolicy'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('zone')) {
      zone = _json['zone'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (instance != null) 'instance': instance!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (natPolicy != null) 'natPolicy': natPolicy!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (zone != null) 'zone': zone!,
      };
}

class TargetInstanceAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstanceAggregatedListWarningData();

  TargetInstanceAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetInstanceAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstanceAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstanceAggregatedListWarning();

  TargetInstanceAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstanceAggregatedListWarningData>((value) =>
              TargetInstanceAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetInstanceAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetInstance resources.
  core.Map<core.String, TargetInstancesScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetInstanceAggregatedListWarning? warning;

  TargetInstanceAggregatedList();

  TargetInstanceAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          TargetInstancesScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstanceAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetInstanceListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstanceListWarningData();

  TargetInstanceListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetInstanceListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstanceListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstanceListWarning();

  TargetInstanceListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstanceListWarningData>((value) =>
              TargetInstanceListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetInstance resources.
class TargetInstanceList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetInstance resources.
  core.List<TargetInstance>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetInstanceListWarning? warning;

  TargetInstanceList();

  TargetInstanceList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetInstance>((value) => TargetInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstanceListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetInstancesScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetInstancesScopedListWarningData();

  TargetInstancesScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetInstancesScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetInstancesScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetInstancesScopedListWarning();

  TargetInstancesScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetInstancesScopedListWarningData>((value) =>
              TargetInstancesScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetInstancesScopedList {
  /// A list of target instances contained in this scope.
  core.List<TargetInstance>? targetInstances;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetInstancesScopedListWarning? warning;

  TargetInstancesScopedList();

  TargetInstancesScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetInstances')) {
      targetInstances = (_json['targetInstances'] as core.List)
          .map<TargetInstance>((value) => TargetInstance.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetInstancesScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetInstances != null)
          'targetInstances':
              targetInstances!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target Pool resource.
///
/// Target pools are used for network TCP/UDP load balancing.
///
/// A target pool references member instances, an associated legacy
/// HttpHealthCheck resource, and, optionally, a backup target pool. For more
/// information, read Using target pools. (== resource_for
/// {$api_version}.targetPools ==)
class TargetPool {
  /// The server-defined URL for the resource.
  ///
  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool, and its failoverRatio field is
  /// properly set to a value between \[0, 1\].
  ///
  /// backupPool and failoverRatio together define the fallback behavior of the
  /// primary target pool: if the ratio of the healthy instances in the primary
  /// pool is at or below failoverRatio, traffic arriving at the load-balanced
  /// IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio and backupPool are not set, or all the
  /// instances in the backup pool are unhealthy, the traffic will be directed
  /// back to the primary pool in the "force" mode, where traffic will be spread
  /// to the healthy instances with the best effort, or to all instances when no
  /// instance is healthy.
  core.String? backupPool;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// This field is applicable only when the containing target pool is serving a
  /// forwarding rule as the primary pool (i.e., not as a backup pool to some
  /// other target pool).
  ///
  /// The value of the field must be in \[0, 1\].
  ///
  /// If set, backupPool must also be set. They together define the fallback
  /// behavior of the primary target pool: if the ratio of the healthy instances
  /// in the primary pool is at or below this number, traffic arriving at the
  /// load-balanced IP will be directed to the backup pool.
  ///
  /// In case where failoverRatio is not set or all the instances in the backup
  /// pool are unhealthy, the traffic will be directed back to the primary pool
  /// in the "force" mode, where traffic will be spread to the healthy instances
  /// with the best effort, or to all instances when no instance is healthy.
  core.double? failoverRatio;

  /// The URL of the HttpHealthCheck resource.
  ///
  /// A member instance in this pool is considered healthy if and only if the
  /// health checks pass. Only legacy HttpHealthChecks are supported. Only one
  /// health check may be specified.
  core.List<core.String>? healthChecks;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of resource URLs to the virtual machine instances serving this
  /// pool.
  ///
  /// They must live in zones contained in the same region as this pool.
  core.List<core.String>? instances;

  /// Type of the resource.
  ///
  /// Always compute#targetPool for target pools.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the region where the target pool resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Session affinity option, must be one of the following values:
  /// NONE: Connections from the same client IP may go to any instance in the
  /// pool.
  /// CLIENT_IP: Connections from the same client IP will go to the same
  /// instance in the pool while that instance remains healthy.
  /// CLIENT_IP_PROTO: Connections from the same client IP with the same IP
  /// protocol will go to the same instance in the pool while that instance
  /// remains healthy.
  /// Possible string values are:
  /// - "CLIENT_IP"
  /// - "CLIENT_IP_PORT_PROTO"
  /// - "CLIENT_IP_PROTO"
  /// - "GENERATED_COOKIE"
  /// - "HEADER_FIELD"
  /// - "HTTP_COOKIE"
  /// - "NONE"
  core.String? sessionAffinity;

  TargetPool();

  TargetPool.fromJson(core.Map _json) {
    if (_json.containsKey('backupPool')) {
      backupPool = _json['backupPool'] as core.String;
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('failoverRatio')) {
      failoverRatio = (_json['failoverRatio'] as core.num).toDouble();
    }
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sessionAffinity')) {
      sessionAffinity = _json['sessionAffinity'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backupPool != null) 'backupPool': backupPool!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (failoverRatio != null) 'failoverRatio': failoverRatio!,
        if (healthChecks != null) 'healthChecks': healthChecks!,
        if (id != null) 'id': id!,
        if (instances != null) 'instances': instances!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sessionAffinity != null) 'sessionAffinity': sessionAffinity!,
      };
}

class TargetPoolAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolAggregatedListWarningData();

  TargetPoolAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetPoolAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolAggregatedListWarning();

  TargetPoolAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolAggregatedListWarningData>((value) =>
              TargetPoolAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetPoolAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetPool resources.
  core.Map<core.String, TargetPoolsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetPoolAggregatedList for aggregated lists of target
  /// pools.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetPoolAggregatedListWarning? warning;

  TargetPoolAggregatedList();

  TargetPoolAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          TargetPoolsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetPoolInstanceHealth {
  core.List<HealthStatus>? healthStatus;

  /// Type of resource.
  ///
  /// Always compute#targetPoolInstanceHealth when checking the health of an
  /// instance.
  ///
  /// Output only.
  core.String? kind;

  TargetPoolInstanceHealth();

  TargetPoolInstanceHealth.fromJson(core.Map _json) {
    if (_json.containsKey('healthStatus')) {
      healthStatus = (_json['healthStatus'] as core.List)
          .map<HealthStatus>((value) => HealthStatus.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthStatus != null)
          'healthStatus': healthStatus!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
      };
}

class TargetPoolListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolListWarningData();

  TargetPoolListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetPoolListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolListWarning();

  TargetPoolListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolListWarningData>((value) =>
              TargetPoolListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetPool resources.
class TargetPoolList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetPool resources.
  core.List<TargetPool>? items;

  /// Type of resource.
  ///
  /// Always compute#targetPoolList for lists of target pools.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetPoolListWarning? warning;

  TargetPoolList();

  TargetPoolList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetPool>((value) =>
              TargetPool.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetPoolsAddHealthCheckRequest {
  /// The HttpHealthCheck to add to the target pool.
  core.List<HealthCheckReference>? healthChecks;

  TargetPoolsAddHealthCheckRequest();

  TargetPoolsAddHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheckReference>((value) => HealthCheckReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsAddInstanceRequest {
  /// A full or partial URL to an instance to add to this target pool.
  ///
  /// This can be a full or partial URL. For example, the following are valid
  /// URLs:
  /// -
  /// https://www.googleapis.com/compute/v1/projects/project-id/zones/zone/instances/instance-name
  /// - projects/project-id/zones/zone/instances/instance-name
  /// - zones/zone/instances/instance-name
  core.List<InstanceReference>? instances;

  TargetPoolsAddInstanceRequest();

  TargetPoolsAddInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsRemoveHealthCheckRequest {
  /// Health check URL to be removed.
  ///
  /// This can be a full or valid partial URL. For example, the following are
  /// valid URLs:
  /// -
  /// https://www.googleapis.com/compute/beta/projects/project/global/httpHealthChecks/health-check
  /// - projects/project/global/httpHealthChecks/health-check
  /// - global/httpHealthChecks/health-check
  core.List<HealthCheckReference>? healthChecks;

  TargetPoolsRemoveHealthCheckRequest();

  TargetPoolsRemoveHealthCheckRequest.fromJson(core.Map _json) {
    if (_json.containsKey('healthChecks')) {
      healthChecks = (_json['healthChecks'] as core.List)
          .map<HealthCheckReference>((value) => HealthCheckReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (healthChecks != null)
          'healthChecks': healthChecks!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsRemoveInstanceRequest {
  /// URLs of the instances to be removed from target pool.
  core.List<InstanceReference>? instances;

  TargetPoolsRemoveInstanceRequest();

  TargetPoolsRemoveInstanceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('instances')) {
      instances = (_json['instances'] as core.List)
          .map<InstanceReference>((value) => InstanceReference.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null)
          'instances': instances!.map((value) => value.toJson()).toList(),
      };
}

class TargetPoolsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetPoolsScopedListWarningData();

  TargetPoolsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class TargetPoolsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetPoolsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetPoolsScopedListWarning();

  TargetPoolsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetPoolsScopedListWarningData>((value) =>
              TargetPoolsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetPoolsScopedList {
  /// A list of target pools contained in this scope.
  core.List<TargetPool>? targetPools;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  TargetPoolsScopedListWarning? warning;

  TargetPoolsScopedList();

  TargetPoolsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetPools')) {
      targetPools = (_json['targetPools'] as core.List)
          .map<TargetPool>((value) =>
              TargetPool.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetPoolsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetPools != null)
          'targetPools': targetPools!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetReference {
  core.String? target;

  TargetReference();

  TargetReference.fromJson(core.Map _json) {
    if (_json.containsKey('target')) {
      target = _json['target'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (target != null) 'target': target!,
      };
}

class TargetSslProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetSslProxy.
  core.String? service;

  TargetSslProxiesSetBackendServiceRequest();

  TargetSslProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
      };
}

class TargetSslProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  ///
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  TargetSslProxiesSetProxyHeaderRequest();

  TargetSslProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
      };
}

class TargetSslProxiesSetSslCertificatesRequest {
  /// New set of URLs to SslCertificate resources to associate with this
  /// TargetSslProxy.
  ///
  /// Currently exactly one ssl certificate must be specified.
  core.List<core.String>? sslCertificates;

  TargetSslProxiesSetSslCertificatesRequest();

  TargetSslProxiesSetSslCertificatesRequest.fromJson(core.Map _json) {
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
      };
}

/// Represents a Target SSL Proxy resource.
///
/// A target SSL proxy is a component of a SSL Proxy load balancer.
///
/// Global forwarding rules reference a target SSL proxy, and the target proxy
/// then references an external backend service. For more information, read
/// Using Target Proxies. (== resource_for {$api_version}.targetSslProxies ==)
class TargetSslProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetSslProxy for target SSL proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  /// URLs to SslCertificate resources that are used to authenticate connections
  /// to Backends.
  ///
  /// At least one SSL certificate must be specified. Currently, you may specify
  /// up to 15 SSL certificates.
  core.List<core.String>? sslCertificates;

  /// URL of SslPolicy resource that will be associated with the TargetSslProxy
  /// resource.
  ///
  /// If not set, the TargetSslProxy resource will not have any SSL policy
  /// configured.
  core.String? sslPolicy;

  TargetSslProxy();

  TargetSslProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
    if (_json.containsKey('sslCertificates')) {
      sslCertificates = (_json['sslCertificates'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('sslPolicy')) {
      sslPolicy = _json['sslPolicy'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (service != null) 'service': service!,
        if (sslCertificates != null) 'sslCertificates': sslCertificates!,
        if (sslPolicy != null) 'sslPolicy': sslPolicy!,
      };
}

class TargetSslProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetSslProxyListWarningData();

  TargetSslProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetSslProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetSslProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetSslProxyListWarning();

  TargetSslProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetSslProxyListWarningData>((value) =>
              TargetSslProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetSslProxy resources.
class TargetSslProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetSslProxy resources.
  core.List<TargetSslProxy>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetSslProxyListWarning? warning;

  TargetSslProxyList();

  TargetSslProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetSslProxy>((value) => TargetSslProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetSslProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetTcpProxiesSetBackendServiceRequest {
  /// The URL of the new BackendService resource for the targetTcpProxy.
  core.String? service;

  TargetTcpProxiesSetBackendServiceRequest();

  TargetTcpProxiesSetBackendServiceRequest.fromJson(core.Map _json) {
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (service != null) 'service': service!,
      };
}

class TargetTcpProxiesSetProxyHeaderRequest {
  /// The new type of proxy header to append before sending data to the backend.
  ///
  /// NONE or PROXY_V1 are allowed.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  TargetTcpProxiesSetProxyHeaderRequest();

  TargetTcpProxiesSetProxyHeaderRequest.fromJson(core.Map _json) {
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
      };
}

/// Represents a Target TCP Proxy resource.
///
/// A target TCP proxy is a component of a TCP Proxy load balancer.
///
/// Global forwarding rules reference target TCP proxy, and the target proxy
/// then references an external backend service. For more information, read TCP
/// Proxy Load Balancing overview. (== resource_for
/// {$api_version}.targetTcpProxies ==)
class TargetTcpProxy {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#targetTcpProxy for target TCP proxies.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// This field only applies when the forwarding rule that references this
  /// target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
  ///
  /// When this field is set to true, Envoy proxies set up inbound traffic
  /// interception and bind to the IP address and port specified in the
  /// forwarding rule.
  ///
  /// This is generally useful when using Traffic Director to configure Envoy as
  /// a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy
  /// proxy listens for inbound requests and handles requests when it receives
  /// them.
  ///
  /// The default is false.
  core.bool? proxyBind;

  /// Specifies the type of proxy header to append before sending data to the
  /// backend, either NONE or PROXY_V1.
  ///
  /// The default is NONE.
  /// Possible string values are:
  /// - "NONE"
  /// - "PROXY_V1"
  core.String? proxyHeader;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// URL to the BackendService resource.
  core.String? service;

  TargetTcpProxy();

  TargetTcpProxy.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('proxyBind')) {
      proxyBind = _json['proxyBind'] as core.bool;
    }
    if (_json.containsKey('proxyHeader')) {
      proxyHeader = _json['proxyHeader'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (proxyBind != null) 'proxyBind': proxyBind!,
        if (proxyHeader != null) 'proxyHeader': proxyHeader!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (service != null) 'service': service!,
      };
}

class TargetTcpProxyListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetTcpProxyListWarningData();

  TargetTcpProxyListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetTcpProxyListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetTcpProxyListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetTcpProxyListWarning();

  TargetTcpProxyListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetTcpProxyListWarningData>((value) =>
              TargetTcpProxyListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetTcpProxy resources.
class TargetTcpProxyList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetTcpProxy resources.
  core.List<TargetTcpProxy>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetTcpProxyListWarning? warning;

  TargetTcpProxyList();

  TargetTcpProxyList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetTcpProxy>((value) => TargetTcpProxy.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetTcpProxyListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Target VPN Gateway resource.
///
/// The target VPN gateway resource represents a Classic Cloud VPN gateway.
///
/// For more information, read the the Cloud VPN Overview. (== resource_for
/// {$api_version}.targetVpnGateways ==)
class TargetVpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// A list of URLs to the ForwardingRule resources.
  ///
  /// ForwardingRules are created using compute.forwardingRules.insert and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? forwardingRules;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the network to which this VPN gateway is attached.
  ///
  /// Provided by the client when the VPN gateway is created.
  core.String? network;

  /// URL of the region where the target VPN gateway resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The status of the VPN gateway, which can be one of the following:
  /// CREATING, READY, FAILED, or DELETING.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CREATING"
  /// - "DELETING"
  /// - "FAILED"
  /// - "READY"
  core.String? status;

  /// A list of URLs to VpnTunnel resources.
  ///
  /// VpnTunnels are created using the compute.vpntunnels.insert method and
  /// associated with a VPN gateway.
  ///
  /// Output only.
  core.List<core.String>? tunnels;

  TargetVpnGateway();

  TargetVpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('forwardingRules')) {
      forwardingRules = (_json['forwardingRules'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('tunnels')) {
      tunnels = (_json['tunnels'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (forwardingRules != null) 'forwardingRules': forwardingRules!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (tunnels != null) 'tunnels': tunnels!,
      };
}

class TargetVpnGatewayAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewayAggregatedListWarningData();

  TargetVpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetVpnGatewayAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewayAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewayAggregatedListWarning();

  TargetVpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewayAggregatedListWarningData>((value) =>
              TargetVpnGatewayAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetVpnGatewayAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetVpnGateway resources.
  core.Map<core.String, TargetVpnGatewaysScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  TargetVpnGatewayAggregatedListWarning? warning;

  TargetVpnGatewayAggregatedList();

  TargetVpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          TargetVpnGatewaysScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewayAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetVpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewayListWarningData();

  TargetVpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class TargetVpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewayListWarning();

  TargetVpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewayListWarningData>((value) =>
              TargetVpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of TargetVpnGateway resources.
class TargetVpnGatewayList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of TargetVpnGateway resources.
  core.List<TargetVpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#targetVpnGateway for target VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  TargetVpnGatewayListWarning? warning;

  TargetVpnGatewayList();

  TargetVpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TargetVpnGatewaysScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  TargetVpnGatewaysScopedListWarningData();

  TargetVpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class TargetVpnGatewaysScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<TargetVpnGatewaysScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  TargetVpnGatewaysScopedListWarning();

  TargetVpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<TargetVpnGatewaysScopedListWarningData>((value) =>
              TargetVpnGatewaysScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class TargetVpnGatewaysScopedList {
  /// A list of target VPN gateways contained in this scope.
  ///
  /// Output only.
  core.List<TargetVpnGateway>? targetVpnGateways;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  TargetVpnGatewaysScopedListWarning? warning;

  TargetVpnGatewaysScopedList();

  TargetVpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('targetVpnGateways')) {
      targetVpnGateways = (_json['targetVpnGateways'] as core.List)
          .map<TargetVpnGateway>((value) => TargetVpnGateway.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = TargetVpnGatewaysScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (targetVpnGateways != null)
          'targetVpnGateways':
              targetVpnGateways!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class TestFailure {
  /// The actual output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  core.String? actualOutputUrl;

  /// Actual HTTP status code for rule with `urlRedirect` calculated by load
  /// balancer
  core.int? actualRedirectResponseCode;

  /// BackendService or BackendBucket returned by load balancer.
  core.String? actualService;

  /// The expected output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  core.String? expectedOutputUrl;

  /// Expected HTTP status code for rule with `urlRedirect` calculated by load
  /// balancer
  core.int? expectedRedirectResponseCode;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  core.String? expectedService;

  /// HTTP headers of the request.
  core.List<UrlMapTestHeader>? headers;

  /// Host portion of the URL.
  core.String? host;

  /// Path portion including query parameters in the URL.
  core.String? path;

  TestFailure();

  TestFailure.fromJson(core.Map _json) {
    if (_json.containsKey('actualOutputUrl')) {
      actualOutputUrl = _json['actualOutputUrl'] as core.String;
    }
    if (_json.containsKey('actualRedirectResponseCode')) {
      actualRedirectResponseCode =
          _json['actualRedirectResponseCode'] as core.int;
    }
    if (_json.containsKey('actualService')) {
      actualService = _json['actualService'] as core.String;
    }
    if (_json.containsKey('expectedOutputUrl')) {
      expectedOutputUrl = _json['expectedOutputUrl'] as core.String;
    }
    if (_json.containsKey('expectedRedirectResponseCode')) {
      expectedRedirectResponseCode =
          _json['expectedRedirectResponseCode'] as core.int;
    }
    if (_json.containsKey('expectedService')) {
      expectedService = _json['expectedService'] as core.String;
    }
    if (_json.containsKey('headers')) {
      headers = (_json['headers'] as core.List)
          .map<UrlMapTestHeader>((value) => UrlMapTestHeader.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (actualOutputUrl != null) 'actualOutputUrl': actualOutputUrl!,
        if (actualRedirectResponseCode != null)
          'actualRedirectResponseCode': actualRedirectResponseCode!,
        if (actualService != null) 'actualService': actualService!,
        if (expectedOutputUrl != null) 'expectedOutputUrl': expectedOutputUrl!,
        if (expectedRedirectResponseCode != null)
          'expectedRedirectResponseCode': expectedRedirectResponseCode!,
        if (expectedService != null) 'expectedService': expectedService!,
        if (headers != null)
          'headers': headers!.map((value) => value.toJson()).toList(),
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
      };
}

class TestPermissionsRequest {
  /// The set of permissions to check for the 'resource'.
  ///
  /// Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
  core.List<core.String>? permissions;

  TestPermissionsRequest();

  TestPermissionsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissions != null) 'permissions': permissions!,
      };
}

class TestPermissionsResponse {
  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  core.List<core.String>? permissions;

  TestPermissionsResponse();

  TestPermissionsResponse.fromJson(core.Map _json) {
    if (_json.containsKey('permissions')) {
      permissions = (_json['permissions'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (permissions != null) 'permissions': permissions!,
      };
}

/// Represents a URL Map resource.
///
/// Google Compute Engine has two URL Map resources:
///
/// * \[Global\](/compute/docs/reference/rest/{$api_version}/urlMaps) *
/// \[Regional\](/compute/docs/reference/rest/{$api_version}/regionUrlMaps)
///
/// A URL map resource is a component of certain types of GCP load balancers and
/// Traffic Director.
///
/// * urlMaps are used by external HTTP(S) load balancers and Traffic Director.
///
/// * regionUrlMaps are used by internal HTTP(S) load balancers.
///
/// For a list of supported URL map features by load balancer type, see the Load
/// balancing features: Routing and traffic management table.
///
/// For a list of supported URL map features for Traffic Director, see the
/// Traffic Director features: Routing and traffic management table.
///
/// This resource defines mappings from host names and URL paths to either a
/// backend service or a backend bucket.
///
/// To use the global urlMaps resource, the backend service must have a
/// loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the
/// regionUrlMaps resource, the backend service must have a loadBalancingScheme
/// of INTERNAL_MANAGED. For more information, read URL Map Concepts.
class UrlMap {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// defaultRouteAction takes effect when none of the  hostRules match.
  ///
  /// The load balancer performs advanced routing actions like URL rewrites,
  /// header transformations, etc. prior to forwarding the request to the
  /// selected backend. If defaultRouteAction specifies any
  /// weightedBackendServices, defaultService must not be set. Conversely if
  /// defaultService is set, defaultRouteAction cannot contain any
  /// weightedBackendServices.
  /// Only one of defaultRouteAction or defaultUrlRedirect must be set.
  /// UrlMaps for external HTTP(S) load balancers support only the urlRewrite
  /// action within defaultRouteAction.
  /// defaultRouteAction has no effect when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  HttpRouteAction? defaultRouteAction;

  /// The full or partial URL of the defaultService resource to which traffic is
  /// directed if none of the hostRules match.
  ///
  /// If defaultRouteAction is additionally specified, advanced routing actions
  /// like URL Rewrites, etc. take effect prior to sending the request to the
  /// backend. However, if defaultService is specified, defaultRouteAction
  /// cannot contain any weightedBackendServices. Conversely, if routeAction
  /// specifies any weightedBackendServices, service must not be specified.
  /// Only one of defaultService, defaultUrlRedirect or
  /// defaultRouteAction.weightedBackendService must be set.
  /// defaultService has no effect when the URL map is bound to target gRPC
  /// proxy that has validateForProxyless field set to true.
  core.String? defaultService;

  /// When none of the specified hostRules match, the request is redirected to a
  /// URL specified by defaultUrlRedirect.
  /// If defaultUrlRedirect is specified, defaultService or defaultRouteAction
  /// must not be set.
  /// Not supported when the URL map is bound to target gRPC proxy.
  HttpRedirectAction? defaultUrlRedirect;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Fingerprint of this resource.
  ///
  /// A hash of the contents stored in this object. This field is used in
  /// optimistic locking. This field will be ignored when inserting a UrlMap. An
  /// up-to-date fingerprint must be provided in order to update the UrlMap,
  /// otherwise the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve a UrlMap.
  core.String? fingerprint;
  core.List<core.int> get fingerprintAsBytes =>
      convert.base64.decode(fingerprint!);

  set fingerprintAsBytes(core.List<core.int> _bytes) {
    fingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// The headerAction specified here take effect after headerAction specified
  /// under pathMatcher.
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// The list of HostRules to use against the URL.
  core.List<HostRule>? hostRules;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#urlMaps for url maps.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// The list of named PathMatchers to use against the URL.
  core.List<PathMatcher>? pathMatchers;

  /// URL of the region where the regional URL map resides.
  ///
  /// This field is not applicable to global URL maps. You must specify this
  /// field as part of the HTTP request URL. It is not settable as a field in
  /// the request body.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// The list of expected URL mapping tests.
  ///
  /// Request to update this UrlMap will succeed only if all of the test cases
  /// pass. You can specify a maximum of 100 tests per UrlMap.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  core.List<UrlMapTest>? tests;

  UrlMap();

  UrlMap.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('defaultRouteAction')) {
      defaultRouteAction = HttpRouteAction.fromJson(
          _json['defaultRouteAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('defaultService')) {
      defaultService = _json['defaultService'] as core.String;
    }
    if (_json.containsKey('defaultUrlRedirect')) {
      defaultUrlRedirect = HttpRedirectAction.fromJson(
          _json['defaultUrlRedirect'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('fingerprint')) {
      fingerprint = _json['fingerprint'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('hostRules')) {
      hostRules = (_json['hostRules'] as core.List)
          .map<HostRule>((value) =>
              HostRule.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('pathMatchers')) {
      pathMatchers = (_json['pathMatchers'] as core.List)
          .map<PathMatcher>((value) => PathMatcher.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('tests')) {
      tests = (_json['tests'] as core.List)
          .map<UrlMapTest>((value) =>
              UrlMapTest.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (defaultRouteAction != null)
          'defaultRouteAction': defaultRouteAction!.toJson(),
        if (defaultService != null) 'defaultService': defaultService!,
        if (defaultUrlRedirect != null)
          'defaultUrlRedirect': defaultUrlRedirect!.toJson(),
        if (description != null) 'description': description!,
        if (fingerprint != null) 'fingerprint': fingerprint!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (hostRules != null)
          'hostRules': hostRules!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (pathMatchers != null)
          'pathMatchers': pathMatchers!.map((value) => value.toJson()).toList(),
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (tests != null)
          'tests': tests!.map((value) => value.toJson()).toList(),
      };
}

class UrlMapListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapListWarningData();

  UrlMapListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UrlMapListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapListWarning();

  UrlMapListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapListWarningData>((value) => UrlMapListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of UrlMap resources.
class UrlMapList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of UrlMap resources.
  core.List<UrlMap>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  UrlMapListWarning? warning;

  UrlMapList();

  UrlMapList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<UrlMap>((value) =>
              UrlMap.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapReference {
  core.String? urlMap;

  UrlMapReference();

  UrlMapReference.fromJson(core.Map _json) {
    if (_json.containsKey('urlMap')) {
      urlMap = _json['urlMap'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (urlMap != null) 'urlMap': urlMap!,
      };
}

/// Message for the expected URL mappings.
class UrlMapTest {
  /// Description of this test case.
  core.String? description;

  /// The expected output URL evaluated by load balancer containing the scheme,
  /// host, path and query parameters.
  /// For rules that forward requests to backends, the test passes only when
  /// expectedOutputUrl matches the request forwarded by load balancer to
  /// backends.
  ///
  /// For rules with urlRewrite, the test verifies that the forwarded request
  /// matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When
  /// service is specified, expectedOutputUrl\`s scheme is ignored.
  /// For rules with urlRedirect, the test passes only if expectedOutputUrl
  /// matches the URL in the load balancer's redirect response. If urlRedirect
  /// specifies https_redirect, the test passes only if the scheme in
  /// expectedOutputUrl is also set to https. If urlRedirect specifies
  /// strip_query, the test passes only if expectedOutputUrl does not contain
  /// any query parameters.
  /// expectedOutputUrl is optional when service is specified.
  core.String? expectedOutputUrl;

  /// For rules with urlRedirect, the test passes only if
  /// expectedRedirectResponseCode matches the HTTP status code in load
  /// balancer's redirect response.
  /// expectedRedirectResponseCode cannot be set when service is set.
  core.int? expectedRedirectResponseCode;

  /// HTTP headers for this request.
  ///
  /// If headers contains a host header, then host must also match the header
  /// value.
  core.List<UrlMapTestHeader>? headers;

  /// Host portion of the URL.
  ///
  /// If headers contains a host header, then host must also match the header
  /// value.
  core.String? host;

  /// Path portion of the URL.
  core.String? path;

  /// Expected BackendService or BackendBucket resource the given URL should be
  /// mapped to.
  /// service cannot be set if expectedRedirectResponseCode is set.
  core.String? service;

  UrlMapTest();

  UrlMapTest.fromJson(core.Map _json) {
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('expectedOutputUrl')) {
      expectedOutputUrl = _json['expectedOutputUrl'] as core.String;
    }
    if (_json.containsKey('expectedRedirectResponseCode')) {
      expectedRedirectResponseCode =
          _json['expectedRedirectResponseCode'] as core.int;
    }
    if (_json.containsKey('headers')) {
      headers = (_json['headers'] as core.List)
          .map<UrlMapTestHeader>((value) => UrlMapTestHeader.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('host')) {
      host = _json['host'] as core.String;
    }
    if (_json.containsKey('path')) {
      path = _json['path'] as core.String;
    }
    if (_json.containsKey('service')) {
      service = _json['service'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (expectedOutputUrl != null) 'expectedOutputUrl': expectedOutputUrl!,
        if (expectedRedirectResponseCode != null)
          'expectedRedirectResponseCode': expectedRedirectResponseCode!,
        if (headers != null)
          'headers': headers!.map((value) => value.toJson()).toList(),
        if (host != null) 'host': host!,
        if (path != null) 'path': path!,
        if (service != null) 'service': service!,
      };
}

/// HTTP headers used in UrlMapTests.
class UrlMapTestHeader {
  /// Header name.
  core.String? name;

  /// Header value.
  core.String? value;

  UrlMapTestHeader();

  UrlMapTestHeader.fromJson(core.Map _json) {
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Message representing the validation result for a UrlMap.
class UrlMapValidationResult {
  core.List<core.String>? loadErrors;

  /// Whether the given UrlMap can be successfully loaded.
  ///
  /// If false, 'loadErrors' indicates the reasons.
  core.bool? loadSucceeded;
  core.List<TestFailure>? testFailures;

  /// If successfully loaded, this field indicates whether the test passed.
  ///
  /// If false, 'testFailures's indicate the reason of failure.
  core.bool? testPassed;

  UrlMapValidationResult();

  UrlMapValidationResult.fromJson(core.Map _json) {
    if (_json.containsKey('loadErrors')) {
      loadErrors = (_json['loadErrors'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('loadSucceeded')) {
      loadSucceeded = _json['loadSucceeded'] as core.bool;
    }
    if (_json.containsKey('testFailures')) {
      testFailures = (_json['testFailures'] as core.List)
          .map<TestFailure>((value) => TestFailure.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('testPassed')) {
      testPassed = _json['testPassed'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (loadErrors != null) 'loadErrors': loadErrors!,
        if (loadSucceeded != null) 'loadSucceeded': loadSucceeded!,
        if (testFailures != null)
          'testFailures': testFailures!.map((value) => value.toJson()).toList(),
        if (testPassed != null) 'testPassed': testPassed!,
      };
}

class UrlMapsAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapsAggregatedListWarningData();

  UrlMapsAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UrlMapsAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapsAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapsAggregatedListWarning();

  UrlMapsAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapsAggregatedListWarningData>((value) =>
              UrlMapsAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UrlMapsAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of UrlMapsScopedList resources.
  core.Map<core.String, UrlMapsScopedList>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  UrlMapsAggregatedListWarning? warning;

  UrlMapsAggregatedList();

  UrlMapsAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          UrlMapsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapsAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UrlMapsScopedListWarningData();

  UrlMapsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of backend services when the
/// list is empty.
class UrlMapsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UrlMapsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UrlMapsScopedListWarning();

  UrlMapsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UrlMapsScopedListWarningData>((value) =>
              UrlMapsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UrlMapsScopedList {
  /// A list of UrlMaps contained in this scope.
  core.List<UrlMap>? urlMaps;

  /// Informational warning which replaces the list of backend services when the
  /// list is empty.
  UrlMapsScopedListWarning? warning;

  UrlMapsScopedList();

  UrlMapsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('urlMaps')) {
      urlMaps = (_json['urlMaps'] as core.List)
          .map<UrlMap>((value) =>
              UrlMap.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = UrlMapsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (urlMaps != null)
          'urlMaps': urlMaps!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class UrlMapsValidateRequest {
  /// Content of the UrlMap to be validated.
  UrlMap? resource;

  UrlMapsValidateRequest();

  UrlMapsValidateRequest.fromJson(core.Map _json) {
    if (_json.containsKey('resource')) {
      resource = UrlMap.fromJson(
          _json['resource'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (resource != null) 'resource': resource!.toJson(),
      };
}

class UrlMapsValidateResponse {
  UrlMapValidationResult? result;

  UrlMapsValidateResponse();

  UrlMapsValidateResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = UrlMapValidationResult.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

/// The spec for modifying the path before sending the request to the matched
/// backend service.
class UrlRewrite {
  /// Prior to forwarding the request to the selected service, the request's
  /// host header is replaced with contents of hostRewrite.
  /// The value must be between 1 and 255 characters.
  core.String? hostRewrite;

  /// Prior to forwarding the request to the selected backend service, the
  /// matching portion of the request's path is replaced by pathPrefixRewrite.
  /// The value must be between 1 and 1024 characters.
  core.String? pathPrefixRewrite;

  UrlRewrite();

  UrlRewrite.fromJson(core.Map _json) {
    if (_json.containsKey('hostRewrite')) {
      hostRewrite = _json['hostRewrite'] as core.String;
    }
    if (_json.containsKey('pathPrefixRewrite')) {
      pathPrefixRewrite = _json['pathPrefixRewrite'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (hostRewrite != null) 'hostRewrite': hostRewrite!,
        if (pathPrefixRewrite != null) 'pathPrefixRewrite': pathPrefixRewrite!,
      };
}

/// Subnetwork which the current user has compute.subnetworks.use permission on.
class UsableSubnetwork {
  /// The range of internal addresses that are owned by this subnetwork.
  core.String? ipCidrRange;

  /// Network URL.
  core.String? network;

  /// Secondary IP ranges.
  core.List<UsableSubnetworkSecondaryRange>? secondaryIpRanges;

  /// Subnetwork URL.
  core.String? subnetwork;

  UsableSubnetwork();

  UsableSubnetwork.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('secondaryIpRanges')) {
      secondaryIpRanges = (_json['secondaryIpRanges'] as core.List)
          .map<UsableSubnetworkSecondaryRange>((value) =>
              UsableSubnetworkSecondaryRange.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('subnetwork')) {
      subnetwork = _json['subnetwork'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (network != null) 'network': network!,
        if (secondaryIpRanges != null)
          'secondaryIpRanges':
              secondaryIpRanges!.map((value) => value.toJson()).toList(),
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

/// Secondary IP range of a usable subnetwork.
class UsableSubnetworkSecondaryRange {
  /// The range of IP addresses belonging to this subnetwork secondary range.
  core.String? ipCidrRange;

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  ///
  /// The name must be 1-63 characters long, and comply with RFC1035. The name
  /// must be unique within the subnetwork.
  core.String? rangeName;

  UsableSubnetworkSecondaryRange();

  UsableSubnetworkSecondaryRange.fromJson(core.Map _json) {
    if (_json.containsKey('ipCidrRange')) {
      ipCidrRange = _json['ipCidrRange'] as core.String;
    }
    if (_json.containsKey('rangeName')) {
      rangeName = _json['rangeName'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (ipCidrRange != null) 'ipCidrRange': ipCidrRange!,
        if (rangeName != null) 'rangeName': rangeName!,
      };
}

class UsableSubnetworksAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  UsableSubnetworksAggregatedListWarningData();

  UsableSubnetworksAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class UsableSubnetworksAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<UsableSubnetworksAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  UsableSubnetworksAggregatedListWarning();

  UsableSubnetworksAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<UsableSubnetworksAggregatedListWarningData>((value) =>
              UsableSubnetworksAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class UsableSubnetworksAggregatedList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// \[Output\] A list of usable subnetwork URLs.
  core.List<UsableSubnetwork>? items;

  /// Type of resource.
  ///
  /// Always compute#usableSubnetworksAggregatedList for aggregated lists of
  /// usable subnetworks.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  UsableSubnetworksAggregatedListWarning? warning;

  UsableSubnetworksAggregatedList();

  UsableSubnetworksAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<UsableSubnetwork>((value) => UsableSubnetwork.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = UsableSubnetworksAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// The location in Cloud Storage and naming method of the daily usage report.
///
/// Contains bucket_name and report_name prefix.
class UsageExportLocation {
  /// The name of an existing bucket in Cloud Storage where the usage report
  /// object is stored.
  ///
  /// The Google Service Account is granted write access to this bucket. This
  /// can either be the bucket name by itself, such as example-bucket, or the
  /// bucket name with gs:// or https://storage.googleapis.com/ in front of it,
  /// such as gs://example-bucket.
  core.String? bucketName;

  /// An optional prefix for the name of the usage report object stored in
  /// bucketName.
  ///
  /// If not supplied, defaults to usage. The report is stored as a CSV file
  /// named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the day of the
  /// usage according to Pacific Time. If you supply a prefix, it should conform
  /// to Cloud Storage object naming conventions.
  core.String? reportNamePrefix;

  UsageExportLocation();

  UsageExportLocation.fromJson(core.Map _json) {
    if (_json.containsKey('bucketName')) {
      bucketName = _json['bucketName'] as core.String;
    }
    if (_json.containsKey('reportNamePrefix')) {
      reportNamePrefix = _json['reportNamePrefix'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bucketName != null) 'bucketName': bucketName!,
        if (reportNamePrefix != null) 'reportNamePrefix': reportNamePrefix!,
      };
}

/// Contain information of Nat mapping for a VM endpoint (i.e., NIC).
class VmEndpointNatMappings {
  /// Name of the VM instance which the endpoint belongs to
  core.String? instanceName;
  core.List<VmEndpointNatMappingsInterfaceNatMappings>? interfaceNatMappings;

  VmEndpointNatMappings();

  VmEndpointNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey('instanceName')) {
      instanceName = _json['instanceName'] as core.String;
    }
    if (_json.containsKey('interfaceNatMappings')) {
      interfaceNatMappings = (_json['interfaceNatMappings'] as core.List)
          .map<VmEndpointNatMappingsInterfaceNatMappings>((value) =>
              VmEndpointNatMappingsInterfaceNatMappings.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceName != null) 'instanceName': instanceName!,
        if (interfaceNatMappings != null)
          'interfaceNatMappings':
              interfaceNatMappings!.map((value) => value.toJson()).toList(),
      };
}

/// Contain information of Nat mapping for an interface of this endpoint.
class VmEndpointNatMappingsInterfaceNatMappings {
  /// List of all drain IP:port-range mappings assigned to this interface.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? drainNatIpPortRanges;

  /// A list of all IP:port-range mappings assigned to this interface.
  ///
  /// These ranges are inclusive, that is, both the first and the last ports can
  /// be used for NAT. Example: \["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"\].
  core.List<core.String>? natIpPortRanges;

  /// Total number of drain ports across all NAT IPs allocated to this
  /// interface.
  ///
  /// It equals to the aggregated port number in the field
  /// drain_nat_ip_port_ranges.
  core.int? numTotalDrainNatPorts;

  /// Total number of ports across all NAT IPs allocated to this interface.
  ///
  /// It equals to the aggregated port number in the field nat_ip_port_ranges.
  core.int? numTotalNatPorts;

  /// Alias IP range for this interface endpoint.
  ///
  /// It will be a private (RFC 1918) IP range. Examples: "10.33.4.55/32", or
  /// "192.168.5.0/24".
  core.String? sourceAliasIpRange;

  /// Primary IP of the VM for this NIC.
  core.String? sourceVirtualIp;

  VmEndpointNatMappingsInterfaceNatMappings();

  VmEndpointNatMappingsInterfaceNatMappings.fromJson(core.Map _json) {
    if (_json.containsKey('drainNatIpPortRanges')) {
      drainNatIpPortRanges = (_json['drainNatIpPortRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('natIpPortRanges')) {
      natIpPortRanges = (_json['natIpPortRanges'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('numTotalDrainNatPorts')) {
      numTotalDrainNatPorts = _json['numTotalDrainNatPorts'] as core.int;
    }
    if (_json.containsKey('numTotalNatPorts')) {
      numTotalNatPorts = _json['numTotalNatPorts'] as core.int;
    }
    if (_json.containsKey('sourceAliasIpRange')) {
      sourceAliasIpRange = _json['sourceAliasIpRange'] as core.String;
    }
    if (_json.containsKey('sourceVirtualIp')) {
      sourceVirtualIp = _json['sourceVirtualIp'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (drainNatIpPortRanges != null)
          'drainNatIpPortRanges': drainNatIpPortRanges!,
        if (natIpPortRanges != null) 'natIpPortRanges': natIpPortRanges!,
        if (numTotalDrainNatPorts != null)
          'numTotalDrainNatPorts': numTotalDrainNatPorts!,
        if (numTotalNatPorts != null) 'numTotalNatPorts': numTotalNatPorts!,
        if (sourceAliasIpRange != null)
          'sourceAliasIpRange': sourceAliasIpRange!,
        if (sourceVirtualIp != null) 'sourceVirtualIp': sourceVirtualIp!,
      };
}

class VmEndpointNatMappingsListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VmEndpointNatMappingsListWarningData();

  VmEndpointNatMappingsListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VmEndpointNatMappingsListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VmEndpointNatMappingsListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VmEndpointNatMappingsListWarning();

  VmEndpointNatMappingsListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VmEndpointNatMappingsListWarningData>((value) =>
              VmEndpointNatMappingsListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VmEndpointNatMappings.
class VmEndpointNatMappingsList {
  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#vmEndpointNatMappingsList for lists of Nat mappings of VM
  /// endpoints.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// A list of Nat mapping information of VM endpoints.
  ///
  /// Output only.
  core.List<VmEndpointNatMappings>? result;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VmEndpointNatMappingsListWarning? warning;

  VmEndpointNatMappingsList();

  VmEndpointNatMappingsList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('result')) {
      result = (_json['result'] as core.List)
          .map<VmEndpointNatMappings>((value) => VmEndpointNatMappings.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VmEndpointNatMappingsListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (result != null)
          'result': result!.map((value) => value.toJson()).toList(),
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a HA VPN gateway.
///
/// HA VPN is a high-availability (HA) Cloud VPN solution that lets you securely
/// connect your on-premises network to your Google Cloud Virtual Private Cloud
/// network through an IPsec VPN connection in a single region.
///
/// For more information about Cloud HA VPN solutions, see Cloud VPN topologies
/// . (== resource_for {$api_version}.vpnGateways ==)
class VpnGateway {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// A fingerprint for the labels being applied to this VpnGateway, which is
  /// essentially a hash of the labels set used for optimistic locking.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels, otherwise
  /// the request will fail with error 412 conditionNotMet.
  ///
  /// To see the latest fingerprint, make a get() request to retrieve an
  /// VpnGateway.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Labels for this resource.
  ///
  /// These can only be added or modified by the setLabels method. Each label
  /// key/value pair must comply with RFC1035. Label values may be empty.
  core.Map<core.String, core.String>? labels;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the network to which this VPN gateway is attached.
  ///
  /// Provided by the client when the VPN gateway is created.
  core.String? network;

  /// URL of the region where the VPN gateway resides.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// A list of interfaces on this VPN gateway.
  core.List<VpnGatewayVpnGatewayInterface>? vpnInterfaces;

  VpnGateway();

  VpnGateway.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('network')) {
      network = _json['network'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('vpnInterfaces')) {
      vpnInterfaces = (_json['vpnInterfaces'] as core.List)
          .map<VpnGatewayVpnGatewayInterface>((value) =>
              VpnGatewayVpnGatewayInterface.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (vpnInterfaces != null)
          'vpnInterfaces':
              vpnInterfaces!.map((value) => value.toJson()).toList(),
      };
}

class VpnGatewayAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewayAggregatedListWarningData();

  VpnGatewayAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnGatewayAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewayAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewayAggregatedListWarning();

  VpnGatewayAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewayAggregatedListWarningData>((value) =>
              VpnGatewayAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnGatewayAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnGateway resources.
  core.Map<core.String, VpnGatewaysScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  VpnGatewayAggregatedListWarning? warning;

  VpnGatewayAggregatedList();

  VpnGatewayAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          VpnGatewaysScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewayAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnGatewayListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewayListWarningData();

  VpnGatewayListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnGatewayListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewayListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewayListWarning();

  VpnGatewayListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewayListWarningData>((value) =>
              VpnGatewayListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VpnGateway resources.
class VpnGatewayList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnGateway resources.
  core.List<VpnGateway>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnGateway for VPN gateways.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VpnGatewayListWarning? warning;

  VpnGatewayList();

  VpnGatewayList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<VpnGateway>((value) =>
              VpnGateway.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewayListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnGatewayStatus {
  /// List of VPN connection for this VpnGateway.
  core.List<VpnGatewayStatusVpnConnection>? vpnConnections;

  VpnGatewayStatus();

  VpnGatewayStatus.fromJson(core.Map _json) {
    if (_json.containsKey('vpnConnections')) {
      vpnConnections = (_json['vpnConnections'] as core.List)
          .map<VpnGatewayStatusVpnConnection>((value) =>
              VpnGatewayStatusVpnConnection.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnConnections != null)
          'vpnConnections':
              vpnConnections!.map((value) => value.toJson()).toList(),
      };
}

/// Describes the high availability requirement state for the VPN connection
/// between this Cloud VPN gateway and a peer gateway.
class VpnGatewayStatusHighAvailabilityRequirementState {
  /// Indicates the high availability requirement state for the VPN connection.
  ///
  /// Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
  /// Possible string values are:
  /// - "CONNECTION_REDUNDANCY_MET"
  /// - "CONNECTION_REDUNDANCY_NOT_MET"
  core.String? state;

  /// Indicates the reason why the VPN connection does not meet the high
  /// availability redundancy criteria/requirement.
  ///
  /// Valid values is INCOMPLETE_TUNNELS_COVERAGE.
  /// Possible string values are:
  /// - "INCOMPLETE_TUNNELS_COVERAGE"
  core.String? unsatisfiedReason;

  VpnGatewayStatusHighAvailabilityRequirementState();

  VpnGatewayStatusHighAvailabilityRequirementState.fromJson(core.Map _json) {
    if (_json.containsKey('state')) {
      state = _json['state'] as core.String;
    }
    if (_json.containsKey('unsatisfiedReason')) {
      unsatisfiedReason = _json['unsatisfiedReason'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (state != null) 'state': state!,
        if (unsatisfiedReason != null) 'unsatisfiedReason': unsatisfiedReason!,
      };
}

/// Contains some information about a VPN tunnel.
class VpnGatewayStatusTunnel {
  /// The VPN gateway interface this VPN tunnel is associated with.
  core.int? localGatewayInterface;

  /// The peer gateway interface this VPN tunnel is connected to, the peer
  /// gateway could either be an external VPN gateway or GCP VPN gateway.
  core.int? peerGatewayInterface;

  /// URL reference to the VPN tunnel.
  core.String? tunnelUrl;

  VpnGatewayStatusTunnel();

  VpnGatewayStatusTunnel.fromJson(core.Map _json) {
    if (_json.containsKey('localGatewayInterface')) {
      localGatewayInterface = _json['localGatewayInterface'] as core.int;
    }
    if (_json.containsKey('peerGatewayInterface')) {
      peerGatewayInterface = _json['peerGatewayInterface'] as core.int;
    }
    if (_json.containsKey('tunnelUrl')) {
      tunnelUrl = _json['tunnelUrl'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (localGatewayInterface != null)
          'localGatewayInterface': localGatewayInterface!,
        if (peerGatewayInterface != null)
          'peerGatewayInterface': peerGatewayInterface!,
        if (tunnelUrl != null) 'tunnelUrl': tunnelUrl!,
      };
}

/// A VPN connection contains all VPN tunnels connected from this VpnGateway to
/// the same peer gateway.
///
/// The peer gateway could either be a external VPN gateway or GCP VPN gateway.
class VpnGatewayStatusVpnConnection {
  /// URL reference to the peer external VPN gateways to which the VPN tunnels
  /// in this VPN connection are connected.
  ///
  /// This field is mutually exclusive with peer_gcp_gateway.
  core.String? peerExternalGateway;

  /// URL reference to the peer side VPN gateways to which the VPN tunnels in
  /// this VPN connection are connected.
  ///
  /// This field is mutually exclusive with peer_gcp_gateway.
  core.String? peerGcpGateway;

  /// HighAvailabilityRequirementState for the VPN connection.
  VpnGatewayStatusHighAvailabilityRequirementState? state;

  /// List of VPN tunnels that are in this VPN connection.
  core.List<VpnGatewayStatusTunnel>? tunnels;

  VpnGatewayStatusVpnConnection();

  VpnGatewayStatusVpnConnection.fromJson(core.Map _json) {
    if (_json.containsKey('peerExternalGateway')) {
      peerExternalGateway = _json['peerExternalGateway'] as core.String;
    }
    if (_json.containsKey('peerGcpGateway')) {
      peerGcpGateway = _json['peerGcpGateway'] as core.String;
    }
    if (_json.containsKey('state')) {
      state = VpnGatewayStatusHighAvailabilityRequirementState.fromJson(
          _json['state'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('tunnels')) {
      tunnels = (_json['tunnels'] as core.List)
          .map<VpnGatewayStatusTunnel>((value) =>
              VpnGatewayStatusTunnel.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (peerExternalGateway != null)
          'peerExternalGateway': peerExternalGateway!,
        if (peerGcpGateway != null) 'peerGcpGateway': peerGcpGateway!,
        if (state != null) 'state': state!.toJson(),
        if (tunnels != null)
          'tunnels': tunnels!.map((value) => value.toJson()).toList(),
      };
}

/// A VPN gateway interface.
class VpnGatewayVpnGatewayInterface {
  /// The numeric ID of this VPN gateway interface.
  core.int? id;

  /// The external IP address for this VPN gateway interface.
  ///
  /// Output only.
  core.String? ipAddress;

  VpnGatewayVpnGatewayInterface();

  VpnGatewayVpnGatewayInterface.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.int;
    }
    if (_json.containsKey('ipAddress')) {
      ipAddress = _json['ipAddress'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (ipAddress != null) 'ipAddress': ipAddress!,
      };
}

class VpnGatewaysGetStatusResponse {
  VpnGatewayStatus? result;

  VpnGatewaysGetStatusResponse();

  VpnGatewaysGetStatusResponse.fromJson(core.Map _json) {
    if (_json.containsKey('result')) {
      result = VpnGatewayStatus.fromJson(
          _json['result'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (result != null) 'result': result!.toJson(),
      };
}

class VpnGatewaysScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnGatewaysScopedListWarningData();

  VpnGatewaysScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
///
/// Output only.
class VpnGatewaysScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnGatewaysScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnGatewaysScopedListWarning();

  VpnGatewaysScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnGatewaysScopedListWarningData>((value) =>
              VpnGatewaysScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnGatewaysScopedList {
  /// A list of VPN gateways contained in this scope.
  ///
  /// Output only.
  core.List<VpnGateway>? vpnGateways;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  ///
  /// Output only.
  VpnGatewaysScopedListWarning? warning;

  VpnGatewaysScopedList();

  VpnGatewaysScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('vpnGateways')) {
      vpnGateways = (_json['vpnGateways'] as core.List)
          .map<VpnGateway>((value) =>
              VpnGateway.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnGatewaysScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnGateways != null)
          'vpnGateways': vpnGateways!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Represents a Cloud VPN Tunnel resource.
///
/// For more information about VPN, read the  the Cloud VPN Overview.
///
/// (== resource_for {$api_version}.vpnTunnels ==)
class VpnTunnel {
  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// An optional description of this resource.
  ///
  /// Provide this property when you create the resource.
  core.String? description;

  /// Detailed status message for the VPN tunnel.
  ///
  /// Output only.
  core.String? detailedStatus;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// IKE protocol version to use when establishing the VPN tunnel with the peer
  /// VPN gateway.
  ///
  /// Acceptable IKE versions are 1 or 2. The default version is 2.
  core.int? ikeVersion;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// Local traffic selector to use when establishing the VPN tunnel with the
  /// peer VPN gateway.
  ///
  /// The value should be a CIDR formatted string, for example: 192.168.0.0/16.
  /// The ranges must be disjoint. Only IPv4 is supported.
  core.List<core.String>? localTrafficSelector;

  /// Name of the resource.
  ///
  /// Provided by the client when the resource is created. The name must be 1-63
  /// characters long, and comply with RFC1035. Specifically, the name must be
  /// 1-63 characters long and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a
  /// lowercase letter, and all following characters must be a dash, lowercase
  /// letter, or digit, except the last character, which cannot be a dash.
  core.String? name;

  /// URL of the peer side external VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created. This field is
  /// exclusive with the field peerGcpGateway.
  core.String? peerExternalGateway;

  /// The interface ID of the external VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created.
  core.int? peerExternalGatewayInterface;

  /// URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
  /// connected.
  ///
  /// Provided by the client when the VPN tunnel is created. This field can be
  /// used when creating highly available VPN from VPC network to VPC network,
  /// the field is exclusive with the field peerExternalGateway. If provided,
  /// the VPN tunnel will automatically use the same vpnGatewayInterface ID in
  /// the peer GCP VPN gateway.
  core.String? peerGcpGateway;

  /// IP address of the peer VPN gateway.
  ///
  /// Only IPv4 is supported.
  core.String? peerIp;

  /// URL of the region where the VPN tunnel resides.
  ///
  /// You must specify this field as part of the HTTP request URL. It is not
  /// settable as a field in the request body.
  ///
  /// Output only.
  core.String? region;

  /// Remote traffic selectors to use when establishing the VPN tunnel with the
  /// peer VPN gateway.
  ///
  /// The value should be a CIDR formatted string, for example: 192.168.0.0/16.
  /// The ranges should be disjoint. Only IPv4 is supported.
  core.List<core.String>? remoteTrafficSelector;

  /// URL of the router resource to be used for dynamic routing.
  core.String? router;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Shared secret used to set the secure session between the Cloud VPN gateway
  /// and the peer VPN gateway.
  core.String? sharedSecret;

  /// Hash of the shared secret.
  core.String? sharedSecretHash;

  /// The status of the VPN tunnel, which can be one of the following:
  /// - PROVISIONING: Resource is being allocated for the VPN tunnel.
  ///
  ///
  /// - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from
  /// the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route
  /// resources are needed to setup the VPN tunnel.
  /// - FIRST_HANDSHAKE: Successful first handshake with the peer VPN.
  /// - ESTABLISHED: Secure session is successfully established with the peer
  /// VPN.
  /// - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS
  /// - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret).
  /// - NEGOTIATION_FAILURE: Handshake failed.
  /// - DEPROVISIONING: Resources are being deallocated for the VPN tunnel.
  /// - FAILED: Tunnel creation has failed and the tunnel is not ready to be
  /// used.
  /// - NO_INCOMING_PACKETS: No incoming packets from peer.
  /// - REJECTED: Tunnel configuration was rejected, can be result of being
  /// blacklisted.
  /// - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all
  /// required resources.
  /// - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for
  /// Classic VPN tunnels or the project is in frozen state.
  /// - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably
  /// behind NAT.
  /// - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an
  /// HA-VPN tunnel.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ALLOCATING_RESOURCES"
  /// - "AUTHORIZATION_ERROR"
  /// - "DEPROVISIONING"
  /// - "ESTABLISHED"
  /// - "FAILED"
  /// - "FIRST_HANDSHAKE"
  /// - "NEGOTIATION_FAILURE"
  /// - "NETWORK_ERROR"
  /// - "NO_INCOMING_PACKETS"
  /// - "PROVISIONING"
  /// - "REJECTED"
  /// - "STOPPED"
  /// - "WAITING_FOR_FULL_CONFIG"
  core.String? status;

  /// URL of the Target VPN gateway with which this VPN tunnel is associated.
  ///
  /// Provided by the client when the VPN tunnel is created.
  core.String? targetVpnGateway;

  /// URL of the VPN gateway with which this VPN tunnel is associated.
  ///
  /// Provided by the client when the VPN tunnel is created. This must be used
  /// (instead of target_vpn_gateway) if a High Availability VPN gateway
  /// resource is created.
  core.String? vpnGateway;

  /// The interface ID of the VPN gateway with which this VPN tunnel is
  /// associated.
  core.int? vpnGatewayInterface;

  VpnTunnel();

  VpnTunnel.fromJson(core.Map _json) {
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('detailedStatus')) {
      detailedStatus = _json['detailedStatus'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('ikeVersion')) {
      ikeVersion = _json['ikeVersion'] as core.int;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('localTrafficSelector')) {
      localTrafficSelector = (_json['localTrafficSelector'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('peerExternalGateway')) {
      peerExternalGateway = _json['peerExternalGateway'] as core.String;
    }
    if (_json.containsKey('peerExternalGatewayInterface')) {
      peerExternalGatewayInterface =
          _json['peerExternalGatewayInterface'] as core.int;
    }
    if (_json.containsKey('peerGcpGateway')) {
      peerGcpGateway = _json['peerGcpGateway'] as core.String;
    }
    if (_json.containsKey('peerIp')) {
      peerIp = _json['peerIp'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('remoteTrafficSelector')) {
      remoteTrafficSelector = (_json['remoteTrafficSelector'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('router')) {
      router = _json['router'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('sharedSecret')) {
      sharedSecret = _json['sharedSecret'] as core.String;
    }
    if (_json.containsKey('sharedSecretHash')) {
      sharedSecretHash = _json['sharedSecretHash'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('targetVpnGateway')) {
      targetVpnGateway = _json['targetVpnGateway'] as core.String;
    }
    if (_json.containsKey('vpnGateway')) {
      vpnGateway = _json['vpnGateway'] as core.String;
    }
    if (_json.containsKey('vpnGatewayInterface')) {
      vpnGatewayInterface = _json['vpnGatewayInterface'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (description != null) 'description': description!,
        if (detailedStatus != null) 'detailedStatus': detailedStatus!,
        if (id != null) 'id': id!,
        if (ikeVersion != null) 'ikeVersion': ikeVersion!,
        if (kind != null) 'kind': kind!,
        if (localTrafficSelector != null)
          'localTrafficSelector': localTrafficSelector!,
        if (name != null) 'name': name!,
        if (peerExternalGateway != null)
          'peerExternalGateway': peerExternalGateway!,
        if (peerExternalGatewayInterface != null)
          'peerExternalGatewayInterface': peerExternalGatewayInterface!,
        if (peerGcpGateway != null) 'peerGcpGateway': peerGcpGateway!,
        if (peerIp != null) 'peerIp': peerIp!,
        if (region != null) 'region': region!,
        if (remoteTrafficSelector != null)
          'remoteTrafficSelector': remoteTrafficSelector!,
        if (router != null) 'router': router!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (sharedSecret != null) 'sharedSecret': sharedSecret!,
        if (sharedSecretHash != null) 'sharedSecretHash': sharedSecretHash!,
        if (status != null) 'status': status!,
        if (targetVpnGateway != null) 'targetVpnGateway': targetVpnGateway!,
        if (vpnGateway != null) 'vpnGateway': vpnGateway!,
        if (vpnGatewayInterface != null)
          'vpnGatewayInterface': vpnGatewayInterface!,
      };
}

class VpnTunnelAggregatedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelAggregatedListWarningData();

  VpnTunnelAggregatedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnTunnelAggregatedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelAggregatedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelAggregatedListWarning();

  VpnTunnelAggregatedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelAggregatedListWarningData>((value) =>
              VpnTunnelAggregatedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnTunnelAggregatedList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnTunnelsScopedList resources.
  core.Map<core.String, VpnTunnelsScopedList>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Unreachable resources.
  ///
  /// Output only.
  core.List<core.String>? unreachables;

  /// Informational warning message.
  ///
  /// Output only.
  VpnTunnelAggregatedListWarning? warning;

  VpnTunnelAggregatedList();

  VpnTunnelAggregatedList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          VpnTunnelsScopedList.fromJson(
              item as core.Map<core.String, core.dynamic>),
        ),
      );
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('unreachables')) {
      unreachables = (_json['unreachables'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelAggregatedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((key, item) => core.MapEntry(key, item.toJson())),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (unreachables != null) 'unreachables': unreachables!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnTunnelListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelListWarningData();

  VpnTunnelListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class VpnTunnelListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelListWarning();

  VpnTunnelListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelListWarningData>((value) =>
              VpnTunnelListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of VpnTunnel resources.
class VpnTunnelList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of VpnTunnel resources.
  core.List<VpnTunnel>? items;

  /// Type of resource.
  ///
  /// Always compute#vpnTunnel for VPN tunnels.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  VpnTunnelListWarning? warning;

  VpnTunnelList();

  VpnTunnelList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<VpnTunnel>((value) =>
              VpnTunnel.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class VpnTunnelsScopedListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  VpnTunnelsScopedListWarningData();

  VpnTunnelsScopedListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning which replaces the list of addresses when the list is
/// empty.
class VpnTunnelsScopedListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<VpnTunnelsScopedListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  VpnTunnelsScopedListWarning();

  VpnTunnelsScopedListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<VpnTunnelsScopedListWarningData>((value) =>
              VpnTunnelsScopedListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class VpnTunnelsScopedList {
  /// A list of VPN tunnels contained in this scope.
  core.List<VpnTunnel>? vpnTunnels;

  /// Informational warning which replaces the list of addresses when the list
  /// is empty.
  VpnTunnelsScopedListWarning? warning;

  VpnTunnelsScopedList();

  VpnTunnelsScopedList.fromJson(core.Map _json) {
    if (_json.containsKey('vpnTunnels')) {
      vpnTunnels = (_json['vpnTunnels'] as core.List)
          .map<VpnTunnel>((value) =>
              VpnTunnel.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('warning')) {
      warning = VpnTunnelsScopedListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (vpnTunnels != null)
          'vpnTunnels': vpnTunnels!.map((value) => value.toJson()).toList(),
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class WafExpressionSet {
  /// A list of alternate IDs.
  ///
  /// The format should be: - E.g. XSS-stable Generic suffix like "stable" is
  /// particularly useful if a policy likes to avail newer set of expressions
  /// without having to change the policy. A given alias name can't be used for
  /// more than one entity set.
  core.List<core.String>? aliases;

  /// List of available expressions.
  core.List<WafExpressionSetExpression>? expressions;

  /// Google specified expression set ID.
  ///
  /// The format should be: - E.g. XSS-20170329
  core.String? id;

  WafExpressionSet();

  WafExpressionSet.fromJson(core.Map _json) {
    if (_json.containsKey('aliases')) {
      aliases = (_json['aliases'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('expressions')) {
      expressions = (_json['expressions'] as core.List)
          .map<WafExpressionSetExpression>((value) =>
              WafExpressionSetExpression.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (aliases != null) 'aliases': aliases!,
        if (expressions != null)
          'expressions': expressions!.map((value) => value.toJson()).toList(),
        if (id != null) 'id': id!,
      };
}

class WafExpressionSetExpression {
  /// Expression ID should uniquely identify the origin of the expression.
  ///
  /// E.g. owasp-crs-v020901-id973337 identifies Owasp core rule set version
  /// 2.9.1 rule id 973337. The ID could be used to determine the individual
  /// attack definition that has been detected. It could also be used to exclude
  /// it from the policy in case of false positive.
  core.String? id;

  WafExpressionSetExpression();

  WafExpressionSetExpression.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
      };
}

/// In contrast to a single BackendService in HttpRouteAction to which all
/// matching traffic is directed to, WeightedBackendService allows traffic to be
/// split across multiple BackendServices.
///
/// The volume of traffic for each BackendService is proportional to the weight
/// specified in each WeightedBackendService
class WeightedBackendService {
  /// The full or partial URL to the default BackendService resource.
  ///
  /// Before forwarding the request to backendService, the loadbalancer applies
  /// any relevant headerActions specified as part of this backendServiceWeight.
  core.String? backendService;

  /// Specifies changes to request and response headers that need to take effect
  /// for the selected backendService.
  /// headerAction specified here take effect before headerAction in the
  /// enclosing HttpRouteRule, PathMatcher and UrlMap.
  /// Note that headerAction is not supported for Loadbalancers that have their
  /// loadBalancingScheme set to EXTERNAL.
  /// Not supported when the URL map is bound to target gRPC proxy that has
  /// validateForProxyless field set to true.
  HttpHeaderAction? headerAction;

  /// Specifies the fraction of traffic sent to backendService, computed as
  /// weight / (sum of all weightedBackendService weights in routeAction) .
  /// The selection of a backend service is determined only for new traffic.
  ///
  /// Once a user's request has been directed to a backendService, subsequent
  /// requests will be sent to the same backendService as determined by the
  /// BackendService's session affinity policy.
  /// The value must be between 0 and 1000
  core.int? weight;

  WeightedBackendService();

  WeightedBackendService.fromJson(core.Map _json) {
    if (_json.containsKey('backendService')) {
      backendService = _json['backendService'] as core.String;
    }
    if (_json.containsKey('headerAction')) {
      headerAction = HttpHeaderAction.fromJson(
          _json['headerAction'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('weight')) {
      weight = _json['weight'] as core.int;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (backendService != null) 'backendService': backendService!,
        if (headerAction != null) 'headerAction': headerAction!.toJson(),
        if (weight != null) 'weight': weight!,
      };
}

class XpnHostListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  XpnHostListWarningData();

  XpnHostListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class XpnHostListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<XpnHostListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  XpnHostListWarning();

  XpnHostListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<XpnHostListWarningData>((value) =>
              XpnHostListWarningData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

class XpnHostList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of shared VPC host project URLs.
  ///
  /// Output only.
  core.List<Project>? items;

  /// Type of resource.
  ///
  /// Always compute#xpnHostList for lists of shared VPC hosts.
  ///
  /// Output only.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  XpnHostListWarning? warning;

  XpnHostList();

  XpnHostList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Project>((value) =>
              Project.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = XpnHostListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

/// Service resource (a.k.a service project) ID.
class XpnResourceId {
  /// The ID of the service resource.
  ///
  /// In the case of projects, this field supports project id (e.g.,
  /// my-project-123) and project number (e.g. 12345678).
  core.String? id;

  /// The type of the service resource.
  /// Possible string values are:
  /// - "PROJECT"
  /// - "XPN_RESOURCE_TYPE_UNSPECIFIED"
  core.String? type;

  XpnResourceId();

  XpnResourceId.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('type')) {
      type = _json['type'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (type != null) 'type': type!,
      };
}

/// Represents a Zone resource.
///
/// A zone is a deployment area.
///
/// These deployment areas are subsets of a region. For example the zone
/// us-east1-a is located in the us-east1 region. For more information, read
/// Regions and Zones. (== resource_for {$api_version}.zones ==)
class Zone {
  /// Available cpu/platform selections for the zone.
  ///
  /// Output only.
  core.List<core.String>? availableCpuPlatforms;

  /// Creation timestamp in RFC3339 text format.
  ///
  /// Output only.
  core.String? creationTimestamp;

  /// The deprecation status associated with this zone.
  ///
  /// Output only.
  DeprecationStatus? deprecated;

  /// Textual description of the resource.
  ///
  /// Output only.
  core.String? description;

  /// The unique identifier for the resource.
  ///
  /// This identifier is defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// Type of the resource.
  ///
  /// Always compute#zone for zones.
  ///
  /// Output only.
  core.String? kind;

  /// Name of the resource.
  ///
  /// Output only.
  core.String? name;

  /// Full URL reference to the region which hosts the zone.
  ///
  /// Output only.
  core.String? region;

  /// Server-defined URL for the resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Status of the zone, either UP or DOWN.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DOWN"
  /// - "UP"
  core.String? status;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? supportsPzs;

  Zone();

  Zone.fromJson(core.Map _json) {
    if (_json.containsKey('availableCpuPlatforms')) {
      availableCpuPlatforms = (_json['availableCpuPlatforms'] as core.List)
          .map<core.String>((value) => value as core.String)
          .toList();
    }
    if (_json.containsKey('creationTimestamp')) {
      creationTimestamp = _json['creationTimestamp'] as core.String;
    }
    if (_json.containsKey('deprecated')) {
      deprecated = DeprecationStatus.fromJson(
          _json['deprecated'] as core.Map<core.String, core.dynamic>);
    }
    if (_json.containsKey('description')) {
      description = _json['description'] as core.String;
    }
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('name')) {
      name = _json['name'] as core.String;
    }
    if (_json.containsKey('region')) {
      region = _json['region'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('status')) {
      status = _json['status'] as core.String;
    }
    if (_json.containsKey('supportsPzs')) {
      supportsPzs = _json['supportsPzs'] as core.bool;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (availableCpuPlatforms != null)
          'availableCpuPlatforms': availableCpuPlatforms!,
        if (creationTimestamp != null) 'creationTimestamp': creationTimestamp!,
        if (deprecated != null) 'deprecated': deprecated!.toJson(),
        if (description != null) 'description': description!,
        if (id != null) 'id': id!,
        if (kind != null) 'kind': kind!,
        if (name != null) 'name': name!,
        if (region != null) 'region': region!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (status != null) 'status': status!,
        if (supportsPzs != null) 'supportsPzs': supportsPzs!,
      };
}

class ZoneListWarningData {
  /// A key that provides more detail on the warning being returned.
  ///
  /// For example, for warnings where there are no results in a list request for
  /// a particular zone, this key might be scope and the key value might be the
  /// zone name. Other examples might be a key indicating a deprecated resource
  /// and a suggested replacement, or a warning about invalid network settings
  /// (for example, if an instance attempts to perform IP forwarding but is not
  /// enabled for IP forwarding).
  ///
  /// Output only.
  core.String? key;

  /// A warning data value corresponding to the key.
  ///
  /// Output only.
  core.String? value;

  ZoneListWarningData();

  ZoneListWarningData.fromJson(core.Map _json) {
    if (_json.containsKey('key')) {
      key = _json['key'] as core.String;
    }
    if (_json.containsKey('value')) {
      value = _json['value'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (value != null) 'value': value!,
      };
}

/// Informational warning message.
///
/// Output only.
class ZoneListWarning {
  /// A warning code, if applicable.
  ///
  /// For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no
  /// results in the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CLEANUP_FAILED"
  /// - "DEPRECATED_RESOURCE_USED"
  /// - "DEPRECATED_TYPE_USED"
  /// - "DISK_SIZE_LARGER_THAN_IMAGE_SIZE"
  /// - "EXPERIMENTAL_TYPE_USED"
  /// - "EXTERNAL_API_WARNING"
  /// - "FIELD_VALUE_OVERRIDEN"
  /// - "INJECTED_KERNELS_DEPRECATED"
  /// - "LARGE_DEPLOYMENT_WARNING"
  /// - "MISSING_TYPE_DEPENDENCY"
  /// - "NEXT_HOP_ADDRESS_NOT_ASSIGNED"
  /// - "NEXT_HOP_CANNOT_IP_FORWARD"
  /// - "NEXT_HOP_INSTANCE_NOT_FOUND"
  /// - "NEXT_HOP_INSTANCE_NOT_ON_NETWORK"
  /// - "NEXT_HOP_NOT_RUNNING"
  /// - "NOT_CRITICAL_ERROR"
  /// - "NO_RESULTS_ON_PAGE"
  /// - "PARTIAL_SUCCESS"
  /// - "REQUIRED_TOS_AGREEMENT"
  /// - "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
  /// - "RESOURCE_NOT_DELETED"
  /// - "SCHEMA_VALIDATION_IGNORED"
  /// - "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
  /// - "UNDECLARED_PROPERTIES"
  /// - "UNREACHABLE"
  core.String? code;

  /// Metadata about this warning in key: value format.
  ///
  /// For example:
  /// "data": \[ { "key": "scope", "value": "zones/us-east1-d" }
  ///
  /// Output only.
  core.List<ZoneListWarningData>? data;

  /// A human-readable description of the warning code.
  ///
  /// Output only.
  core.String? message;

  ZoneListWarning();

  ZoneListWarning.fromJson(core.Map _json) {
    if (_json.containsKey('code')) {
      code = _json['code'] as core.String;
    }
    if (_json.containsKey('data')) {
      data = (_json['data'] as core.List)
          .map<ZoneListWarningData>((value) => ZoneListWarningData.fromJson(
              value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('message')) {
      message = _json['message'] as core.String;
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (data != null) 'data': data!.map((value) => value.toJson()).toList(),
        if (message != null) 'message': message!,
      };
}

/// Contains a list of zone resources.
class ZoneList {
  /// Unique identifier for the resource; defined by the server.
  ///
  /// Output only.
  core.String? id;

  /// A list of Zone resources.
  core.List<Zone>? items;

  /// Type of resource.
  core.String? kind;

  /// This token allows you to get the next page of results for list requests.
  ///
  /// If the number of results is larger than maxResults, use the nextPageToken
  /// as a value for the query parameter pageToken in the next list request.
  /// Subsequent list requests will have their own nextPageToken to continue
  /// paging through the results.
  ///
  /// Output only.
  core.String? nextPageToken;

  /// Server-defined URL for this resource.
  ///
  /// Output only.
  core.String? selfLink;

  /// Informational warning message.
  ///
  /// Output only.
  ZoneListWarning? warning;

  ZoneList();

  ZoneList.fromJson(core.Map _json) {
    if (_json.containsKey('id')) {
      id = _json['id'] as core.String;
    }
    if (_json.containsKey('items')) {
      items = (_json['items'] as core.List)
          .map<Zone>((value) =>
              Zone.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('kind')) {
      kind = _json['kind'] as core.String;
    }
    if (_json.containsKey('nextPageToken')) {
      nextPageToken = _json['nextPageToken'] as core.String;
    }
    if (_json.containsKey('selfLink')) {
      selfLink = _json['selfLink'] as core.String;
    }
    if (_json.containsKey('warning')) {
      warning = ZoneListWarning.fromJson(
          _json['warning'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (items != null)
          'items': items!.map((value) => value.toJson()).toList(),
        if (kind != null) 'kind': kind!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (selfLink != null) 'selfLink': selfLink!,
        if (warning != null) 'warning': warning!.toJson(),
      };
}

class ZoneSetLabelsRequest {
  /// The fingerprint of the previous set of labels for this resource, used to
  /// detect conflicts.
  ///
  /// The fingerprint is initially generated by Compute Engine and changes after
  /// every request to modify or update labels. You must always provide an
  /// up-to-date fingerprint hash in order to update or change labels. Make a
  /// get() request to the resource to get the latest fingerprint.
  core.String? labelFingerprint;
  core.List<core.int> get labelFingerprintAsBytes =>
      convert.base64.decode(labelFingerprint!);

  set labelFingerprintAsBytes(core.List<core.int> _bytes) {
    labelFingerprint =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// The labels to set for this resource.
  core.Map<core.String, core.String>? labels;

  ZoneSetLabelsRequest();

  ZoneSetLabelsRequest.fromJson(core.Map _json) {
    if (_json.containsKey('labelFingerprint')) {
      labelFingerprint = _json['labelFingerprint'] as core.String;
    }
    if (_json.containsKey('labels')) {
      labels = (_json['labels'] as core.Map<core.String, core.dynamic>).map(
        (key, item) => core.MapEntry(
          key,
          item as core.String,
        ),
      );
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (labelFingerprint != null) 'labelFingerprint': labelFingerprint!,
        if (labels != null) 'labels': labels!,
      };
}

class ZoneSetPolicyRequest {
  /// Flatten Policy to create a backwacd compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify bindings.
  core.List<Binding>? bindings;

  /// Flatten Policy to create a backward compatible wire-format.
  ///
  /// Deprecated. Use 'policy' to specify the etag.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> _bytes) {
    etag =
        convert.base64.encode(_bytes).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// REQUIRED: The complete policy to be applied to the 'resource'.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is
  /// in general a valid policy but certain services (like Projects) might
  /// reject them.
  Policy? policy;

  ZoneSetPolicyRequest();

  ZoneSetPolicyRequest.fromJson(core.Map _json) {
    if (_json.containsKey('bindings')) {
      bindings = (_json['bindings'] as core.List)
          .map<Binding>((value) =>
              Binding.fromJson(value as core.Map<core.String, core.dynamic>))
          .toList();
    }
    if (_json.containsKey('etag')) {
      etag = _json['etag'] as core.String;
    }
    if (_json.containsKey('policy')) {
      policy = Policy.fromJson(
          _json['policy'] as core.Map<core.String, core.dynamic>);
    }
  }

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null)
          'bindings': bindings!.map((value) => value.toJson()).toList(),
        if (etag != null) 'etag': etag!,
        if (policy != null) 'policy': policy!.toJson(),
      };
}
